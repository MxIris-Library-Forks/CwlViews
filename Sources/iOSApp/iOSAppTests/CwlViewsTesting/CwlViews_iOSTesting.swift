//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-04-21 10:30:55 +0000 from the following files:
//   CwlBindingParser.swift
//   CwlAlertActionTesting_iOS.swift
//   CwlAlertControllerTesting_iOS.swift
//   CwlApplicationTesting_iOS.swift
//   CwlBarButtonItemTesting_iOS.swift
//   CwlBarItemTesting_iOS.swift
//   CwlButtonTesting_iOS.swift
//   CwlControlTesting_iOS.swift
//   CwlExtendedViewControllerTesting_iOS.swift
//   CwlGestureRecognizerTesting_iOS.swift
//   CwlImageViewTesting_iOS.swift
//   CwlLabelTesting_iOS.swift
//   CwlLongPressGestureRecognizerTesting_iOS.swift
//   CwlNavigationBarTesting_iOS.swift
//   CwlNavigationControllerTesting_iOS.swift
//   CwlNavigationItemTesting_iOS.swift
//   CwlPageControl.swift
//   CwlPageViewControllerTesting_iOS.swift
//   CwlPanGestureRecognizerTesting_iOS.swift
//   CwlPinchGestureRecognizerTesting_iOS.swift
//   CwlRotationGestureRecognizerTesting_iOS.swift
//   CwlScreenEdgePanGestureRecognizerTesting_iOS.swift
//   CwlScrollViewTesting_iOS.swift
//   CwlSearchBarTesting_iOS.swift
//   CwlSliderTesting_iOS.swift
//   CwlSplitViewControllerTesting_iOS.swift
//   CwlSwipeGestureRecognizerTesting_iOS.swift
//   CwlSwitchTesting_iOS.swift
//   CwlTabBarControllerTesting_iOS.swift
//   CwlTabBarItemTesting_iOS.swift
//   CwlTabBarTesting_iOS.swift
//   CwlTableViewCellTesting_iOS.swift
//   CwlTableViewTesting_iOS.swift
//   CwlTapGestureRecognizerTesting_iOS.swift
//   CwlTextFieldTesting_iOS.swift
//   CwlTextInputTraitsTesting_iOS.swift
//   CwlTextViewTesting_iOS.swift
//   CwlToolbarTesting_iOS.swift
//   CwlViewControllerTesting_iOS.swift
//   CwlViewTesting_iOS.swift
//   CwlWindowTesting_iOS.swift

import UIKit
@testable import iOSApp

struct BindingParser<AssociatedValue, Binding> {
	var parse: (Binding) -> AssociatedValue?
	init(parse: @escaping (Binding) -> AssociatedValue?) {
		self.parse = parse
	}
}

enum BindingParserErrors: Error {
	case multipleMatchesFound
	case noMatchesFound
	case unexpectedArgumentType
}

extension Dynamic {
	var values: [Value] {
		switch self {
		case .constant(let v): return [v]
		case .dynamic(let s): return s.onValue { v in print(v) }.capture().values
		}
	}
	
	var signal: Signal<Value> {
		switch self {
		case .constant(let f): return Signal.just(f)
		case .dynamic(let s): return s
		}
	}
}

extension Binder {
	static func consume(from possibleBinder: Any) throws -> (type: Self.Preparer.Instance.Type, parameters: Self.Preparer.Parameters, bindings: [Self.Preparer.Binding]) {
		if let b = possibleBinder as? Self {
			return b.consume()
		}
		throw BindingParserErrors.unexpectedArgumentType
	}

	static func consumeBindings(from possibleBinder: Any) throws -> [Self.Preparer.Binding] {
		return try consume(from: possibleBinder).bindings
	}
}

extension Binding {
	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values.first
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func valuesArray<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> [AssociatedValue] where S.Element == Self {
		var found: [AssociatedValue]? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<Constant<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.value
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func signal<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> Signal<AssociatedValue> where S.Element == Self {
		var found: Signal<AssociatedValue>? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.signal
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func argument<AssociatedValue, S: Sequence>(for parser: BindingParser<AssociatedValue, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

#if os(iOS)

extension BindingParser where Binding == AlertAction.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var style: BindingParser<Constant<UIAlertAction.Style>, Binding> { return BindingParser<Constant<UIAlertAction.Style>, Binding>(parse: { binding -> Optional<Constant<UIAlertAction.Style>> in if case .style(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Constant<String>, Binding> { return BindingParser<Constant<String>, Binding>(parse: { binding -> Optional<Constant<String>> in if case .title(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }

	//	2. Signal bindings are performed on the object after construction.

	//	3. Action bindings are triggered by the object after construction.
	static var handler: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .handler(let x) = binding { return x } else { return nil } }) }

	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == AlertController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var actions: BindingParser<Constant<[AlertActionConvertible]>, Binding> { return BindingParser<Constant<[AlertActionConvertible]>, Binding>(parse: { binding -> Optional<Constant<[AlertActionConvertible]>> in if case .actions(let x) = binding { return x } else { return nil } }) }
	static var preferredStyle: BindingParser<Constant<UIAlertController.Style>, Binding> { return BindingParser<Constant<UIAlertController.Style>, Binding>(parse: { binding -> Optional<Constant<UIAlertController.Style>> in if case .preferredStyle(let x) = binding { return x } else { return nil } }) }
	static var textFields: BindingParser<Constant<[TextField]>, Binding> { return BindingParser<Constant<[TextField]>, Binding>(parse: { binding -> Optional<Constant<[TextField]>> in if case .textFields(let x) = binding { return x } else { return nil } }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var message: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .message(let x) = binding { return x } else { return nil } }) }
	static var preferredActionIndex: BindingParser<Dynamic<Int?>, Binding> { return BindingParser<Dynamic<Int?>, Binding>(parse: { binding -> Optional<Dynamic<Int?>> in if case .preferredActionIndex(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Application.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var iconBadgeNumber: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .iconBadgeNumber(let x) = binding { return x } else { return nil } }) }
	static var isIdleTimerDisabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isIdleTimerDisabled(let x) = binding { return x } else { return nil } }) }
	static var isNetworkActivityIndicatorVisible: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isNetworkActivityIndicatorVisible(let x) = binding { return x } else { return nil } }) }
	static var shortcutItems: BindingParser<Dynamic<[UIApplicationShortcutItem]?>, Binding> { return BindingParser<Dynamic<[UIApplicationShortcutItem]?>, Binding>(parse: { binding -> Optional<Dynamic<[UIApplicationShortcutItem]?>> in if case .shortcutItems(let x) = binding { return x } else { return nil } }) }
	static var supportShakeToEdit: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .supportShakeToEdit(let x) = binding { return x } else { return nil } }) }
	static var window: BindingParser<Dynamic<WindowConvertible?>, Binding> { return BindingParser<Dynamic<WindowConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<WindowConvertible?>> in if case .window(let x) = binding { return x } else { return nil } }) }

	//	2. Signal bindings are performed on the object after construction.
	static var ignoreInteractionEvents: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .ignoreInteractionEvents(let x) = binding { return x } else { return nil } }) }
	static var registerForRemoteNotifications: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .registerForRemoteNotifications(let x) = binding { return x } else { return nil } }) }

	//	3. Action bindings are triggered by the object after construction.

	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: BindingParser<(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool> in if case .continueUserActivity(let x) = binding { return x } else { return nil } }) }
	static var didBecomeActive: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .didBecomeActive(let x) = binding { return x } else { return nil } }) }
	static var didDecodeRestorableState: BindingParser<(UIApplication, NSKeyedUnarchiver) -> Void, Binding> { return BindingParser<(UIApplication, NSKeyedUnarchiver) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, NSKeyedUnarchiver) -> Void> in if case .didDecodeRestorableState(let x) = binding { return x } else { return nil } }) }
	static var didEnterBackground: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .didEnterBackground(let x) = binding { return x } else { return nil } }) }
	static var didFailToContinueUserActivity: BindingParser<(UIApplication, String, Error) -> Void, Binding> { return BindingParser<(UIApplication, String, Error) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, String, Error) -> Void> in if case .didFailToContinueUserActivity(let x) = binding { return x } else { return nil } }) }
	static var didFinishLaunching: BindingParser<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> in if case .didFinishLaunching(let x) = binding { return x } else { return nil } }) }
	static var didReceiveMemoryWarning: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .didReceiveMemoryWarning(let x) = binding { return x } else { return nil } }) }
	static var didReceiveRemoteNotification: BindingParser<(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void, Binding> { return BindingParser<(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void> in if case .didReceiveRemoteNotification(let x) = binding { return x } else { return nil } }) }
	static var didRegisterRemoteNotifications: BindingParser<(UIApplication, Error) -> Void, Binding> { return BindingParser<(UIApplication, Error) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, Error) -> Void> in if case .didRegisterRemoteNotifications(let x) = binding { return x } else { return nil } }) }
	static var didUpdate: BindingParser<(_ application: UIApplication, NSUserActivity) -> Void, Binding> { return BindingParser<(_ application: UIApplication, NSUserActivity) -> Void, Binding>(parse: { binding -> Optional<(_ application: UIApplication, NSUserActivity) -> Void> in if case .didUpdate(let x) = binding { return x } else { return nil } }) }
	static var handleEventsForBackgroundURLSession: BindingParser<(UIApplication, String, @escaping () -> Void) -> Void, Binding> { return BindingParser<(UIApplication, String, @escaping () -> Void) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, String, @escaping () -> Void) -> Void> in if case .handleEventsForBackgroundURLSession(let x) = binding { return x } else { return nil } }) }
	static var handleWatchKitExtensionRequest: BindingParser<(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void, Binding> { return BindingParser<(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void> in if case .handleWatchKitExtensionRequest(let x) = binding { return x } else { return nil } }) }
	static var open: BindingParser<(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool> in if case .open(let x) = binding { return x } else { return nil } }) }
	static var performAction: BindingParser<(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void, Binding> { return BindingParser<(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void> in if case .performAction(let x) = binding { return x } else { return nil } }) }
	static var performFetch: BindingParser<(UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void, Binding> { return BindingParser<(UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void, Binding>(parse: { binding -> Optional<(UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void> in if case .performFetch(let x) = binding { return x } else { return nil } }) }
	static var protectedDataDidBecomeAvailable: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .protectedDataDidBecomeAvailable(let x) = binding { return x } else { return nil } }) }
	static var protectedDataWillBecomeUnavailable: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .protectedDataWillBecomeUnavailable(let x) = binding { return x } else { return nil } }) }
	static var shouldAllowExtensionPointIdentifier: BindingParser<(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool> in if case .shouldAllowExtensionPointIdentifier(let x) = binding { return x } else { return nil } }) }
	static var shouldRequestHealthAuthorization: BindingParser<(_ application: UIApplication) -> Void, Binding> { return BindingParser<(_ application: UIApplication) -> Void, Binding>(parse: { binding -> Optional<(_ application: UIApplication) -> Void> in if case .shouldRequestHealthAuthorization(let x) = binding { return x } else { return nil } }) }
	static var significantTimeChange: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .significantTimeChange(let x) = binding { return x } else { return nil } }) }
	static var viewControllerWithRestorationPath: BindingParser<(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?, Binding> { return BindingParser<(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?, Binding>(parse: { binding -> Optional<(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?> in if case .viewControllerWithRestorationPath(let x) = binding { return x } else { return nil } }) }
	static var willContinueUserActivity: BindingParser<(_ application: UIApplication, String) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, String) -> Bool> in if case .willContinueUserActivity(let x) = binding { return x } else { return nil } }) }
	static var willEncodeRestorableState: BindingParser<(_ application: UIApplication, NSKeyedArchiver) -> Void, Binding> { return BindingParser<(_ application: UIApplication, NSKeyedArchiver) -> Void, Binding>(parse: { binding -> Optional<(_ application: UIApplication, NSKeyedArchiver) -> Void> in if case .willEncodeRestorableState(let x) = binding { return x } else { return nil } }) }
	static var willEnterForeground: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .willEnterForeground(let x) = binding { return x } else { return nil } }) }
	static var willFinishLaunching: BindingParser<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingParser<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>(parse: { binding -> Optional<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> in if case .willFinishLaunching(let x) = binding { return x } else { return nil } }) }
	static var willResignActive: BindingParser<(UIApplication) -> Void, Binding> { return BindingParser<(UIApplication) -> Void, Binding>(parse: { binding -> Optional<(UIApplication) -> Void> in if case .willResignActive(let x) = binding { return x } else { return nil } }) }
	static var willTerminate: BindingParser<(_ application: UIApplication) -> Void, Binding> { return BindingParser<(_ application: UIApplication) -> Void, Binding>(parse: { binding -> Optional<(_ application: UIApplication) -> Void> in if case .willTerminate(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == BarButtonItem.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BindingParser<Constant<UIBarButtonItem.SystemItem>, Binding> { return BindingParser<Constant<UIBarButtonItem.SystemItem>, Binding>(parse: { binding -> Optional<Constant<UIBarButtonItem.SystemItem>> in if case .systemItem(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backButtonBackgroundImage: BindingParser<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>> in if case .backButtonBackgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backButtonTitlePositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> in if case .backButtonTitlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backgroundVerticalPositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> in if case .backgroundVerticalPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var customView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .customView(let x) = binding { return x } else { return nil } }) }
	static var itemStyle: BindingParser<Dynamic<UIBarButtonItem.Style>, Binding> { return BindingParser<Dynamic<UIBarButtonItem.Style>, Binding>(parse: { binding -> Optional<Dynamic<UIBarButtonItem.Style>> in if case .itemStyle(let x) = binding { return x } else { return nil } }) }
	static var possibleTitles: BindingParser<Dynamic<Set<String>?>, Binding> { return BindingParser<Dynamic<Set<String>?>, Binding>(parse: { binding -> Optional<Dynamic<Set<String>?>> in if case .possibleTitles(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var titlePositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> in if case .titlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var width: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .width(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: BindingParser<TargetAction, Binding> { return BindingParser<TargetAction, Binding>(parse: { binding -> Optional<TargetAction> in if case .action(let x) = binding { return x } else { return nil } }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == BarItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var image: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .image(let x) = binding { return x } else { return nil } }) }
	static var imageInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .imageInsets(let x) = binding { return x } else { return nil } }) }
	static var isEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }
	static var landscapeImagePhone: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .landscapeImagePhone(let x) = binding { return x } else { return nil } }) }
	static var landscapeImagePhoneInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .landscapeImagePhoneInsets(let x) = binding { return x } else { return nil } }) }
	static var tag: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .tag(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var titleTextAttributes: BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>> in if case .titleTextAttributes(let x) = binding { return x } else { return nil } }) }

	//	2. Signal bindings are performed on the object after construction.

	//	3. Action bindings are triggered by the object after construction.

	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Button.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var imageView: BindingParser<Constant<ImageView>, Binding> { return BindingParser<Constant<ImageView>, Binding>(parse: { binding -> Optional<Constant<ImageView>> in if case .imageView(let x) = binding { return x } else { return nil } }) }
	static var titleLabel: BindingParser<Constant<Label>, Binding> { return BindingParser<Constant<Label>, Binding>(parse: { binding -> Optional<Constant<Label>> in if case .titleLabel(let x) = binding { return x } else { return nil } }) }
	static var type: BindingParser<Constant<UIButton.ButtonType>, Binding> { return BindingParser<Constant<UIButton.ButtonType>, Binding>(parse: { binding -> Optional<Constant<UIButton.ButtonType>> in if case .type(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsImageWhenDisabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .adjustsImageWhenDisabled(let x) = binding { return x } else { return nil } }) }
	static var adjustsImageWhenHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .adjustsImageWhenHighlighted(let x) = binding { return x } else { return nil } }) }
	static var attributedTitle: BindingParser<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>> in if case .attributedTitle(let x) = binding { return x } else { return nil } }) }
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var contentEdgeInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .contentEdgeInsets(let x) = binding { return x } else { return nil } }) }
	static var image: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .image(let x) = binding { return x } else { return nil } }) }
	static var imageEdgeInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .imageEdgeInsets(let x) = binding { return x } else { return nil } }) }
	static var showsTouchWhenHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsTouchWhenHighlighted(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<ScopedValues<UIControl.State, String?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, String?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, String?>>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var titleColor: BindingParser<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIColor?>>> in if case .titleColor(let x) = binding { return x } else { return nil } }) }
	static var titleEdgeInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .titleEdgeInsets(let x) = binding { return x } else { return nil } }) }
	static var titleShadowColor: BindingParser<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIColor?>>> in if case .titleShadowColor(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Control.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }
	static var isSelected: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isSelected(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var contentVerticalAlignment: BindingParser<Dynamic<UIControl.ContentVerticalAlignment>, Binding> { return BindingParser<Dynamic<UIControl.ContentVerticalAlignment>, Binding>(parse: { binding -> Optional<Dynamic<UIControl.ContentVerticalAlignment>> in if case .contentVerticalAlignment(let x) = binding { return x } else { return nil } }) }
	static var contentHorizontalAlignment: BindingParser<Dynamic<UIControl.ContentHorizontalAlignment>, Binding> { return BindingParser<Dynamic<UIControl.ContentHorizontalAlignment>, Binding>(parse: { binding -> Optional<Dynamic<UIControl.ContentHorizontalAlignment>> in if case .contentHorizontalAlignment(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var actions: BindingParser<ControlActions, Binding> { return BindingParser<ControlActions, Binding>(parse: { binding -> Optional<ControlActions> in if case .actions(let x) = binding { return x } else { return nil } }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding: ExtendedViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<$2, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didAppear: BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController, Bool) -> Void> in if case .didAppear(let x) = binding { return x } else { return nil } }) }
	static var didDisappear: BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController, Bool) -> Void> in if case .didDisappear(let x) = binding { return x } else { return nil } }) }
	static var didReceiveMemoryWarning: BindingParser<(UIViewController) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController) -> Void> in if case .didReceiveMemoryWarning(let x) = binding { return x } else { return nil } }) }
	static var loadView: BindingParser<() -> ViewConvertible, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<() -> ViewConvertible, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<() -> ViewConvertible> in if case .loadView(let x) = binding { return x } else { return nil } }) }
	static var traitCollectionDidChange: BindingParser<(UIViewController, UITraitCollection?) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController, UITraitCollection?) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController, UITraitCollection?) -> Void> in if case .traitCollectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var willAppear: BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController, Bool) -> Void> in if case .willAppear(let x) = binding { return x } else { return nil } }) }
	static var willDisappear: BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding> { return BindingParser<(UIViewController, Bool) -> Void, ExtendedViewController<Binding.SubclassType>.Binding>(parse: { binding -> Optional<(UIViewController, Bool) -> Void> in if case .willDisappear(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == GestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedPressTypes: BindingParser<Dynamic<[NSNumber]>, Binding> { return BindingParser<Dynamic<[NSNumber]>, Binding>(parse: { binding -> Optional<Dynamic<[NSNumber]>> in if case .allowedPressTypes(let x) = binding { return x } else { return nil } }) }
	static var allowedTouchTypes: BindingParser<Dynamic<[NSNumber]>, Binding> { return BindingParser<Dynamic<[NSNumber]>, Binding>(parse: { binding -> Optional<Dynamic<[NSNumber]>> in if case .allowedTouchTypes(let x) = binding { return x } else { return nil } }) }
	static var cancelsTouchesInView: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .cancelsTouchesInView(let x) = binding { return x } else { return nil } }) }
	static var delaysTouchesBegan: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .delaysTouchesBegan(let x) = binding { return x } else { return nil } }) }
	static var delaysTouchesEnded: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .delaysTouchesEnded(let x) = binding { return x } else { return nil } }) }
	static var requiresExclusiveTouchType: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .requiresExclusiveTouchType(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.
	static var action: BindingParser<SignalInput<Any?>, Binding> { return BindingParser<SignalInput<Any?>, Binding>(parse: { binding -> Optional<SignalInput<Any?>> in if case .action(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBegin: BindingParser<(UIGestureRecognizer) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer) -> Bool> in if case .shouldBegin(let x) = binding { return x } else { return nil } }) }
	static var shouldBeRequiredToFail: BindingParser<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool> in if case .shouldBeRequiredToFail(let x) = binding { return x } else { return nil } }) }
	static var shouldReceivePress: BindingParser<(UIGestureRecognizer, UIPress) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer, UIPress) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer, UIPress) -> Bool> in if case .shouldReceivePress(let x) = binding { return x } else { return nil } }) }
	static var shouldReceiveTouch: BindingParser<(UIGestureRecognizer, UITouch) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer, UITouch) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer, UITouch) -> Bool> in if case .shouldReceiveTouch(let x) = binding { return x } else { return nil } }) }
	static var shouldRecognizeSimultanously: BindingParser<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer, UIGestureRecognizer) -> Bool> in if case .shouldRecognizeSimultanously(let x) = binding { return x } else { return nil } }) }
	static var shouldRequireFailure: BindingParser<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding> { return BindingParser<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding>(parse: { binding -> Optional<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool> in if case .shouldRequireFailure(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == ImageView.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .image(let x) = binding { return x } else { return nil } }) }
	static var highlightedImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .highlightedImage(let x) = binding { return x } else { return nil } }) }
	static var animationImages: BindingParser<Dynamic<[UIImage]?>, Binding> { return BindingParser<Dynamic<[UIImage]?>, Binding>(parse: { binding -> Optional<Dynamic<[UIImage]?>> in if case .animationImages(let x) = binding { return x } else { return nil } }) }
	static var highlightedAnimationImages: BindingParser<Dynamic<[UIImage]?>, Binding> { return BindingParser<Dynamic<[UIImage]?>, Binding>(parse: { binding -> Optional<Dynamic<[UIImage]?>> in if case .highlightedAnimationImages(let x) = binding { return x } else { return nil } }) }
	static var animationDuration: BindingParser<Dynamic<TimeInterval>, Binding> { return BindingParser<Dynamic<TimeInterval>, Binding>(parse: { binding -> Optional<Dynamic<TimeInterval>> in if case .animationDuration(let x) = binding { return x } else { return nil } }) }
	static var animationRepeatCount: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .animationRepeatCount(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var animating: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .animating(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Label.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .adjustsFontSizeToFitWidth(let x) = binding { return x } else { return nil } }) }
	static var allowsDefaultTighteningForTruncation: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsDefaultTighteningForTruncation(let x) = binding { return x } else { return nil } }) }
	static var attributedText: BindingParser<Dynamic<NSAttributedString?>, Binding> { return BindingParser<Dynamic<NSAttributedString?>, Binding>(parse: { binding -> Optional<Dynamic<NSAttributedString?>> in if case .attributedText(let x) = binding { return x } else { return nil } }) }
	static var baselineAdjustment: BindingParser<Dynamic<UIBaselineAdjustment>, Binding> { return BindingParser<Dynamic<UIBaselineAdjustment>, Binding>(parse: { binding -> Optional<Dynamic<UIBaselineAdjustment>> in if case .baselineAdjustment(let x) = binding { return x } else { return nil } }) }
	static var font: BindingParser<Dynamic<UIFont>, Binding> { return BindingParser<Dynamic<UIFont>, Binding>(parse: { binding -> Optional<Dynamic<UIFont>> in if case .font(let x) = binding { return x } else { return nil } }) }
	static var highlightedTextColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .highlightedTextColor(let x) = binding { return x } else { return nil } }) }
	static var isEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var lineBreakMode: BindingParser<Dynamic<NSLineBreakMode>, Binding> { return BindingParser<Dynamic<NSLineBreakMode>, Binding>(parse: { binding -> Optional<Dynamic<NSLineBreakMode>> in if case .lineBreakMode(let x) = binding { return x } else { return nil } }) }
	static var minimumScaleFactor: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .minimumScaleFactor(let x) = binding { return x } else { return nil } }) }
	static var numberOfLines: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfLines(let x) = binding { return x } else { return nil } }) }
	static var preferredMaxLayoutWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .preferredMaxLayoutWidth(let x) = binding { return x } else { return nil } }) }
	static var shadowColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .shadowColor(let x) = binding { return x } else { return nil } }) }
	static var shadowOffset: BindingParser<Dynamic<CGSize>, Binding> { return BindingParser<Dynamic<CGSize>, Binding>(parse: { binding -> Optional<Dynamic<CGSize>> in if case .shadowOffset(let x) = binding { return x } else { return nil } }) }
	static var text: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var textAlignment: BindingParser<Dynamic<NSTextAlignment>, Binding> { return BindingParser<Dynamic<NSTextAlignment>, Binding>(parse: { binding -> Optional<Dynamic<NSTextAlignment>> in if case .textAlignment(let x) = binding { return x } else { return nil } }) }
	static var textColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == LongPressGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .allowableMovement(let x) = binding { return x } else { return nil } }) }
	static var minimumPressDuration: BindingParser<Dynamic<CFTimeInterval>, Binding> { return BindingParser<Dynamic<CFTimeInterval>, Binding>(parse: { binding -> Optional<Dynamic<CFTimeInterval>> in if case .minimumPressDuration(let x) = binding { return x } else { return nil } }) }
	static var numberOfTapsRequired: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfTapsRequired(let x) = binding { return x } else { return nil } }) }
	static var numberOfTouchesRequired: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfTouchesRequired(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == NavigationBar.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backIndicatorImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .backIndicatorImage(let x) = binding { return x } else { return nil } }) }
	static var backIndicatorTransitionMaskImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .backIndicatorTransitionMaskImage(let x) = binding { return x } else { return nil } }) }
	static var barStyle: BindingParser<Dynamic<UIBarStyle>, Binding> { return BindingParser<Dynamic<UIBarStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIBarStyle>> in if case .barStyle(let x) = binding { return x } else { return nil } }) }
	static var barTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .barTintColor(let x) = binding { return x } else { return nil } }) }
	static var isTranslucent: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isTranslucent(let x) = binding { return x } else { return nil } }) }
	static var items: BindingParser<Dynamic<StackMutation<NavigationItemConvertible>>, Binding> { return BindingParser<Dynamic<StackMutation<NavigationItemConvertible>>, Binding>(parse: { binding -> Optional<Dynamic<StackMutation<NavigationItemConvertible>>> in if case .items(let x) = binding { return x } else { return nil } }) }
	static var shadowImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .shadowImage(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var titleTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key: Any]>> in if case .titleTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var titleVerticalPositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> in if case .titleVerticalPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didPop: BindingParser<(UINavigationBar, UINavigationItem) -> Void, Binding> { return BindingParser<(UINavigationBar, UINavigationItem) -> Void, Binding>(parse: { binding -> Optional<(UINavigationBar, UINavigationItem) -> Void> in if case .didPop(let x) = binding { return x } else { return nil } }) }
	static var didPush: BindingParser<(UINavigationBar, UINavigationItem) -> Void, Binding> { return BindingParser<(UINavigationBar, UINavigationItem) -> Void, Binding>(parse: { binding -> Optional<(UINavigationBar, UINavigationItem) -> Void> in if case .didPush(let x) = binding { return x } else { return nil } }) }
	static var position: BindingParser<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingParser<(UIBarPositioning) -> UIBarPosition, Binding>(parse: { binding -> Optional<(UIBarPositioning) -> UIBarPosition> in if case .position(let x) = binding { return x } else { return nil } }) }
	static var shouldPop: BindingParser<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingParser<(UINavigationBar, UINavigationItem) -> Bool, Binding>(parse: { binding -> Optional<(UINavigationBar, UINavigationItem) -> Bool> in if case .shouldPop(let x) = binding { return x } else { return nil } }) }
	static var shouldPush: BindingParser<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingParser<(UINavigationBar, UINavigationItem) -> Bool, Binding>(parse: { binding -> Optional<(UINavigationBar, UINavigationItem) -> Bool> in if case .shouldPush(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == NavigationController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationBar: BindingParser<Constant<NavigationBar>, Binding> { return BindingParser<Constant<NavigationBar>, Binding>(parse: { binding -> Optional<Constant<NavigationBar>> in if case .navigationBar(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var hidesBarsOnSwipe: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBarsOnSwipe(let x) = binding { return x } else { return nil } }) }
	static var hidesBarsOnTap: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBarsOnTap(let x) = binding { return x } else { return nil } }) }
	static var hidesBarsWhenKeyboardAppears: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBarsWhenKeyboardAppears(let x) = binding { return x } else { return nil } }) }
	static var hidesBarsWhenVerticallyCompact: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBarsWhenVerticallyCompact(let x) = binding { return x } else { return nil } }) }
	static var isNavigationBarHidden: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isNavigationBarHidden(let x) = binding { return x } else { return nil } }) }
	static var isToolbarHidden: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isToolbarHidden(let x) = binding { return x } else { return nil } }) }
	static var stack: BindingParser<Dynamic<StackMutation<ViewControllerConvertible>>, Binding> { return BindingParser<Dynamic<StackMutation<ViewControllerConvertible>>, Binding>(parse: { binding -> Optional<Dynamic<StackMutation<ViewControllerConvertible>>> in if case .stack(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var poppedToCount: BindingParser<SignalInput<Int>, Binding> { return BindingParser<SignalInput<Int>, Binding>(parse: { binding -> Optional<SignalInput<Int>> in if case .poppedToCount(let x) = binding { return x } else { return nil } }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationController: BindingParser<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingParser<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?> in if case .animationController(let x) = binding { return x } else { return nil } }) }
	static var interactionController: BindingParser<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingParser<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> in if case .interactionController(let x) = binding { return x } else { return nil } }) }
	static var preferredInterfaceOrientation: BindingParser<(_ navigationController: UINavigationController) -> UIInterfaceOrientation, Binding> { return BindingParser<(_ navigationController: UINavigationController) -> UIInterfaceOrientation, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController) -> UIInterfaceOrientation> in if case .preferredInterfaceOrientation(let x) = binding { return x } else { return nil } }) }
	static var supportedInterfaceOrientations: BindingParser<(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask, Binding> { return BindingParser<(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask> in if case .supportedInterfaceOrientations(let x) = binding { return x } else { return nil } }) }
	static var didShow: BindingParser<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void, Binding> { return BindingParser<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> in if case .didShow(let x) = binding { return x } else { return nil } }) }
	static var willShow: BindingParser<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void, Binding> { return BindingParser<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void, Binding>(parse: { binding -> Optional<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> in if case .willShow(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == NavigationItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backBarButtonItem: BindingParser<Dynamic<BarButtonItemConvertible?>, Binding> { return BindingParser<Dynamic<BarButtonItemConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<BarButtonItemConvertible?>> in if case .backBarButtonItem(let x) = binding { return x } else { return nil } }) }
	static var hidesBackButton: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .hidesBackButton(let x) = binding { return x } else { return nil } }) }
	static var leftBarButtonItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .leftBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var leftItemsSupplementBackButton: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .leftItemsSupplementBackButton(let x) = binding { return x } else { return nil } }) }
	static var prompt: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .prompt(let x) = binding { return x } else { return nil } }) }
	static var rightBarButtonItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .rightBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var titleView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .titleView(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == PageControl.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var currentPage: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .currentPage(let x) = binding { return x } else { return nil } }) }
	static var currentPageIndicatorTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .currentPageIndicatorTintColor(let x) = binding { return x } else { return nil } }) }
	static var defersCurrentPageDisplay: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .defersCurrentPageDisplay(let x) = binding { return x } else { return nil } }) }
	static var numberOfPages: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfPages(let x) = binding { return x } else { return nil } }) }
	static var pageIndicatorTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .pageIndicatorTintColor(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var updateCurrentPageDisplay: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .updateCurrentPageDisplay(let x) = binding { return x } else { return nil } }) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<$2, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationOrientation: BindingParser<Constant<UIPageViewController.NavigationOrientation>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Constant<UIPageViewController.NavigationOrientation>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Constant<UIPageViewController.NavigationOrientation>> in if case .navigationOrientation(let x) = binding { return x } else { return nil } }) }
	static var pageSpacing: BindingParser<Constant<CGFloat>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Constant<CGFloat>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Constant<CGFloat>> in if case .pageSpacing(let x) = binding { return x } else { return nil } }) }
	static var spineLocation: BindingParser<Constant<UIPageViewController.SpineLocation>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Constant<UIPageViewController.SpineLocation>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Constant<UIPageViewController.SpineLocation>> in if case .spineLocation(let x) = binding { return x } else { return nil } }) }
	static var transitionStyle: BindingParser<Constant<UIPageViewController.TransitionStyle>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Constant<UIPageViewController.TransitionStyle>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Constant<UIPageViewController.TransitionStyle>> in if case .transitionStyle(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isDoubleSided: BindingParser<Dynamic<Bool>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Dynamic<Bool>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isDoubleSided(let x) = binding { return x } else { return nil } }) }
	static var pageData: BindingParser<Dynamic<Animatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Dynamic<Animatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Dynamic<Animatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>> in if case .pageData(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var changeCurrentPage: BindingParser<Signal<Animatable<Int, UIPageViewController.NavigationDirection>>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<Signal<Animatable<Int, UIPageViewController.NavigationDirection>>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<Signal<Animatable<Int, UIPageViewController.NavigationDirection>>> in if case .changeCurrentPage(let x) = binding { return x } else { return nil } }) }

	// 3. Action bindings are triggered by the object after construction.
	static var pageChanged: BindingParser<SignalInput<(index: Int, data: Binding.PageDataType)>, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<SignalInput<(index: Int, data: Binding.PageDataType)>, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<SignalInput<(index: Int, data: Binding.PageDataType)>> in if case .pageChanged(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var constructPage: BindingParser<(Binding.PageDataType) -> ViewControllerConvertible, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(Binding.PageDataType) -> ViewControllerConvertible, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(Binding.PageDataType) -> ViewControllerConvertible> in if case .constructPage(let x) = binding { return x } else { return nil } }) }
	static var didFinishAnimating: BindingParser<(UIPageViewController, Bool, [UIViewController], Bool) -> Void, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(UIPageViewController, Bool, [UIViewController], Bool) -> Void, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(UIPageViewController, Bool, [UIViewController], Bool) -> Void> in if case .didFinishAnimating(let x) = binding { return x } else { return nil } }) }
	static var interfaceOrientationForPresentation: BindingParser<(UIPageViewController) -> UIInterfaceOrientation, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(UIPageViewController) -> UIInterfaceOrientation, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(UIPageViewController) -> UIInterfaceOrientation> in if case .interfaceOrientationForPresentation(let x) = binding { return x } else { return nil } }) }
	static var spineLocationFor: BindingParser<(UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation> in if case .spineLocationFor(let x) = binding { return x } else { return nil } }) }
	static var supportedInterfaceOrientations: BindingParser<(UIPageViewController) -> UIInterfaceOrientationMask, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(UIPageViewController) -> UIInterfaceOrientationMask, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(UIPageViewController) -> UIInterfaceOrientationMask> in if case .supportedInterfaceOrientations(let x) = binding { return x } else { return nil } }) }
	static var willTransitionTo: BindingParser<(UIPageViewController, [UIViewController]) -> Void, PageViewController<Binding.PageDataType>.Binding> { return BindingParser<(UIPageViewController, [UIViewController]) -> Void, PageViewController<Binding.PageDataType>.Binding>(parse: { binding -> Optional<(UIPageViewController, [UIViewController]) -> Void> in if case .willTransitionTo(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == PanGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumNumberOfTouches: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .maximumNumberOfTouches(let x) = binding { return x } else { return nil } }) }
	static var minimumNumberOfTouches: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .minimumNumberOfTouches(let x) = binding { return x } else { return nil } }) }
	static var translation: BindingParser<Dynamic<CGPoint>, Binding> { return BindingParser<Dynamic<CGPoint>, Binding>(parse: { binding -> Optional<Dynamic<CGPoint>> in if case .translation(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == PinchGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var scale: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .scale(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == RotationGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotation: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .rotation(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == ScreenEdgePanGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var edges: BindingParser<Dynamic<UIRectEdge>, Binding> { return BindingParser<Dynamic<UIRectEdge>, Binding>(parse: { binding -> Optional<Dynamic<UIRectEdge>> in if case .edges(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == ScrollView.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var panGestureRecognizerStyles: BindingParser<Constant<PanGestureRecognizer>, Binding> { return BindingParser<Constant<PanGestureRecognizer>, Binding>(parse: { binding -> Optional<Constant<PanGestureRecognizer>> in if case .panGestureRecognizerStyles(let x) = binding { return x } else { return nil } }) }
	static var pinchGestureRecognizerStyles: BindingParser<Constant<PinchGestureRecognizer>, Binding> { return BindingParser<Constant<PinchGestureRecognizer>, Binding>(parse: { binding -> Optional<Constant<PinchGestureRecognizer>> in if case .pinchGestureRecognizerStyles(let x) = binding { return x } else { return nil } }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alwaysBounceHorizontal: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .alwaysBounceHorizontal(let x) = binding { return x } else { return nil } }) }
	static var alwaysBounceVertical: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .alwaysBounceVertical(let x) = binding { return x } else { return nil } }) }
	static var bounces: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .bounces(let x) = binding { return x } else { return nil } }) }
	static var bouncesZoom: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .bouncesZoom(let x) = binding { return x } else { return nil } }) }
	static var canCancelContentTouches: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .canCancelContentTouches(let x) = binding { return x } else { return nil } }) }
	static var contentInset: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .contentInset(let x) = binding { return x } else { return nil } }) }
	static var contentInsetAdjustmentBehavior: BindingParser<Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>, Binding> { return BindingParser<Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>, Binding>(parse: { binding -> Optional<Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>> in if case .contentInsetAdjustmentBehavior(let x) = binding { return x } else { return nil } }) }
	static var contentOffset: BindingParser<Dynamic<SetOrAnimate<CGPoint>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<CGPoint>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<CGPoint>>> in if case .contentOffset(let x) = binding { return x } else { return nil } }) }
	static var contentSize: BindingParser<Dynamic<CGSize>, Binding> { return BindingParser<Dynamic<CGSize>, Binding>(parse: { binding -> Optional<Dynamic<CGSize>> in if case .contentSize(let x) = binding { return x } else { return nil } }) }
	static var decelerationRate: BindingParser<Dynamic<UIScrollView.DecelerationRate>, Binding> { return BindingParser<Dynamic<UIScrollView.DecelerationRate>, Binding>(parse: { binding -> Optional<Dynamic<UIScrollView.DecelerationRate>> in if case .decelerationRate(let x) = binding { return x } else { return nil } }) }
	static var delaysContentTouches: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .delaysContentTouches(let x) = binding { return x } else { return nil } }) }
	static var indicatorStyle: BindingParser<Dynamic<UIScrollView.IndicatorStyle>, Binding> { return BindingParser<Dynamic<UIScrollView.IndicatorStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIScrollView.IndicatorStyle>> in if case .indicatorStyle(let x) = binding { return x } else { return nil } }) }
	static var isDirectionalLockEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isDirectionalLockEnabled(let x) = binding { return x } else { return nil } }) }
	static var isPagingEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isPagingEnabled(let x) = binding { return x } else { return nil } }) }
	static var isScrollEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isScrollEnabled(let x) = binding { return x } else { return nil } }) }
	static var maximumZoomScale: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .maximumZoomScale(let x) = binding { return x } else { return nil } }) }
	static var minimumZoomScale: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .minimumZoomScale(let x) = binding { return x } else { return nil } }) }
	static var refreshControl: BindingParser<Dynamic<UIRefreshControl?>, Binding> { return BindingParser<Dynamic<UIRefreshControl?>, Binding>(parse: { binding -> Optional<Dynamic<UIRefreshControl?>> in if case .refreshControl(let x) = binding { return x } else { return nil } }) }
	static var scrollIndicatorInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .scrollIndicatorInsets(let x) = binding { return x } else { return nil } }) }
	static var scrollsToTop: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .scrollsToTop(let x) = binding { return x } else { return nil } }) }
	static var showsHorizontalScrollIndicator: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsHorizontalScrollIndicator(let x) = binding { return x } else { return nil } }) }
	static var showsVerticalScrollIndicator: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsVerticalScrollIndicator(let x) = binding { return x } else { return nil } }) }
	static var zoomScale: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .zoomScale(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollIndicators: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .flashScrollIndicators(let x) = binding { return x } else { return nil } }) }
	static var scrollRectToVisible: BindingParser<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingParser<Signal<(rect: CGRect, animated: Bool)>, Binding>(parse: { binding -> Optional<Signal<(rect: CGRect, animated: Bool)>> in if case .scrollRectToVisible(let x) = binding { return x } else { return nil } }) }
	static var zoom: BindingParser<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingParser<Signal<(rect: CGRect, animated: Bool)>, Binding>(parse: { binding -> Optional<Signal<(rect: CGRect, animated: Bool)>> in if case .zoom(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var userDidScroll: BindingParser<SignalInput<CGPoint>, Binding> { return BindingParser<SignalInput<CGPoint>, Binding>(parse: { binding -> Optional<SignalInput<CGPoint>> in if case .userDidScroll(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didEndDecelerating: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .didEndDecelerating(let x) = binding { return x } else { return nil } }) }
	static var didEndDragging: BindingParser<(UIScrollView, Bool) -> Void, Binding> { return BindingParser<(UIScrollView, Bool) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView, Bool) -> Void> in if case .didEndDragging(let x) = binding { return x } else { return nil } }) }
	static var didEndScrollingAnimation: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .didEndScrollingAnimation(let x) = binding { return x } else { return nil } }) }
	static var didEndZooming: BindingParser<(UIScrollView, UIView?, CGFloat) -> Void, Binding> { return BindingParser<(UIScrollView, UIView?, CGFloat) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView, UIView?, CGFloat) -> Void> in if case .didEndZooming(let x) = binding { return x } else { return nil } }) }
	static var didScroll: BindingParser<(UIScrollView, CGPoint) -> Void, Binding> { return BindingParser<(UIScrollView, CGPoint) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView, CGPoint) -> Void> in if case .didScroll(let x) = binding { return x } else { return nil } }) }
	static var didScrollToTop: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .didScrollToTop(let x) = binding { return x } else { return nil } }) }
	static var didZoom: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .didZoom(let x) = binding { return x } else { return nil } }) }
	static var shouldScrollToTop: BindingParser<(_ scrollView: UIScrollView) -> Bool, Binding> { return BindingParser<(_ scrollView: UIScrollView) -> Bool, Binding>(parse: { binding -> Optional<(_ scrollView: UIScrollView) -> Bool> in if case .shouldScrollToTop(let x) = binding { return x } else { return nil } }) }
	static var viewForZooming: BindingParser<(_ scrollView: UIScrollView) -> UIView?, Binding> { return BindingParser<(_ scrollView: UIScrollView) -> UIView?, Binding>(parse: { binding -> Optional<(_ scrollView: UIScrollView) -> UIView?> in if case .viewForZooming(let x) = binding { return x } else { return nil } }) }
	static var willBeginDecelerating: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .willBeginDecelerating(let x) = binding { return x } else { return nil } }) }
	static var willBeginDragging: BindingParser<(UIScrollView) -> Void, Binding> { return BindingParser<(UIScrollView) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView) -> Void> in if case .willBeginDragging(let x) = binding { return x } else { return nil } }) }
	static var willBeginZooming: BindingParser<(UIScrollView, UIView?) -> Void, Binding> { return BindingParser<(UIScrollView, UIView?) -> Void, Binding>(parse: { binding -> Optional<(UIScrollView, UIView?) -> Void> in if case .willBeginZooming(let x) = binding { return x } else { return nil } }) }
	static var willEndDragging: BindingParser<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding> { return BindingParser<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding>(parse: { binding -> Optional<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void> in if case .willEndDragging(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == SearchBar.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser<Constant<TextInputTraits>, Binding> { return BindingParser<Constant<TextInputTraits>, Binding>(parse: { binding -> Optional<Constant<TextInputTraits>> in if case .textInputTraits(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var barStyle: BindingParser<Dynamic<UIBarStyle>, Binding> { return BindingParser<Dynamic<UIBarStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIBarStyle>> in if case .barStyle(let x) = binding { return x } else { return nil } }) }
	static var image: BindingParser<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<IconAndControlState, UIImage?>>> in if case .image(let x) = binding { return x } else { return nil } }) }
	static var inputAccessoryView: BindingParser<Dynamic<UIView?>, Binding> { return BindingParser<Dynamic<UIView?>, Binding>(parse: { binding -> Optional<Dynamic<UIView?>> in if case .inputAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var isTranslucent: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isTranslucent(let x) = binding { return x } else { return nil } }) }
	static var placeholder: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .placeholder(let x) = binding { return x } else { return nil } }) }
	static var positionAdjustment: BindingParser<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding> { return BindingParser<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>> in if case .positionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var prompt: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .prompt(let x) = binding { return x } else { return nil } }) }
	static var scopeBarButtonBackgroundImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .scopeBarButtonBackgroundImage(let x) = binding { return x } else { return nil } }) }
	static var scopeBarButtonDividerImage: BindingParser<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>> in if case .scopeBarButtonDividerImage(let x) = binding { return x } else { return nil } }) }
	static var scopeBarButtonTitleTextAttributes: BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>> in if case .scopeBarButtonTitleTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var scopeButtonTitles: BindingParser<Dynamic<[String]?>, Binding> { return BindingParser<Dynamic<[String]?>, Binding>(parse: { binding -> Optional<Dynamic<[String]?>> in if case .scopeButtonTitles(let x) = binding { return x } else { return nil } }) }
	static var searchFieldBackgroundImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .searchFieldBackgroundImage(let x) = binding { return x } else { return nil } }) }
	static var searchFieldBackgroundPositionAdjustment: BindingParser<Dynamic<UIOffset>, Binding> { return BindingParser<Dynamic<UIOffset>, Binding>(parse: { binding -> Optional<Dynamic<UIOffset>> in if case .searchFieldBackgroundPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var searchTextPositionAdjustment: BindingParser<Dynamic<UIOffset>, Binding> { return BindingParser<Dynamic<UIOffset>, Binding>(parse: { binding -> Optional<Dynamic<UIOffset>> in if case .searchTextPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var selectedScopeButtonIndex: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .selectedScopeButtonIndex(let x) = binding { return x } else { return nil } }) }
	static var showCancelButton: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .showCancelButton(let x) = binding { return x } else { return nil } }) }
	static var showsBookmarkButton: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsBookmarkButton(let x) = binding { return x } else { return nil } }) }
	static var showsScopeBar: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsScopeBar(let x) = binding { return x } else { return nil } }) }
	static var showsSearchResultsButton: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsSearchResultsButton(let x) = binding { return x } else { return nil } }) }
	static var text: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.

	//	3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var bookmarkButtonClicked: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .bookmarkButtonClicked(let x) = binding { return x } else { return nil } }) }
	static var cancelButtonClicked: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .cancelButtonClicked(let x) = binding { return x } else { return nil } }) }
	static var textDidBeginEditing: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .textDidBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var textDidChange: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .textDidChange(let x) = binding { return x } else { return nil } }) }
	static var textDidEndEditing: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .textDidEndEditing(let x) = binding { return x } else { return nil } }) }
	static var position: BindingParser<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingParser<(UIBarPositioning) -> UIBarPosition, Binding>(parse: { binding -> Optional<(UIBarPositioning) -> UIBarPosition> in if case .position(let x) = binding { return x } else { return nil } }) }
	static var resultsListButtonClicked: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .resultsListButtonClicked(let x) = binding { return x } else { return nil } }) }
	static var searchButtonClicked: BindingParser<(UISearchBar) -> Void, Binding> { return BindingParser<(UISearchBar) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar) -> Void> in if case .searchButtonClicked(let x) = binding { return x } else { return nil } }) }
	static var selectedScopeButtonIndexDidChange: BindingParser<(UISearchBar, Int) -> Void, Binding> { return BindingParser<(UISearchBar, Int) -> Void, Binding>(parse: { binding -> Optional<(UISearchBar, Int) -> Void> in if case .selectedScopeButtonIndexDidChange(let x) = binding { return x } else { return nil } }) }
	static var shouldBeginEditing: BindingParser<(UISearchBar) -> Bool, Binding> { return BindingParser<(UISearchBar) -> Bool, Binding>(parse: { binding -> Optional<(UISearchBar) -> Bool> in if case .shouldBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldChangeText: BindingParser<(UISearchBar, NSRange, String) -> Bool, Binding> { return BindingParser<(UISearchBar, NSRange, String) -> Bool, Binding>(parse: { binding -> Optional<(UISearchBar, NSRange, String) -> Bool> in if case .shouldChangeText(let x) = binding { return x } else { return nil } }) }
	static var shouldEndEditing: BindingParser<(UISearchBar) -> Bool, Binding> { return BindingParser<(UISearchBar) -> Bool, Binding>(parse: { binding -> Optional<(UISearchBar) -> Bool> in if case .shouldEndEditing(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == Slider.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isContinuous: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isContinuous(let x) = binding { return x } else { return nil } }) }
	static var maximumTrackImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .maximumTrackImage(let x) = binding { return x } else { return nil } }) }
	static var maximumTrackTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .maximumTrackTintColor(let x) = binding { return x } else { return nil } }) }
	static var maximumValue: BindingParser<Dynamic<Float>, Binding> { return BindingParser<Dynamic<Float>, Binding>(parse: { binding -> Optional<Dynamic<Float>> in if case .maximumValue(let x) = binding { return x } else { return nil } }) }
	static var maximumValueImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .maximumValueImage(let x) = binding { return x } else { return nil } }) }
	static var minimumTrackImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .minimumTrackImage(let x) = binding { return x } else { return nil } }) }
	static var minimumTrackTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .minimumTrackTintColor(let x) = binding { return x } else { return nil } }) }
	static var minimumValue: BindingParser<Dynamic<Float>, Binding> { return BindingParser<Dynamic<Float>, Binding>(parse: { binding -> Optional<Dynamic<Float>> in if case .minimumValue(let x) = binding { return x } else { return nil } }) }
	static var minimumValueImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .minimumValueImage(let x) = binding { return x } else { return nil } }) }
	static var thumbImage: BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, UIImage?>>> in if case .thumbImage(let x) = binding { return x } else { return nil } }) }
	static var thumbTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .thumbTintColor(let x) = binding { return x } else { return nil } }) }
	static var value: BindingParser<Dynamic<SetOrAnimate<Float>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Float>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Float>>> in if case .value(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == SplitViewController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var backgroundView: BindingParser<Constant<View>, Binding> { return BindingParser<Constant<View>, Binding>(parse: { binding -> Optional<Constant<View>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumPrimaryColumnWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .maximumPrimaryColumnWidth(let x) = binding { return x } else { return nil } }) }
	static var minimumPrimaryColumnWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .minimumPrimaryColumnWidth(let x) = binding { return x } else { return nil } }) }
	static var preferredDisplayMode: BindingParser<Dynamic<UISplitViewController.DisplayMode>, Binding> { return BindingParser<Dynamic<UISplitViewController.DisplayMode>, Binding>(parse: { binding -> Optional<Dynamic<UISplitViewController.DisplayMode>> in if case .preferredDisplayMode(let x) = binding { return x } else { return nil } }) }
	static var preferredPrimaryColumnWidthFraction: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .preferredPrimaryColumnWidthFraction(let x) = binding { return x } else { return nil } }) }
	static var presentsWithGesture: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .presentsWithGesture(let x) = binding { return x } else { return nil } }) }
	static var primaryViewController: BindingParser<Dynamic<ViewControllerConvertible>, Binding> { return BindingParser<Dynamic<ViewControllerConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewControllerConvertible>> in if case .primaryViewController(let x) = binding { return x } else { return nil } }) }
	static var secondaryViewController: BindingParser<Dynamic<ViewControllerConvertible>, Binding> { return BindingParser<Dynamic<ViewControllerConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewControllerConvertible>> in if case .secondaryViewController(let x) = binding { return x } else { return nil } }) }
	static var shouldShowSecondary: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .shouldShowSecondary(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.
	static var dismissedSecondary: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .dismissedSecondary(let x) = binding { return x } else { return nil } }) }
	static var displayModeButton: BindingParser<SignalInput<BarButtonItemConvertible?>, Binding> { return BindingParser<SignalInput<BarButtonItemConvertible?>, Binding>(parse: { binding -> Optional<SignalInput<BarButtonItemConvertible?>> in if case .displayModeButton(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var collapseSecondary: BindingParser<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding> { return BindingParser<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding>(parse: { binding -> Optional<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool> in if case .collapseSecondary(let x) = binding { return x } else { return nil } }) }
	static var preferredInterfaceOrientation: BindingParser<(UISplitViewController) -> UIInterfaceOrientation, Binding> { return BindingParser<(UISplitViewController) -> UIInterfaceOrientation, Binding>(parse: { binding -> Optional<(UISplitViewController) -> UIInterfaceOrientation> in if case .preferredInterfaceOrientation(let x) = binding { return x } else { return nil } }) }
	static var primaryViewControllerForCollapsing: BindingParser<(UISplitViewController) -> UIViewController?, Binding> { return BindingParser<(UISplitViewController) -> UIViewController?, Binding>(parse: { binding -> Optional<(UISplitViewController) -> UIViewController?> in if case .primaryViewControllerForCollapsing(let x) = binding { return x } else { return nil } }) }
	static var primaryViewControllerForExpanding: BindingParser<(UISplitViewController) -> UIViewController?, Binding> { return BindingParser<(UISplitViewController) -> UIViewController?, Binding>(parse: { binding -> Optional<(UISplitViewController) -> UIViewController?> in if case .primaryViewControllerForExpanding(let x) = binding { return x } else { return nil } }) }
	static var separateSecondary: BindingParser<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding> { return BindingParser<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding>(parse: { binding -> Optional<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?> in if case .separateSecondary(let x) = binding { return x } else { return nil } }) }
	static var showPrimaryViewController: BindingParser<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingParser<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>(parse: { binding -> Optional<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> in if case .showPrimaryViewController(let x) = binding { return x } else { return nil } }) }
	static var showSecondaryViewController: BindingParser<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingParser<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>(parse: { binding -> Optional<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> in if case .showSecondaryViewController(let x) = binding { return x } else { return nil } }) }
	static var supportedInterfaceOrientations: BindingParser<(UISplitViewController) -> UIInterfaceOrientationMask, Binding> { return BindingParser<(UISplitViewController) -> UIInterfaceOrientationMask, Binding>(parse: { binding -> Optional<(UISplitViewController) -> UIInterfaceOrientationMask> in if case .supportedInterfaceOrientations(let x) = binding { return x } else { return nil } }) }
	static var targetDisplayModeForAction: BindingParser<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding> { return BindingParser<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding>(parse: { binding -> Optional<(UISplitViewController) -> UISplitViewController.DisplayMode> in if case .targetDisplayModeForAction(let x) = binding { return x } else { return nil } }) }
	static var willChangeDisplayMode: BindingParser<(UISplitViewController, UISplitViewController.DisplayMode) -> Void, Binding> { return BindingParser<(UISplitViewController, UISplitViewController.DisplayMode) -> Void, Binding>(parse: { binding -> Optional<(UISplitViewController, UISplitViewController.DisplayMode) -> Void> in if case .willChangeDisplayMode(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == SwipeGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var direction: BindingParser<Dynamic<UISwipeGestureRecognizer.Direction>, Binding> { return BindingParser<Dynamic<UISwipeGestureRecognizer.Direction>, Binding>(parse: { binding -> Optional<Dynamic<UISwipeGestureRecognizer.Direction>> in if case .direction(let x) = binding { return x } else { return nil } }) }
	static var numberOfTouchesRequired: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfTouchesRequired(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Switch.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isOn: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isOn(let x) = binding { return x } else { return nil } }) }
	static var offImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .offImage(let x) = binding { return x } else { return nil } }) }
	static var onImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .onImage(let x) = binding { return x } else { return nil } }) }
	static var onTintColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .onTintColor(let x) = binding { return x } else { return nil } }) }
	static var thumbTintColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .thumbTintColor(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
extension BindingParser where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<$2, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tabBar: BindingParser<Constant<TabBar<Binding.ItemIdentifierType>>, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<Constant<TabBar<Binding.ItemIdentifierType>>, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Constant<TabBar<Binding.ItemIdentifierType>>> in if case .tabBar(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var customizableItems: BindingParser<Dynamic<Set<Binding.ItemIdentifierType>>, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<Set<Binding.ItemIdentifierType>>, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<Set<Binding.ItemIdentifierType>>> in if case .customizableItems(let x) = binding { return x } else { return nil } }) }
	static var items: BindingParser<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> in if case .items(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var selectItem: BindingParser<Signal<Binding.ItemIdentifierType>, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<Signal<Binding.ItemIdentifierType>, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Signal<Binding.ItemIdentifierType>> in if case .selectItem(let x) = binding { return x } else { return nil } }) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationControllerForTransition: BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType, UIViewController, Binding.ItemIdentifierType) -> UIViewControllerAnimatedTransitioning?, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType, UIViewController, Binding.ItemIdentifierType) -> UIViewControllerAnimatedTransitioning?, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, UIViewController, Binding.ItemIdentifierType, UIViewController, Binding.ItemIdentifierType) -> UIViewControllerAnimatedTransitioning?> in if case .animationControllerForTransition(let x) = binding { return x } else { return nil } }) }
	static var didEndCustomizing: BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> in if case .didEndCustomizing(let x) = binding { return x } else { return nil } }) }
	static var didSelect: BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Void> in if case .didSelect(let x) = binding { return x } else { return nil } }) }
	static var interactionControllerForAnimation: BindingParser<(UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> in if case .interactionControllerForAnimation(let x) = binding { return x } else { return nil } }) }
	static var preferredInterfaceOrientationForPresentation: BindingParser<(UITabBarController) -> UIInterfaceOrientation, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController) -> UIInterfaceOrientation, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController) -> UIInterfaceOrientation> in if case .preferredInterfaceOrientationForPresentation(let x) = binding { return x } else { return nil } }) }
	static var shouldSelect: BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Bool, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Bool, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Bool> in if case .shouldSelect(let x) = binding { return x } else { return nil } }) }
	static var supportedInterfaceOrientations: BindingParser<(UITabBarController) -> UIInterfaceOrientationMask, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController) -> UIInterfaceOrientationMask, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController) -> UIInterfaceOrientationMask> in if case .supportedInterfaceOrientations(let x) = binding { return x } else { return nil } }) }
	static var tabConstructor: BindingParser<(Binding.ItemIdentifierType) -> ViewControllerConvertible, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(Binding.ItemIdentifierType) -> ViewControllerConvertible, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(Binding.ItemIdentifierType) -> ViewControllerConvertible> in if case .tabConstructor(let x) = binding { return x } else { return nil } }) }
	static var willBeginCustomizing: BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType]) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType]) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType]) -> Void> in if case .willBeginCustomizing(let x) = binding { return x } else { return nil } }) }
	static var willEndCustomizing: BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void, TabBarController<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> in if case .willEndCustomizing(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == TabBarItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BindingParser<Constant<UITabBarItem.SystemItem?>, Binding> { return BindingParser<Constant<UITabBarItem.SystemItem?>, Binding>(parse: { binding -> Optional<Constant<UITabBarItem.SystemItem?>> in if case .systemItem(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	static var badgeColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .badgeColor(let x) = binding { return x } else { return nil } }) }
	static var badgeTextAttributes: BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>> in if case .badgeTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var badgeValue: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .badgeValue(let x) = binding { return x } else { return nil } }) }
	static var selectedImage: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .selectedImage(let x) = binding { return x } else { return nil } }) }
	static var titlePositionAdjustment: BindingParser<Dynamic<UIOffset>, Binding> { return BindingParser<Dynamic<UIOffset>, Binding>(parse: { binding -> Optional<Dynamic<UIOffset>> in if case .titlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<$2, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var barStyle: BindingParser<Dynamic<UIBarStyle>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIBarStyle>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIBarStyle>> in if case .barStyle(let x) = binding { return x } else { return nil } }) }
	static var barTintColor: BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .barTintColor(let x) = binding { return x } else { return nil } }) }
	static var isTranslucent: BindingParser<Dynamic<Bool>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<Bool>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isTranslucent(let x) = binding { return x } else { return nil } }) }
	static var itemPositioning: BindingParser<Dynamic<UITabBar.ItemPositioning>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UITabBar.ItemPositioning>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UITabBar.ItemPositioning>> in if case .itemPositioning(let x) = binding { return x } else { return nil } }) }
	static var items: BindingParser<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> in if case .items(let x) = binding { return x } else { return nil } }) }
	static var itemSpacing: BindingParser<Dynamic<CGFloat>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<CGFloat>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .itemSpacing(let x) = binding { return x } else { return nil } }) }
	static var itemWidth: BindingParser<Dynamic<CGFloat>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<CGFloat>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .itemWidth(let x) = binding { return x } else { return nil } }) }
	static var selectionIndicatorImage: BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .selectionIndicatorImage(let x) = binding { return x } else { return nil } }) }
	static var shadowImage: BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIImage?>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .shadowImage(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var unselectedItemTintColor: BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Dynamic<UIColor>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .unselectedItemTintColor(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var customizingItems: BindingParser<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>> in if case .customizingItems(let x) = binding { return x } else { return nil } }) }
	static var selectItem: BindingParser<Signal<Binding.ItemIdentifierType>, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<Signal<Binding.ItemIdentifierType>, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<Signal<Binding.ItemIdentifierType>> in if case .selectItem(let x) = binding { return x } else { return nil } }) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginCustomizing: BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> in if case .didBeginCustomizing(let x) = binding { return x } else { return nil } }) }
	static var didEndCustomizing: BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> in if case .didEndCustomizing(let x) = binding { return x } else { return nil } }) }
	static var didSelectItem: BindingParser<(UITabBar, UITabBarItem, Binding.ItemIdentifierType) -> Void, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBar, UITabBarItem, Binding.ItemIdentifierType) -> Void, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBar, UITabBarItem, Binding.ItemIdentifierType) -> Void> in if case .didSelectItem(let x) = binding { return x } else { return nil } }) }
	static var itemConstructor: BindingParser<(Binding.ItemIdentifierType) -> TabBarItemConvertible, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(Binding.ItemIdentifierType) -> TabBarItemConvertible, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(Binding.ItemIdentifierType) -> TabBarItemConvertible> in if case .itemConstructor(let x) = binding { return x } else { return nil } }) }
	static var willBeginCustomizing: BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> in if case .willBeginCustomizing(let x) = binding { return x } else { return nil } }) }
	static var willEndCustomizing: BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void, TabBar<Binding.ItemIdentifierType>.Binding> { return BindingParser<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void, TabBar<Binding.ItemIdentifierType>.Binding>(parse: { binding -> Optional<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> in if case .willEndCustomizing(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == TableViewCell.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: BindingParser<Constant<UITableViewCell.CellStyle>, Binding> { return BindingParser<Constant<UITableViewCell.CellStyle>, Binding>(parse: { binding -> Optional<Constant<UITableViewCell.CellStyle>> in if case .cellStyle(let x) = binding { return x } else { return nil } }) }
	static var contentView: BindingParser<Constant<View>, Binding> { return BindingParser<Constant<View>, Binding>(parse: { binding -> Optional<Constant<View>> in if case .contentView(let x) = binding { return x } else { return nil } }) }
	static var detailLabel: BindingParser<Constant<Label>, Binding> { return BindingParser<Constant<Label>, Binding>(parse: { binding -> Optional<Constant<Label>> in if case .detailLabel(let x) = binding { return x } else { return nil } }) }
	static var imageView: BindingParser<Constant<ImageView>, Binding> { return BindingParser<Constant<ImageView>, Binding>(parse: { binding -> Optional<Constant<ImageView>> in if case .imageView(let x) = binding { return x } else { return nil } }) }
	static var textLabel: BindingParser<Constant<Label>, Binding> { return BindingParser<Constant<Label>, Binding>(parse: { binding -> Optional<Constant<Label>> in if case .textLabel(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var accessoryType: BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.AccessoryType>> in if case .accessoryType(let x) = binding { return x } else { return nil } }) }
	static var accessoryView: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .accessoryView(let x) = binding { return x } else { return nil } }) }
	static var backgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryType: BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.AccessoryType>> in if case .editingAccessoryType(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryView: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .editingAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var focusStyle: BindingParser<Dynamic<UITableViewCell.FocusStyle>, Binding> { return BindingParser<Dynamic<UITableViewCell.FocusStyle>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.FocusStyle>> in if case .focusStyle(let x) = binding { return x } else { return nil } }) }
	static var indentationLevel: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .indentationLevel(let x) = binding { return x } else { return nil } }) }
	static var indentationWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .indentationWidth(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var isSelected: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isSelected(let x) = binding { return x } else { return nil } }) }
	static var multipleSelectionBackgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .multipleSelectionBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var selectedBackgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .selectedBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditing: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .shouldIndentWhileEditing(let x) = binding { return x } else { return nil } }) }
	static var showsReorderControl: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsReorderControl(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension TableViewBinding {
	static func tableStructure<S: Sequence>(in bindings: S) throws -> TableSectionState<RowDataType> where S.Element == TableView<RowDataType>.Binding {
		var found: TableSectionState<RowDataType>? = nil
		for b in bindings {
			if case .tableData(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.values
				var sections = TableSectionState<RowDataType>()
				for v in values {
					v.value.apply(to: &sections)
				}
				found = sections
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, TableView<Binding.RowDataType>.Binding> { return BindingParser<$2, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Constant<UITableView.Style>> in if case .tableViewStyle(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsMultipleSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var allowsSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var backgroundView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var cellLayoutMarginsFollowReadableWidth: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .cellLayoutMarginsFollowReadableWidth(let x) = binding { return x } else { return nil } }) }
	static var estimatedRowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedRowHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var remembersLastFocusedIndexPath: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .remembersLastFocusedIndexPath(let x) = binding { return x } else { return nil } }) }
	static var rowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .rowHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexMinimumDisplayRowCount: BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .sectionIndexMinimumDisplayRowCount(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTitles: BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<[String]?>> in if case .sectionIndexTitles(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTrackingBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexTrackingBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var separatorColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .separatorColor(let x) = binding { return x } else { return nil } }) }
	static var separatorEffect: BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIVisualEffect?>> in if case .separatorEffect(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var separatorInsetReference: BindingParser<Dynamic<UITableView.SeparatorInsetReference>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UITableView.SeparatorInsetReference>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UITableView.SeparatorInsetReference>> in if case .separatorInsetReference(let x) = binding { return x } else { return nil } }) }
	static var separatorStyle: BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.SeparatorStyle>> in if case .separatorStyle(let x) = binding { return x } else { return nil } }) }
	static var tableData: BindingParser<Dynamic<TableSectionAnimatable<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<TableSectionAnimatable<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<TableSectionAnimatable<Binding.RowDataType>>> in if case .tableData(let x) = binding { return x } else { return nil } }) }
	static var tableFooterView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableFooterView(let x) = binding { return x } else { return nil } }) }
	static var tableHeaderView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableHeaderView(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<IndexPath>>> in if case .deselectRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToNearestSelectedRow: BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<UITableView.ScrollPosition>>> in if case .scrollToNearestSelectedRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition>>> in if case .scrollToRow(let x) = binding { return x } else { return nil } }) }
	static var selectRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition?>>> in if case .selectRow(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var selectionDidChange: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]?>> in if case .selectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var userDidScrollToRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .userDidScrollToRow(let x) = binding { return x } else { return nil } }) }
	static var visibleRowsChanged: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]>> in if case .visibleRowsChanged(let x) = binding { return x } else { return nil } }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var accessoryButtonTapped: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .accessoryButtonTapped(let x) = binding { return x } else { return nil } }) }
	static var canEditRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canEditRow(let x) = binding { return x } else { return nil } }) }
	static var canFocusRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canFocusRow(let x) = binding { return x } else { return nil } }) }
	static var canMoveRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canMoveRow(let x) = binding { return x } else { return nil } }) }
	static var canPerformAction: BindingParser<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> in if case .canPerformAction(let x) = binding { return x } else { return nil } }) }
	static var cellConstructor: BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> in if case .cellConstructor(let x) = binding { return x } else { return nil } }) }
	static var cellIdentifier: BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(TableRow<Binding.RowDataType>) -> String?> in if case .cellIdentifier(let x) = binding { return x } else { return nil } }) }
	static var commit: BindingParser<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void> in if case .commit(let x) = binding { return x } else { return nil } }) }
	static var dataMissingCell: BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(IndexPath) -> TableViewCellConvertible> in if case .dataMissingCell(let x) = binding { return x } else { return nil } }) }
	static var didDeselectRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingCell: BindingParser<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void> in if case .didEndDisplayingCell(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingFooter: BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UIView, Int) -> Void> in if case .didEndDisplayingFooter(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingHeader: BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UIView, Int) -> Void> in if case .didEndDisplayingHeader(let x) = binding { return x } else { return nil } }) }
	static var didEndEditingRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>?) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>?) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>?) -> Void> in if case .didEndEditingRow(let x) = binding { return x } else { return nil } }) }
	static var didHightlightRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didHightlightRow(let x) = binding { return x } else { return nil } }) }
	static var didSelectRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didSelectRow(let x) = binding { return x } else { return nil } }) }
	static var didUnhighlightRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didUnhighlightRow(let x) = binding { return x } else { return nil } }) }
	static var didUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> in if case .didUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var editActionsForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> in if case .editActionsForRow(let x) = binding { return x } else { return nil } }) }
	static var editingStyleForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle> in if case .editingStyleForRow(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForFooter: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .estimatedHeightForFooter(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForHeader: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .estimatedHeightForHeader(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .estimatedHeightForRow(let x) = binding { return x } else { return nil } }) }
	static var footerHeight: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .footerHeight(let x) = binding { return x } else { return nil } }) }
	static var footerView: BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> in if case .footerView(let x) = binding { return x } else { return nil } }) }
	static var headerHeight: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .headerHeight(let x) = binding { return x } else { return nil } }) }
	static var headerView: BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> in if case .headerView(let x) = binding { return x } else { return nil } }) }
	static var heightForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .heightForRow(let x) = binding { return x } else { return nil } }) }
	static var indentationLevelForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int> in if case .indentationLevelForRow(let x) = binding { return x } else { return nil } }) }
	static var indexPathForPreferredFocusedView: BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView) -> IndexPath> in if case .indexPathForPreferredFocusedView(let x) = binding { return x } else { return nil } }) }
	static var moveRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void> in if case .moveRow(let x) = binding { return x } else { return nil } }) }
	static var shouldHighlightRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldHighlightRow(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldIndentWhileEditingRow(let x) = binding { return x } else { return nil } }) }
	static var shouldShowMenuForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldShowMenuForRow(let x) = binding { return x } else { return nil } }) }
	static var shouldUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext) -> Bool> in if case .shouldUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var targetIndexPathForMoveFromRow: BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> in if case .targetIndexPathForMoveFromRow(let x) = binding { return x } else { return nil } }) }
	static var titleForDeleteConfirmationButtonForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?> in if case .titleForDeleteConfirmationButtonForRow(let x) = binding { return x } else { return nil } }) }
	static var willBeginEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> in if case .willBeginEditingRow(let x) = binding { return x } else { return nil } }) }
	static var willDeselectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var willDisplayFooter: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayFooter(let x) = binding { return x } else { return nil } }) }
	static var willDisplayHeader: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayHeader(let x) = binding { return x } else { return nil } }) }
	static var willDisplayRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> in if case .willDisplayRow(let x) = binding { return x } else { return nil } }) }
	static var willSelectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willSelectRow(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == TapGestureRecognizer.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var numberOfTapsRequired: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfTapsRequired(let x) = binding { return x } else { return nil } }) }
	static var numberOfTouchesRequired: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfTouchesRequired(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == TextField.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser<Constant<TextInputTraits>, Binding> { return BindingParser<Constant<TextInputTraits>, Binding>(parse: { binding -> Optional<Constant<TextInputTraits>> in if case .textInputTraits(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .adjustsFontSizeToFitWidth(let x) = binding { return x } else { return nil } }) }
	static var allowsEditingTextAttributes: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsEditingTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var attributedPlaceholder: BindingParser<Dynamic<NSAttributedString?>, Binding> { return BindingParser<Dynamic<NSAttributedString?>, Binding>(parse: { binding -> Optional<Dynamic<NSAttributedString?>> in if case .attributedPlaceholder(let x) = binding { return x } else { return nil } }) }
	static var attributedText: BindingParser<Dynamic<NSAttributedString?>, Binding> { return BindingParser<Dynamic<NSAttributedString?>, Binding>(parse: { binding -> Optional<Dynamic<NSAttributedString?>> in if case .attributedText(let x) = binding { return x } else { return nil } }) }
	static var background: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .background(let x) = binding { return x } else { return nil } }) }
	static var borderStyle: BindingParser<Dynamic<UITextField.BorderStyle>, Binding> { return BindingParser<Dynamic<UITextField.BorderStyle>, Binding>(parse: { binding -> Optional<Dynamic<UITextField.BorderStyle>> in if case .borderStyle(let x) = binding { return x } else { return nil } }) }
	static var clearButtonMode: BindingParser<Dynamic<UITextField.ViewMode>, Binding> { return BindingParser<Dynamic<UITextField.ViewMode>, Binding>(parse: { binding -> Optional<Dynamic<UITextField.ViewMode>> in if case .clearButtonMode(let x) = binding { return x } else { return nil } }) }
	static var clearsOnBeginEditing: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .clearsOnBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var clearsOnInsertion: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .clearsOnInsertion(let x) = binding { return x } else { return nil } }) }
	static var defaultTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key: Any]>> in if case .defaultTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var disabledBackground: BindingParser<Dynamic<UIImage?>, Binding> { return BindingParser<Dynamic<UIImage?>, Binding>(parse: { binding -> Optional<Dynamic<UIImage?>> in if case .disabledBackground(let x) = binding { return x } else { return nil } }) }
	static var font: BindingParser<Dynamic<UIFont?>, Binding> { return BindingParser<Dynamic<UIFont?>, Binding>(parse: { binding -> Optional<Dynamic<UIFont?>> in if case .font(let x) = binding { return x } else { return nil } }) }
	static var inputAccessoryView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .inputAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var inputView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .inputView(let x) = binding { return x } else { return nil } }) }
	static var leftView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .leftView(let x) = binding { return x } else { return nil } }) }
	static var leftViewMode: BindingParser<Dynamic<UITextField.ViewMode>, Binding> { return BindingParser<Dynamic<UITextField.ViewMode>, Binding>(parse: { binding -> Optional<Dynamic<UITextField.ViewMode>> in if case .leftViewMode(let x) = binding { return x } else { return nil } }) }
	static var minimumFontSize: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .minimumFontSize(let x) = binding { return x } else { return nil } }) }
	static var placeholder: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .placeholder(let x) = binding { return x } else { return nil } }) }
	static var rightView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .rightView(let x) = binding { return x } else { return nil } }) }
	static var rightViewMode: BindingParser<Dynamic<UITextField.ViewMode>, Binding> { return BindingParser<Dynamic<UITextField.ViewMode>, Binding>(parse: { binding -> Optional<Dynamic<UITextField.ViewMode>> in if case .rightViewMode(let x) = binding { return x } else { return nil } }) }
	static var text: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var textAlignment: BindingParser<Dynamic<NSTextAlignment>, Binding> { return BindingParser<Dynamic<NSTextAlignment>, Binding>(parse: { binding -> Optional<Dynamic<NSTextAlignment>> in if case .textAlignment(let x) = binding { return x } else { return nil } }) }
	static var textColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	static var typingAttributes: BindingParser<Dynamic<[NSAttributedString.Key: Any]?>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key: Any]?>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key: Any]?>> in if case .typingAttributes(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var resignFirstResponder: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .resignFirstResponder(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: BindingParser<(_ textField: UITextField) -> Void, Binding> { return BindingParser<(_ textField: UITextField) -> Void, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Void> in if case .didBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var didChange: BindingParser<(_ textField: UITextField) -> Void, Binding> { return BindingParser<(_ textField: UITextField) -> Void, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Void> in if case .didChange(let x) = binding { return x } else { return nil } }) }
	static var didEndEditing: BindingParser<(_ textField: UITextField) -> Void, Binding> { return BindingParser<(_ textField: UITextField) -> Void, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Void> in if case .didEndEditing(let x) = binding { return x } else { return nil } }) }
	static var didEndEditingWithReason: BindingParser<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding> { return BindingParser<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding>(parse: { binding -> Optional<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void> in if case .didEndEditingWithReason(let x) = binding { return x } else { return nil } }) }
	static var shouldBeginEditing: BindingParser<(_ textField: UITextField) -> Bool, Binding> { return BindingParser<(_ textField: UITextField) -> Bool, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Bool> in if case .shouldBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldChangeCharacters: BindingParser<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding> { return BindingParser<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding>(parse: { binding -> Optional<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool> in if case .shouldChangeCharacters(let x) = binding { return x } else { return nil } }) }
	static var shouldClear: BindingParser<(_ textField: UITextField) -> Bool, Binding> { return BindingParser<(_ textField: UITextField) -> Bool, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Bool> in if case .shouldClear(let x) = binding { return x } else { return nil } }) }
	static var shouldEndEditing: BindingParser<(_ textField: UITextField) -> Bool, Binding> { return BindingParser<(_ textField: UITextField) -> Bool, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Bool> in if case .shouldEndEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldReturn: BindingParser<(_ textField: UITextField) -> Bool, Binding> { return BindingParser<(_ textField: UITextField) -> Bool, Binding>(parse: { binding -> Optional<(_ textField: UITextField) -> Bool> in if case .shouldReturn(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	static var autocapitalizationType: BindingParser<Dynamic<UITextAutocapitalizationType>, Binding> { return BindingParser<Dynamic<UITextAutocapitalizationType>, Binding>(parse: { binding -> Optional<Dynamic<UITextAutocapitalizationType>> in if case .autocapitalizationType(let x) = binding { return x } else { return nil } }) }
	static var autocorrectionType: BindingParser<Dynamic<UITextAutocorrectionType>, Binding> { return BindingParser<Dynamic<UITextAutocorrectionType>, Binding>(parse: { binding -> Optional<Dynamic<UITextAutocorrectionType>> in if case .autocorrectionType(let x) = binding { return x } else { return nil } }) }
	static var enablesReturnKeyAutomatically: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .enablesReturnKeyAutomatically(let x) = binding { return x } else { return nil } }) }
	static var isSecureTextEntry: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isSecureTextEntry(let x) = binding { return x } else { return nil } }) }
	static var keyboardAppearance: BindingParser<Dynamic<UIKeyboardAppearance>, Binding> { return BindingParser<Dynamic<UIKeyboardAppearance>, Binding>(parse: { binding -> Optional<Dynamic<UIKeyboardAppearance>> in if case .keyboardAppearance(let x) = binding { return x } else { return nil } }) }
	static var keyboardType: BindingParser<Dynamic<UIKeyboardType>, Binding> { return BindingParser<Dynamic<UIKeyboardType>, Binding>(parse: { binding -> Optional<Dynamic<UIKeyboardType>> in if case .keyboardType(let x) = binding { return x } else { return nil } }) }
	static var returnKeyType: BindingParser<Dynamic<UIReturnKeyType>, Binding> { return BindingParser<Dynamic<UIReturnKeyType>, Binding>(parse: { binding -> Optional<Dynamic<UIReturnKeyType>> in if case .returnKeyType(let x) = binding { return x } else { return nil } }) }
	static var smartDashesType: BindingParser<Dynamic<UITextSmartDashesType>, Binding> { return BindingParser<Dynamic<UITextSmartDashesType>, Binding>(parse: { binding -> Optional<Dynamic<UITextSmartDashesType>> in if case .smartDashesType(let x) = binding { return x } else { return nil } }) }
	static var smartInsertDeleteType: BindingParser<Dynamic<UITextSmartInsertDeleteType>, Binding> { return BindingParser<Dynamic<UITextSmartInsertDeleteType>, Binding>(parse: { binding -> Optional<Dynamic<UITextSmartInsertDeleteType>> in if case .smartInsertDeleteType(let x) = binding { return x } else { return nil } }) }
	static var smartQuotesType: BindingParser<Dynamic<UITextSmartQuotesType>, Binding> { return BindingParser<Dynamic<UITextSmartQuotesType>, Binding>(parse: { binding -> Optional<Dynamic<UITextSmartQuotesType>> in if case .smartQuotesType(let x) = binding { return x } else { return nil } }) }
	static var spellCheckingType: BindingParser<Dynamic<UITextSpellCheckingType>, Binding> { return BindingParser<Dynamic<UITextSpellCheckingType>, Binding>(parse: { binding -> Optional<Dynamic<UITextSpellCheckingType>> in if case .spellCheckingType(let x) = binding { return x } else { return nil } }) }
	static var textContentType: BindingParser<Dynamic<UITextContentType>, Binding> { return BindingParser<Dynamic<UITextContentType>, Binding>(parse: { binding -> Optional<Dynamic<UITextContentType>> in if case .textContentType(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == TextView.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser<Constant<TextInputTraits>, Binding> { return BindingParser<Constant<TextInputTraits>, Binding>(parse: { binding -> Optional<Constant<TextInputTraits>> in if case .textInputTraits(let x) = binding { return x } else { return nil } }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsEditingTextAttributes: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsEditingTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var attributedText: BindingParser<Dynamic<NSAttributedString>, Binding> { return BindingParser<Dynamic<NSAttributedString>, Binding>(parse: { binding -> Optional<Dynamic<NSAttributedString>> in if case .attributedText(let x) = binding { return x } else { return nil } }) }
	static var clearsOnInsertion: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .clearsOnInsertion(let x) = binding { return x } else { return nil } }) }
	static var dataDetectorTypes: BindingParser<Dynamic<UIDataDetectorTypes>, Binding> { return BindingParser<Dynamic<UIDataDetectorTypes>, Binding>(parse: { binding -> Optional<Dynamic<UIDataDetectorTypes>> in if case .dataDetectorTypes(let x) = binding { return x } else { return nil } }) }
	static var font: BindingParser<Dynamic<UIFont?>, Binding> { return BindingParser<Dynamic<UIFont?>, Binding>(parse: { binding -> Optional<Dynamic<UIFont?>> in if case .font(let x) = binding { return x } else { return nil } }) }
	static var inputAccessoryView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .inputAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var inputView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .inputView(let x) = binding { return x } else { return nil } }) }
	static var isEditable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEditable(let x) = binding { return x } else { return nil } }) }
	static var isSelectable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isSelectable(let x) = binding { return x } else { return nil } }) }
	static var linkTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key: Any]>> in if case .linkTextAttributes(let x) = binding { return x } else { return nil } }) }
	static var selectedRange: BindingParser<Dynamic<NSRange>, Binding> { return BindingParser<Dynamic<NSRange>, Binding>(parse: { binding -> Optional<Dynamic<NSRange>> in if case .selectedRange(let x) = binding { return x } else { return nil } }) }
	static var text: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var textAlignment: BindingParser<Dynamic<NSTextAlignment>, Binding> { return BindingParser<Dynamic<NSTextAlignment>, Binding>(parse: { binding -> Optional<Dynamic<NSTextAlignment>> in if case .textAlignment(let x) = binding { return x } else { return nil } }) }
	static var textColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	static var textContainerInset: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .textContainerInset(let x) = binding { return x } else { return nil } }) }
	static var typingAttributes: BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key: Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key: Any]>> in if case .typingAttributes(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollRangeToVisible: BindingParser<Signal<NSRange>, Binding> { return BindingParser<Signal<NSRange>, Binding>(parse: { binding -> Optional<Signal<NSRange>> in if case .scrollRangeToVisible(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: BindingParser<(UITextView) -> Void, Binding> { return BindingParser<(UITextView) -> Void, Binding>(parse: { binding -> Optional<(UITextView) -> Void> in if case .didBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var didChange: BindingParser<(UITextView) -> Void, Binding> { return BindingParser<(UITextView) -> Void, Binding>(parse: { binding -> Optional<(UITextView) -> Void> in if case .didChange(let x) = binding { return x } else { return nil } }) }
	static var didChangeSelection: BindingParser<(UITextView) -> Void, Binding> { return BindingParser<(UITextView) -> Void, Binding>(parse: { binding -> Optional<(UITextView) -> Void> in if case .didChangeSelection(let x) = binding { return x } else { return nil } }) }
	static var didEndEditing: BindingParser<(UITextView) -> Void, Binding> { return BindingParser<(UITextView) -> Void, Binding>(parse: { binding -> Optional<(UITextView) -> Void> in if case .didEndEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldBeginEditing: BindingParser<(UITextView) -> Bool, Binding> { return BindingParser<(UITextView) -> Bool, Binding>(parse: { binding -> Optional<(UITextView) -> Bool> in if case .shouldBeginEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldChangeText: BindingParser<(UITextView, NSRange, String) -> Bool, Binding> { return BindingParser<(UITextView, NSRange, String) -> Bool, Binding>(parse: { binding -> Optional<(UITextView, NSRange, String) -> Bool> in if case .shouldChangeText(let x) = binding { return x } else { return nil } }) }
	static var shouldEndEditing: BindingParser<(UITextView) -> Bool, Binding> { return BindingParser<(UITextView) -> Bool, Binding>(parse: { binding -> Optional<(UITextView) -> Bool> in if case .shouldEndEditing(let x) = binding { return x } else { return nil } }) }
	static var shouldInteractWithAttachment: BindingParser<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingParser<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding>(parse: { binding -> Optional<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool> in if case .shouldInteractWithAttachment(let x) = binding { return x } else { return nil } }) }
	static var shouldInteractWithURL: BindingParser<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingParser<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding>(parse: { binding -> Optional<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool> in if case .shouldInteractWithURL(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == Toolbar.Binding {
	// You can easily convert the `Binding` cases 'to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var barStyle: BindingParser<Dynamic<UIBarStyle>, Binding> { return BindingParser<Dynamic<UIBarStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIBarStyle>> in if case .barStyle(let x) = binding { return x } else { return nil } }) }
	static var barTintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .barTintColor(let x) = binding { return x } else { return nil } }) }
	static var isTranslucent: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isTranslucent(let x) = binding { return x } else { return nil } }) }
	static var items: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .items(let x) = binding { return x } else { return nil } }) }
	static var shadowImage: BindingParser<Dynamic<ScopedValues<UIBarPosition, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarPosition, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarPosition, UIImage?>>> in if case .shadowImage(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var position: BindingParser<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingParser<(UIBarPositioning) -> UIBarPosition, Binding>(parse: { binding -> Optional<(UIBarPositioning) -> UIBarPosition> in if case .position(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == ViewController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationItem: BindingParser<Constant<NavigationItem>, Binding> { return BindingParser<Constant<NavigationItem>, Binding>(parse: { binding -> Optional<Constant<NavigationItem>> in if case .navigationItem(let x) = binding { return x } else { return nil } }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var additionalSafeAreaInsets: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .additionalSafeAreaInsets(let x) = binding { return x } else { return nil } }) }
	static var children: BindingParser<Dynamic<[ViewControllerConvertible]>, Binding> { return BindingParser<Dynamic<[ViewControllerConvertible]>, Binding>(parse: { binding -> Optional<Dynamic<[ViewControllerConvertible]>> in if case .children(let x) = binding { return x } else { return nil } }) }
	static var definesPresentationContext: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .definesPresentationContext(let x) = binding { return x } else { return nil } }) }
	static var edgesForExtendedLayout: BindingParser<Dynamic<UIRectEdge>, Binding> { return BindingParser<Dynamic<UIRectEdge>, Binding>(parse: { binding -> Optional<Dynamic<UIRectEdge>> in if case .edgesForExtendedLayout(let x) = binding { return x } else { return nil } }) }
	static var extendedLayoutIncludesOpaqueBars: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .extendedLayoutIncludesOpaqueBars(let x) = binding { return x } else { return nil } }) }
	static var hidesBottomBarWhenPushed: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBottomBarWhenPushed(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var isModalInPopover: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isModalInPopover(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationCapturesStatusBarAppearance: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .modalPresentationCapturesStatusBarAppearance(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationStyle: BindingParser<Dynamic<UIModalPresentationStyle>, Binding> { return BindingParser<Dynamic<UIModalPresentationStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIModalPresentationStyle>> in if case .modalPresentationStyle(let x) = binding { return x } else { return nil } }) }
	static var modalTransitionStyle: BindingParser<Dynamic<UIModalTransitionStyle>, Binding> { return BindingParser<Dynamic<UIModalTransitionStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIModalTransitionStyle>> in if case .modalTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var preferredContentSize: BindingParser<Dynamic<CGSize>, Binding> { return BindingParser<Dynamic<CGSize>, Binding>(parse: { binding -> Optional<Dynamic<CGSize>> in if case .preferredContentSize(let x) = binding { return x } else { return nil } }) }
	static var providesPresentationContextTransitionStyle: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .providesPresentationContextTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var restorationClass: BindingParser<Dynamic<UIViewControllerRestoration.Type?>, Binding> { return BindingParser<Dynamic<UIViewControllerRestoration.Type?>, Binding>(parse: { binding -> Optional<Dynamic<UIViewControllerRestoration.Type?>> in if case .restorationClass(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }
	static var tabBarItem: BindingParser<Dynamic<TabBarItemConvertible>, Binding> { return BindingParser<Dynamic<TabBarItemConvertible>, Binding>(parse: { binding -> Optional<Dynamic<TabBarItemConvertible>> in if case .tabBarItem(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var toolbarItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .toolbarItems(let x) = binding { return x } else { return nil } }) }
	static var transitioningDelegate: BindingParser<Dynamic<UIViewControllerTransitioningDelegate>, Binding> { return BindingParser<Dynamic<UIViewControllerTransitioningDelegate>, Binding>(parse: { binding -> Optional<Dynamic<UIViewControllerTransitioningDelegate>> in if case .transitioningDelegate(let x) = binding { return x } else { return nil } }) }
	static var view: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .view(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var present: BindingParser<Signal<Animatable<ModalPresentation?, ()>>, Binding> { return BindingParser<Signal<Animatable<ModalPresentation?, ()>>, Binding>(parse: { binding -> Optional<Signal<Animatable<ModalPresentation?, ()>>> in if case .present(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var childrenLayout: BindingParser<([UIView]) -> Layout, Binding> { return BindingParser<([UIView]) -> Layout, Binding>(parse: { binding -> Optional<([UIView]) -> Layout> in if case .childrenLayout(let x) = binding { return x } else { return nil } }) }
}

#endif

#if os(iOS)

extension BindingParser where Binding == View.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var layer: BindingParser<Constant<Layer>, Binding> { return BindingParser<Constant<Layer>, Binding>(parse: { binding -> Optional<Constant<Layer>> in if case .layer(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alpha: BindingParser<Dynamic<(CGFloat)>, Binding> { return BindingParser<Dynamic<(CGFloat)>, Binding>(parse: { binding -> Optional<Dynamic<(CGFloat)>> in if case .alpha(let x) = binding { return x } else { return nil } }) }
	static var backgroundColor: BindingParser<Dynamic<(UIColor?)>, Binding> { return BindingParser<Dynamic<(UIColor?)>, Binding>(parse: { binding -> Optional<Dynamic<(UIColor?)>> in if case .backgroundColor(let x) = binding { return x } else { return nil } }) }
	static var clearsContextBeforeDrawing: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .clearsContextBeforeDrawing(let x) = binding { return x } else { return nil } }) }
	static var clipsToBounds: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .clipsToBounds(let x) = binding { return x } else { return nil } }) }
	static var contentMode: BindingParser<Dynamic<(UIView.ContentMode)>, Binding> { return BindingParser<Dynamic<(UIView.ContentMode)>, Binding>(parse: { binding -> Optional<Dynamic<(UIView.ContentMode)>> in if case .contentMode(let x) = binding { return x } else { return nil } }) }
	static var gestureRecognizers: BindingParser<Dynamic<[GestureRecognizerConvertible]>, Binding> { return BindingParser<Dynamic<[GestureRecognizerConvertible]>, Binding>(parse: { binding -> Optional<Dynamic<[GestureRecognizerConvertible]>> in if case .gestureRecognizers(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentCompressionResistancePriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .horizontalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentHuggingPriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .horizontalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }
	static var isExclusiveTouch: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isExclusiveTouch(let x) = binding { return x } else { return nil } }) }
	static var isHidden: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isHidden(let x) = binding { return x } else { return nil } }) }
	static var isMultipleTouchEnabled: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isMultipleTouchEnabled(let x) = binding { return x } else { return nil } }) }
	static var isOpaque: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isOpaque(let x) = binding { return x } else { return nil } }) }
	static var isUserInteractionEnabled: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isUserInteractionEnabled(let x) = binding { return x } else { return nil } }) }
	static var layout: BindingParser<Dynamic<Layout>, Binding> { return BindingParser<Dynamic<Layout>, Binding>(parse: { binding -> Optional<Dynamic<Layout>> in if case .layout(let x) = binding { return x } else { return nil } }) }
	static var layoutMargins: BindingParser<Dynamic<(UIEdgeInsets)>, Binding> { return BindingParser<Dynamic<(UIEdgeInsets)>, Binding>(parse: { binding -> Optional<Dynamic<(UIEdgeInsets)>> in if case .layoutMargins(let x) = binding { return x } else { return nil } }) }
	static var mask: BindingParser<Dynamic<(ViewConvertible?)>, Binding> { return BindingParser<Dynamic<(ViewConvertible?)>, Binding>(parse: { binding -> Optional<Dynamic<(ViewConvertible?)>> in if case .mask(let x) = binding { return x } else { return nil } }) }
	static var motionEffects: BindingParser<Dynamic<([UIMotionEffect])>, Binding> { return BindingParser<Dynamic<([UIMotionEffect])>, Binding>(parse: { binding -> Optional<Dynamic<([UIMotionEffect])>> in if case .motionEffects(let x) = binding { return x } else { return nil } }) }
	static var preservesSuperviewLayoutMargins: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .preservesSuperviewLayoutMargins(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }
	static var semanticContentAttribute: BindingParser<Dynamic<(UISemanticContentAttribute)>, Binding> { return BindingParser<Dynamic<(UISemanticContentAttribute)>, Binding>(parse: { binding -> Optional<Dynamic<(UISemanticContentAttribute)>> in if case .semanticContentAttribute(let x) = binding { return x } else { return nil } }) }
	static var tag: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .tag(let x) = binding { return x } else { return nil } }) }
	static var tintAdjustmentMode: BindingParser<Dynamic<(UIView.TintAdjustmentMode)>, Binding> { return BindingParser<Dynamic<(UIView.TintAdjustmentMode)>, Binding>(parse: { binding -> Optional<Dynamic<(UIView.TintAdjustmentMode)>> in if case .tintAdjustmentMode(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<(UIColor)>, Binding> { return BindingParser<Dynamic<(UIColor)>, Binding>(parse: { binding -> Optional<Dynamic<(UIColor)>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var verticalContentCompressionResistancePriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .verticalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var verticalContentHuggingPriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .verticalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .becomeFirstResponder(let x) = binding { return x } else { return nil } }) }
	static var endEditing: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .endEditing(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Binding == Window.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var frame: BindingParser<Dynamic<CGRect>, Binding> { return BindingParser<Dynamic<CGRect>, Binding>(parse: { binding -> Optional<Dynamic<CGRect>> in if case .frame(let x) = binding { return x } else { return nil } }) }
	static var rootViewController: BindingParser<Dynamic<ViewControllerConvertible>, Binding> { return BindingParser<Dynamic<ViewControllerConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewControllerConvertible>> in if case .rootViewController(let x) = binding { return x } else { return nil } }) }
	static var screen: BindingParser<Dynamic<UIScreen>, Binding> { return BindingParser<Dynamic<UIScreen>, Binding>(parse: { binding -> Optional<Dynamic<UIScreen>> in if case .screen(let x) = binding { return x } else { return nil } }) }
	static var windowLevel: BindingParser<Dynamic<UIWindow.Level>, Binding> { return BindingParser<Dynamic<UIWindow.Level>, Binding>(parse: { binding -> Optional<Dynamic<UIWindow.Level>> in if case .windowLevel(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var makeKey: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .makeKey(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeVisible: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeVisible(let x) = binding { return x } else { return nil } }) }
	static var didBecomeHidden: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeHidden(let x) = binding { return x } else { return nil } }) }
	static var didBecomeKey: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeKey(let x) = binding { return x } else { return nil } }) }
	static var didResignKey: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didResignKey(let x) = binding { return x } else { return nil } }) }
	static var keyboardWillShow: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardWillShow(let x) = binding { return x } else { return nil } }) }
	static var keyboardDidShow: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardDidShow(let x) = binding { return x } else { return nil } }) }
	static var keyboardWillHide: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardWillHide(let x) = binding { return x } else { return nil } }) }
	static var keyboardDidHide: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardDidHide(let x) = binding { return x } else { return nil } }) }
	static var keyboardWillChangeFrame: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardWillChangeFrame(let x) = binding { return x } else { return nil } }) }
	static var keyboardDidChangeFrame: BindingParser<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]?>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]?>> in if case .keyboardDidChangeFrame(let x) = binding { return x } else { return nil } }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif
