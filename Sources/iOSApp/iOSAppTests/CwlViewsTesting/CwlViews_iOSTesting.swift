//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-04-19 12:09:48 +0000 from the following files:
//   CwlBindingParser.swift
//   CwlBarButtonItemTesting.swift
//   CwlLabelTesting.swift
//   CwlNavigationItemTesting.swift
//   CwlTableViewCellTesting.swift
//   CwlTableViewTesting.swift
//   CwlViewControllerTesting.swift
//   CwlViewTesting.swift

import UIKit

struct BindingParser<AssociatedValue, Binding> {
	var parse: (Binding) -> AssociatedValue?
	init(parse: @escaping (Binding) -> AssociatedValue?) {
		self.parse = parse
	}
}

enum BindingParserErrors: Error {
	case multipleMatchesFound
	case noMatchesFound
	case unexpectedArgumentType
}

extension Binder {
	static func consumeBindings(from possibleBinder: Any) throws -> [Self.Binding] {
		if let b = possibleBinder as? Self {
			return b.consumeBindings()
		}
		throw BindingParserErrors.unexpectedArgumentType
	}
}

extension BaseBinding {
	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.captureValues().last
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func valuesArray<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> [AssociatedValue] where S.Element == Self {
		var found: [AssociatedValue]? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.captureValues()
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
 	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<Constant<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.value
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func signal<AssociatedValue, S: Sequence>(for parser: BindingParser<Dynamic<AssociatedValue>, Self>, in bindings: S) throws -> Signal<AssociatedValue> where S.Element == Self {
		var found: Signal<AssociatedValue>? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.signal()
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func argument<AssociatedValue, S: Sequence>(for parser: BindingParser<AssociatedValue, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Binding == BarButtonItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var barButtonSystemItem: BindingParser<Constant<UIBarButtonItem.SystemItem>, Binding> { return BindingParser<Constant<UIBarButtonItem.SystemItem>, Binding>(parse: { binding -> Optional<Constant<UIBarButtonItem.SystemItem>> in if case .barButtonSystemItem(let x) = binding { return x } else { return nil } }) }
	static var itemStyle: BindingParser<Dynamic<UIBarButtonItem.Style>, Binding> { return BindingParser<Dynamic<UIBarButtonItem.Style>, Binding>(parse: { binding -> Optional<Dynamic<UIBarButtonItem.Style>> in if case .itemStyle(let x) = binding { return x } else { return nil } }) }
	static var possibleTitles: BindingParser<Dynamic<Set<String>?>, Binding> { return BindingParser<Dynamic<Set<String>?>, Binding>(parse: { binding -> Optional<Dynamic<Set<String>?>> in if case .possibleTitles(let x) = binding { return x } else { return nil } }) }
	static var width: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .width(let x) = binding { return x } else { return nil } }) }
	static var customView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .customView(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var backgroundImage: BindingParser<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backButtonBackgroundImage: BindingParser<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingParser<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>> in if case .backButtonBackgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backButtonTitlePositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> in if case .backButtonTitlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var backgroundVerticalPositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> in if case .backgroundVerticalPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var titlePositionAdjustment: BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> in if case .titlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var action: BindingParser<TargetAction, Binding> { return BindingParser<TargetAction, Binding>(parse: { binding -> Optional<TargetAction> in if case .action(let x) = binding { return x } else { return nil } }) }
}

extension BindingParser where Binding == Label.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var text: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var attributedText: BindingParser<Dynamic<NSAttributedString?>, Binding> { return BindingParser<Dynamic<NSAttributedString?>, Binding>(parse: { binding -> Optional<Dynamic<NSAttributedString?>> in if case .attributedText(let x) = binding { return x } else { return nil } }) }
	static var font: BindingParser<Dynamic<UIFont>, Binding> { return BindingParser<Dynamic<UIFont>, Binding>(parse: { binding -> Optional<Dynamic<UIFont>> in if case .font(let x) = binding { return x } else { return nil } }) }
	static var textColor: BindingParser<Dynamic<UIColor>, Binding> { return BindingParser<Dynamic<UIColor>, Binding>(parse: { binding -> Optional<Dynamic<UIColor>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	static var textAlignment: BindingParser<Dynamic<NSTextAlignment>, Binding> { return BindingParser<Dynamic<NSTextAlignment>, Binding>(parse: { binding -> Optional<Dynamic<NSTextAlignment>> in if case .textAlignment(let x) = binding { return x } else { return nil } }) }
	static var lineBreakMode: BindingParser<Dynamic<NSLineBreakMode>, Binding> { return BindingParser<Dynamic<NSLineBreakMode>, Binding>(parse: { binding -> Optional<Dynamic<NSLineBreakMode>> in if case .lineBreakMode(let x) = binding { return x } else { return nil } }) }
	static var isEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }
	static var adjustsFontSizeToFitWidth: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .adjustsFontSizeToFitWidth(let x) = binding { return x } else { return nil } }) }
	static var allowsDefaultTighteningForTruncation: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsDefaultTighteningForTruncation(let x) = binding { return x } else { return nil } }) }
	static var baselineAdjustment: BindingParser<Dynamic<UIBaselineAdjustment>, Binding> { return BindingParser<Dynamic<UIBaselineAdjustment>, Binding>(parse: { binding -> Optional<Dynamic<UIBaselineAdjustment>> in if case .baselineAdjustment(let x) = binding { return x } else { return nil } }) }
	static var minimumScaleFactor: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .minimumScaleFactor(let x) = binding { return x } else { return nil } }) }
	static var numberOfLines: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .numberOfLines(let x) = binding { return x } else { return nil } }) }
	static var highlightedTextColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .highlightedTextColor(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var shadowColor: BindingParser<Dynamic<UIColor?>, Binding> { return BindingParser<Dynamic<UIColor?>, Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .shadowColor(let x) = binding { return x } else { return nil } }) }
	static var shadowOffset: BindingParser<Dynamic<CGSize>, Binding> { return BindingParser<Dynamic<CGSize>, Binding>(parse: { binding -> Optional<Dynamic<CGSize>> in if case .shadowOffset(let x) = binding { return x } else { return nil } }) }
	static var preferredMaxLayoutWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .preferredMaxLayoutWidth(let x) = binding { return x } else { return nil } }) }
}

extension BindingParser where Binding == NavigationItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var titleView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .titleView(let x) = binding { return x } else { return nil } }) }
	static var prompt: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .prompt(let x) = binding { return x } else { return nil } }) }
	static var backBarButtonItem: BindingParser<Dynamic<BarButtonItemConvertible?>, Binding> { return BindingParser<Dynamic<BarButtonItemConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<BarButtonItemConvertible?>> in if case .backBarButtonItem(let x) = binding { return x } else { return nil } }) }
	static var hidesBackButton: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .hidesBackButton(let x) = binding { return x } else { return nil } }) }
	static var leftBarButtonItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .leftBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var rightBarButtonItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .rightBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var leftItemsSupplementBackButton: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .leftItemsSupplementBackButton(let x) = binding { return x } else { return nil } }) }
}

extension BindingParser where Binding == TableViewCell.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: BindingParser<Constant<UITableViewCell.CellStyle>, Binding> { return BindingParser<Constant<UITableViewCell.CellStyle>, Binding>(parse: { binding -> Optional<Constant<UITableViewCell.CellStyle>> in if case .cellStyle(let x) = binding { return x } else { return nil } }) }
	static var textLabel: BindingParser<Constant<Label>, Binding> { return BindingParser<Constant<Label>, Binding>(parse: { binding -> Optional<Constant<Label>> in if case .textLabel(let x) = binding { return x } else { return nil } }) }
	static var detailLabel: BindingParser<Constant<Label>, Binding> { return BindingParser<Constant<Label>, Binding>(parse: { binding -> Optional<Constant<Label>> in if case .detailLabel(let x) = binding { return x } else { return nil } }) }
	static var imageView: BindingParser<Constant<ImageView>, Binding> { return BindingParser<Constant<ImageView>, Binding>(parse: { binding -> Optional<Constant<ImageView>> in if case .imageView(let x) = binding { return x } else { return nil } }) }
	static var contentView: BindingParser<Constant<View>, Binding> { return BindingParser<Constant<View>, Binding>(parse: { binding -> Optional<Constant<View>> in if case .contentView(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var selectedBackgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .selectedBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var multipleSelectionBackgroundView: BindingParser<Dynamic<ViewConvertible?>, Binding> { return BindingParser<Dynamic<ViewConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .multipleSelectionBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var accessoryType: BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.AccessoryType>> in if case .accessoryType(let x) = binding { return x } else { return nil } }) }
	static var accessoryView: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .accessoryView(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryType: BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingParser<Dynamic<UITableViewCell.AccessoryType>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.AccessoryType>> in if case .editingAccessoryType(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryView: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .editingAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var isSelected: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isSelected(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var showsReorderControl: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .showsReorderControl(let x) = binding { return x } else { return nil } }) }
	static var indentationLevel: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .indentationLevel(let x) = binding { return x } else { return nil } }) }
	static var indentationWidth: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .indentationWidth(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditing: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .shouldIndentWhileEditing(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<Dynamic<UIEdgeInsets>, Binding> { return BindingParser<Dynamic<UIEdgeInsets>, Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var focusStyle: BindingParser<Dynamic<UITableViewCell.FocusStyle>, Binding> { return BindingParser<Dynamic<UITableViewCell.FocusStyle>, Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.FocusStyle>> in if case .focusStyle(let x) = binding { return x } else { return nil } }) }
}

extension TableViewBinding {
	static func tableStructure<S: Sequence>(in bindings: S) throws -> RangeMutationState<TableSectionState<RowDataType>> where S.Element == TableView<RowDataType>.Binding {
		var found: RangeMutationState<TableSectionState<RowDataType>>? = nil
		for b in bindings {
			if case .tableData(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.captureValues()
				var sections = RangeMutationState<TableSectionState<RowDataType>>()
				for v in values {
					v.apply(to: &sections)
				}
				found = sections
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Constant<UITableView.Style>> in if case .tableViewStyle(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsMultipleSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var allowsSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var backgroundView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var cellLayoutMarginsFollowReadableWidth: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .cellLayoutMarginsFollowReadableWidth(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var estimatedRowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedRowHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var remembersLastFocusedIndexPath: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .remembersLastFocusedIndexPath(let x) = binding { return x } else { return nil } }) }
	static var rowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .rowHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexMinimumDisplayRowCount: BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .sectionIndexMinimumDisplayRowCount(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTrackingBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexTrackingBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTitles: BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<[String]?>> in if case .sectionIndexTitles(let x) = binding { return x } else { return nil } }) }
	static var separatorColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .separatorColor(let x) = binding { return x } else { return nil } }) }
	static var separatorEffect: BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIVisualEffect?>> in if case .separatorEffect(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var separatorStyle: BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.SeparatorStyle>> in if case .separatorStyle(let x) = binding { return x } else { return nil } }) }
	static var tableFooterView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableFooterView(let x) = binding { return x } else { return nil } }) }
	static var tableHeaderView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableHeaderView(let x) = binding { return x } else { return nil } }) }
	static var tableData: BindingParser<Dynamic<TableData<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<TableData<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<TableData<Binding.RowDataType>>> in if case .tableData(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<IndexPath>>> in if case .deselectRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToNearestSelectedRow: BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<UITableView.ScrollPosition>>> in if case .scrollToNearestSelectedRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition>>> in if case .scrollToRow(let x) = binding { return x } else { return nil } }) }
	static var selectRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition?>>> in if case .selectRow(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var userDidScrollToRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .userDidScrollToRow(let x) = binding { return x } else { return nil } }) }
	static var accessoryButtonTapped: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .accessoryButtonTapped(let x) = binding { return x } else { return nil } }) }
	static var didDeselectRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingFooter: BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<Int>> in if case .didEndDisplayingFooter(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingHeader: BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<Int>> in if case .didEndDisplayingHeader(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didEndDisplayingRow(let x) = binding { return x } else { return nil } }) }
	static var didEndEditingRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>?>> in if case .didEndEditingRow(let x) = binding { return x } else { return nil } }) }
	static var didHightlightRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didHightlightRow(let x) = binding { return x } else { return nil } }) }
	static var didSelectRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didSelectRow(let x) = binding { return x } else { return nil } }) }
	static var didUnhighlightRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didUnhighlightRow(let x) = binding { return x } else { return nil } }) }
	static var moveRow: BindingParser<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>> in if case .moveRow(let x) = binding { return x } else { return nil } }) }
	static var selectionDidChange: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]?>> in if case .selectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var visibleRowsChanged: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]>> in if case .visibleRowsChanged(let x) = binding { return x } else { return nil } }) }
	static var commit: BindingParser<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>> in if case .commit(let x) = binding { return x } else { return nil } }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var cellIdentifier: BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(TableRow<Binding.RowDataType>) -> String?> in if case .cellIdentifier(let x) = binding { return x } else { return nil } }) }
	static var canEditRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canEditRow(let x) = binding { return x } else { return nil } }) }
	static var canFocusRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canFocusRow(let x) = binding { return x } else { return nil } }) }
	static var canMoveRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canMoveRow(let x) = binding { return x } else { return nil } }) }
	static var canPerformAction: BindingParser<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> in if case .canPerformAction(let x) = binding { return x } else { return nil } }) }
	static var cellConstructor: BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> in if case .cellConstructor(let x) = binding { return x } else { return nil } }) }
	static var dataMissingCell: BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(IndexPath) -> TableViewCellConvertible> in if case .dataMissingCell(let x) = binding { return x } else { return nil } }) }
	static var didUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> in if case .didUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var editActionsForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> in if case .editActionsForRow(let x) = binding { return x } else { return nil } }) }
	static var editingStyleForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle> in if case .editingStyleForRow(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForFooter: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .estimatedHeightForFooter(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForHeader: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .estimatedHeightForHeader(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .estimatedHeightForRow(let x) = binding { return x } else { return nil } }) }
	static var footerHeight: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .footerHeight(let x) = binding { return x } else { return nil } }) }
	static var footerView: BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int, _ title: String?) -> ViewConvertible?> in if case .footerView(let x) = binding { return x } else { return nil } }) }
	static var headerHeight: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .headerHeight(let x) = binding { return x } else { return nil } }) }
	static var headerView: BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int, _ title: String?) -> ViewConvertible?> in if case .headerView(let x) = binding { return x } else { return nil } }) }
	static var heightForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .heightForRow(let x) = binding { return x } else { return nil } }) }
	static var indentationLevelForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int> in if case .indentationLevelForRow(let x) = binding { return x } else { return nil } }) }
	static var indexPathForPreferredFocusedView: BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView) -> IndexPath> in if case .indexPathForPreferredFocusedView(let x) = binding { return x } else { return nil } }) }
	static var shouldHighlightRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldHighlightRow(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditingRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldIndentWhileEditingRow(let x) = binding { return x } else { return nil } }) }
	static var shouldShowMenuForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldShowMenuForRow(let x) = binding { return x } else { return nil } }) }
	static var shouldUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext) -> Bool> in if case .shouldUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var targetIndexPathForMoveFromRow: BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> in if case .targetIndexPathForMoveFromRow(let x) = binding { return x } else { return nil } }) }
	static var titleForDeleteConfirmationButtonForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?> in if case .titleForDeleteConfirmationButtonForRow(let x) = binding { return x } else { return nil } }) }
	static var willBeginEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> in if case .willBeginEditingRow(let x) = binding { return x } else { return nil } }) }
	static var willDeselectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var willDisplayFooter: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayFooter(let x) = binding { return x } else { return nil } }) }
	static var willDisplayHeader: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayHeader(let x) = binding { return x } else { return nil } }) }
	static var willDisplayRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> in if case .willDisplayRow(let x) = binding { return x } else { return nil } }) }
	static var willSelectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willSelectRow(let x) = binding { return x } else { return nil } }) }
}

extension BindingParser where Binding == ViewController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var navigationItem: BindingParser<Constant<NavigationItem>, Binding> { return BindingParser<Constant<NavigationItem>, Binding>(parse: { binding -> Optional<Constant<NavigationItem>> in if case .navigationItem(let x) = binding { return x } else { return nil } }) }
	static var view: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .view(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var preferredContentSize: BindingParser<Dynamic<CGSize>, Binding> { return BindingParser<Dynamic<CGSize>, Binding>(parse: { binding -> Optional<Dynamic<CGSize>> in if case .preferredContentSize(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationStyle: BindingParser<Dynamic<UIModalPresentationStyle>, Binding> { return BindingParser<Dynamic<UIModalPresentationStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIModalPresentationStyle>> in if case .modalPresentationStyle(let x) = binding { return x } else { return nil } }) }
	static var modalTransitionStyle: BindingParser<Dynamic<UIModalTransitionStyle>, Binding> { return BindingParser<Dynamic<UIModalTransitionStyle>, Binding>(parse: { binding -> Optional<Dynamic<UIModalTransitionStyle>> in if case .modalTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var isModalInPopover: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isModalInPopover(let x) = binding { return x } else { return nil } }) }
	static var definesPresentationContext: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .definesPresentationContext(let x) = binding { return x } else { return nil } }) }
	static var providesPresentationContextTransitionStyle: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .providesPresentationContextTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var transitioningDelegate: BindingParser<Dynamic<UIViewControllerTransitioningDelegate>, Binding> { return BindingParser<Dynamic<UIViewControllerTransitioningDelegate>, Binding>(parse: { binding -> Optional<Dynamic<UIViewControllerTransitioningDelegate>> in if case .transitioningDelegate(let x) = binding { return x } else { return nil } }) }
	static var edgesForExtendedLayout: BindingParser<Dynamic<UIRectEdge>, Binding> { return BindingParser<Dynamic<UIRectEdge>, Binding>(parse: { binding -> Optional<Dynamic<UIRectEdge>> in if case .edgesForExtendedLayout(let x) = binding { return x } else { return nil } }) }
	static var extendedLayoutIncludesOpaqueBars: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .extendedLayoutIncludesOpaqueBars(let x) = binding { return x } else { return nil } }) }
	static var automaticallyAdjustsScrollViewInsets: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .automaticallyAdjustsScrollViewInsets(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }
	static var restorationClass: BindingParser<Dynamic<UIViewControllerRestoration.Type?>, Binding> { return BindingParser<Dynamic<UIViewControllerRestoration.Type?>, Binding>(parse: { binding -> Optional<Dynamic<UIViewControllerRestoration.Type?>> in if case .restorationClass(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationCapturesStatusBarAppearance: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .modalPresentationCapturesStatusBarAppearance(let x) = binding { return x } else { return nil } }) }
	static var hidesBottomBarWhenPushed: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesBottomBarWhenPushed(let x) = binding { return x } else { return nil } }) }
	static var toolbarItems: BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .toolbarItems(let x) = binding { return x } else { return nil } }) }
	static var tabBarItem: BindingParser<Dynamic<TabBarItemConvertible>, Binding> { return BindingParser<Dynamic<TabBarItemConvertible>, Binding>(parse: { binding -> Optional<Dynamic<TabBarItemConvertible>> in if case .tabBarItem(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var present: BindingParser<Signal<ModalPresentation>, Binding> { return BindingParser<Signal<ModalPresentation>, Binding>(parse: { binding -> Optional<Signal<ModalPresentation>> in if case .present(let x) = binding { return x } else { return nil } }) }
	static var traitCollectionDidChange: BindingParser<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding> { return BindingParser<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding>(parse: { binding -> Optional<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>> in if case .traitCollectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var willAppear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .willAppear(let x) = binding { return x } else { return nil } }) }
	static var didAppear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .didAppear(let x) = binding { return x } else { return nil } }) }
	static var didDisappear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .didDisappear(let x) = binding { return x } else { return nil } }) }
	static var willDisappear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .willDisappear(let x) = binding { return x } else { return nil } }) }
	static var loadView: BindingParser<() -> ViewConvertible, Binding> { return BindingParser<() -> ViewConvertible, Binding>(parse: { binding -> Optional<() -> ViewConvertible> in if case .loadView(let x) = binding { return x } else { return nil } }) }
	static var didReceiveMemoryWarning: BindingParser<() -> Void, Binding> { return BindingParser<() -> Void, Binding>(parse: { binding -> Optional<() -> Void> in if case .didReceiveMemoryWarning(let x) = binding { return x } else { return nil } }) }
}

extension BindingParser where Binding == View.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	static var layer: BindingParser<Constant<BackingLayer>, Binding> { return BindingParser<Constant<BackingLayer>, Binding>(parse: { binding -> Optional<Constant<BackingLayer>> in if case .layer(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var layout: BindingParser<Dynamic<Layout>, Binding> { return BindingParser<Dynamic<Layout>, Binding>(parse: { binding -> Optional<Dynamic<Layout>> in if case .layout(let x) = binding { return x } else { return nil } }) }
	static var backgroundColor: BindingParser<Dynamic<(UIColor?)>, Binding> { return BindingParser<Dynamic<(UIColor?)>, Binding>(parse: { binding -> Optional<Dynamic<(UIColor?)>> in if case .backgroundColor(let x) = binding { return x } else { return nil } }) }
	static var isHidden: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isHidden(let x) = binding { return x } else { return nil } }) }
	static var alpha: BindingParser<Dynamic<(CGFloat)>, Binding> { return BindingParser<Dynamic<(CGFloat)>, Binding>(parse: { binding -> Optional<Dynamic<(CGFloat)>> in if case .alpha(let x) = binding { return x } else { return nil } }) }
	static var isOpaque: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isOpaque(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<Dynamic<(UIColor)>, Binding> { return BindingParser<Dynamic<(UIColor)>, Binding>(parse: { binding -> Optional<Dynamic<(UIColor)>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var tintAdjustmentMode: BindingParser<Dynamic<(UIView.TintAdjustmentMode)>, Binding> { return BindingParser<Dynamic<(UIView.TintAdjustmentMode)>, Binding>(parse: { binding -> Optional<Dynamic<(UIView.TintAdjustmentMode)>> in if case .tintAdjustmentMode(let x) = binding { return x } else { return nil } }) }
	static var clipsToBounds: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .clipsToBounds(let x) = binding { return x } else { return nil } }) }
	static var clearsContextBeforeDrawing: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .clearsContextBeforeDrawing(let x) = binding { return x } else { return nil } }) }
	static var mask: BindingParser<Dynamic<(ViewConvertible?)>, Binding> { return BindingParser<Dynamic<(ViewConvertible?)>, Binding>(parse: { binding -> Optional<Dynamic<(ViewConvertible?)>> in if case .mask(let x) = binding { return x } else { return nil } }) }
	static var isUserInteractionEnabled: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isUserInteractionEnabled(let x) = binding { return x } else { return nil } }) }
	static var isMultipleTouchEnabled: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isMultipleTouchEnabled(let x) = binding { return x } else { return nil } }) }
	static var isExclusiveTouch: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .isExclusiveTouch(let x) = binding { return x } else { return nil } }) }
	static var contentMode: BindingParser<Dynamic<(UIView.ContentMode)>, Binding> { return BindingParser<Dynamic<(UIView.ContentMode)>, Binding>(parse: { binding -> Optional<Dynamic<(UIView.ContentMode)>> in if case .contentMode(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentCompressionResistancePriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .horizontalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var verticalContentCompressionResistancePriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .verticalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentHuggingPriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .horizontalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }
	static var verticalContentHuggingPriority: BindingParser<Dynamic<UILayoutPriority>, Binding> { return BindingParser<Dynamic<UILayoutPriority>, Binding>(parse: { binding -> Optional<Dynamic<UILayoutPriority>> in if case .verticalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }
	static var semanticContentAttribute: BindingParser<Dynamic<(UISemanticContentAttribute)>, Binding> { return BindingParser<Dynamic<(UISemanticContentAttribute)>, Binding>(parse: { binding -> Optional<Dynamic<(UISemanticContentAttribute)>> in if case .semanticContentAttribute(let x) = binding { return x } else { return nil } }) }
	static var layoutMargins: BindingParser<Dynamic<(UIEdgeInsets)>, Binding> { return BindingParser<Dynamic<(UIEdgeInsets)>, Binding>(parse: { binding -> Optional<Dynamic<(UIEdgeInsets)>> in if case .layoutMargins(let x) = binding { return x } else { return nil } }) }
	static var preservesSuperviewLayoutMargins: BindingParser<Dynamic<(Bool)>, Binding> { return BindingParser<Dynamic<(Bool)>, Binding>(parse: { binding -> Optional<Dynamic<(Bool)>> in if case .preservesSuperviewLayoutMargins(let x) = binding { return x } else { return nil } }) }
	static var gestureRecognizers: BindingParser<Dynamic<[UIGestureRecognizer]>, Binding> { return BindingParser<Dynamic<[UIGestureRecognizer]>, Binding>(parse: { binding -> Optional<Dynamic<[UIGestureRecognizer]>> in if case .gestureRecognizers(let x) = binding { return x } else { return nil } }) }
	static var motionEffects: BindingParser<Dynamic<([UIMotionEffect])>, Binding> { return BindingParser<Dynamic<([UIMotionEffect])>, Binding>(parse: { binding -> Optional<Dynamic<([UIMotionEffect])>> in if case .motionEffects(let x) = binding { return x } else { return nil } }) }
	static var tag: BindingParser<Dynamic<Int>, Binding> { return BindingParser<Dynamic<Int>, Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .tag(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var endEditing: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .endEditing(let x) = binding { return x } else { return nil } }) }
	static var becomeFirstResponder: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .becomeFirstResponder(let x) = binding { return x } else { return nil } }) }
}
