//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-04-20 01:26:11 +0000 from the following files:
//   CwlExtendedView.swift
//   CwlGradientLayer.swift
//   CwlLayer.swift
//   CwlShapeLayer.swift
//   CwlStackView.swift
//   CwlWebView.swift
//   CwlAlertAction_iOS.swift
//   CwlAlertController_iOS.swift
//   CwlApplication_iOS.swift
//   CwlBarButtonItem_iOS.swift
//   CwlBarItem_iOS.swift
//   CwlButton_iOS.swift
//   CwlControl_iOS.swift
//   CwlExtendedViewController_iOS.swift
//   CwlGestureRecognizer_iOS.swift
//   CwlImageView_iOS.swift
//   CwlLabel_iOS.swift
//   CwlLongPressGestureRecognizer_iOS.swift
//   CwlNavigationBar_iOS.swift
//   CwlNavigationController_iOS.swift
//   CwlNavigationItem_iOS.swift
//   CwlPageControl.swift
//   CwlPageViewController_iOS.swift
//   CwlPanGestureRecognizer_iOS.swift
//   CwlPinchGestureRecognizer_iOS.swift
//   CwlRotationGestureRecognizer_iOS.swift
//   CwlScreenEdgePanGestureRecognizer_iOS.swift
//   CwlScrollView_iOS.swift
//   CwlSearchBar_iOS.swift
//   CwlSlider_iOS.swift
//   CwlSplitViewController_iOS.swift
//   CwlSwipeGestureRecognizer_iOS.swift
//   CwlSwitch_iOS.swift
//   CwlTabBarController_iOS.swift
//   CwlTabBarItem_iOS.swift
//   CwlTabBar_iOS.swift
//   CwlTableViewCell_iOS.swift
//   CwlTableView_iOS.swift
//   CwlTapGestureRecognizer_iOS.swift
//   CwlTextField_iOS.swift
//   CwlTextInputTraits_iOS.swift
//   CwlTextView_iOS.swift
//   CwlToolbar_iOS.swift
//   CwlViewController_iOS.swift
//   CwlView_iOS.swift
//   CwlWindow_iOS.swift

import UIKit

// MARK: - Binder Part 1: Binder
class ExtendedView<Subclass: Layout.View & ViewWithDelegate & HasDelegate>: Binder, ViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

extension ExtendedView where Subclass == CwlExtendedView {
	convenience init(bindings: [Preparer.Binding]) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
	
	convenience init(_ bindings: Preparer.Binding...) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ExtendedView {
	enum Binding: ExtendedViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		@available(macOS 10.10, *) @available(iOS, unavailable) case backgroundColor(Dynamic<NSColor?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case sizeDidChange(SignalInput<CGSize>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	#if os(macOS)
		typealias NSColor = AppKit.NSColor
	#else
		typealias NSColor = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension ExtendedView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = ExtendedView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = Subclass
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ExtendedView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .sizeDidChange(let x): delegate().addMultiHandler1({ s in x.send(value: s) }, #selector(ViewDelegate.layoutSubviews(view:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .backgroundColor(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.backgroundColor = v
				#endif
			}
		case .sizeDidChange: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ExtendedView.Preparer {
	class Storage: View.Preparer.Storage, ViewDelegate {}
	
	class Delegate: DynamicDelegate, ViewDelegate {
		func layoutSubviews(view: Layout.View) {
			multiHandler(view.bounds.size)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ExtendedViewBinding {
	typealias ExtendedViewName<V> = BindingName<V, ExtendedView<Binding.SubclassType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ExtendedView<Binding.SubclassType>.Binding) -> ExtendedViewName<V> {
		return ExtendedViewName<V>(source: source, downcast: Binding.extendedViewBinding)
	}
}
extension BindingName where Binding: ExtendedViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ExtendedViewName<$2> { return .name(ExtendedView.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	#if os(macOS)
		static var backgroundColor: ExtendedViewName<Dynamic<NSColor?>> { return .name(ExtendedView.Binding.backgroundColor) }
	#endif
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var sizeDidChange: ExtendedViewName<SignalInput<CGSize>> { return .name(ExtendedView.Binding.sizeDidChange) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension ExtendedView {
	#if os(iOS)
		func uiView() -> View.Instance { return instance() }
	#elseif os(macOS)
		func nsView() -> View.Instance { return instance() }
	#endif
}

// MARK: - Binder Part 8: Downcast protocols
protocol ExtendedViewBinding: ViewBinding {
	associatedtype SubclassType: Layout.View & ViewWithDelegate & HasDelegate
	static func extendedViewBinding(_ binding: ExtendedView<SubclassType>.Binding) -> Self
}
extension ExtendedViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return extendedViewBinding(.inheritedBinding(binding))
	}
}
extension ExtendedView.Binding {
	typealias Preparer = ExtendedView.Preparer
	static func extendedViewBinding(_ binding: ExtendedView.Binding) -> ExtendedView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
@objc protocol ViewDelegate: class {
	@objc optional func layoutSubviews(view: Layout.View)
}

protocol ViewWithDelegate: class {
	var delegate: ViewDelegate? { get set }

	#if os(macOS)
		var backgroundColor: NSColor? { get set }
	#endif
}

#if os(macOS)
	extension ViewWithDelegate {
		// This default implementation is so that you're not required to implement `backgroundColor` to implement an ExtendedView
		var backgroundColor: NSColor? {
			get {
				return ((self as? NSView)?.layer?.backgroundColor).flatMap { NSColor(cgColor: $0) }
			}
			set {
				if let layer = (self as? NSView)?.layer {
					layer.backgroundColor = newValue?.cgColor 
				}
			}
		}
	}
#endif

/// Implementation of ViewWithDelegate on top of the base UIView.
/// You can use this view directly, subclass it or implement `ViewWithDelegate` and `HasDelegate` on top of another `UIView` to use that view with the `ExtendedView` binder.
class CwlExtendedView: Layout.View, ViewWithDelegate, HasDelegate {
	unowned var delegate: ViewDelegate?
	
	#if os(macOS)
		var backgroundColor: NSColor?
	
		override func draw(_ dirtyRect: NSRect) {
			super.draw(dirtyRect)
			
			if let backgroundColor = backgroundColor {
				backgroundColor.setFill()
				dirtyRect.fill()
			}
		}
	#endif
	
	#if os(iOS)
		override func layoutSubviews() {
			delegate?.layoutSubviews?(view: self)
			super.layoutSubviews()
		}
	#elseif os(macOS)
		override func layout() {
			delegate?.layoutSubviews?(view: self)
			super.layout()
		}
	#endif
}

// MARK: - Binder Part 1: Binder
class GradientLayer: Binder, GradientLayerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension GradientLayer {
	enum Binding: GradientLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case colors(Dynamic<[CGColor]>)
		case locations(Dynamic<[CGFloat]>)
		case endPoint(Dynamic<CGPoint>)
		case startPoint(Dynamic<CGPoint>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension GradientLayer {
	struct Preparer: BinderDelegateDerived {
		typealias Binding = GradientLayer.Binding
		typealias Delegate = Inherited.Delegate
		typealias Inherited = Layer.Preparer
		typealias Instance = CAGradientLayer
		
		var inherited: Inherited
		init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension GradientLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .colors(let x): return x.apply(instance) { i, v in i.colors = v }
		case .locations(let x): return x.apply(instance) { i, v in i.locations = v.map { NSNumber(value: Double($0)) } }
		case .endPoint(let x): return x.apply(instance) { i, v in i.endPoint = v }
		case .startPoint(let x): return x.apply(instance) { i, v in i.startPoint = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GradientLayer.Preparer {
	typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GradientLayerBinding {
	typealias GradientLayerName<V> = BindingName<V, GradientLayer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> GradientLayer.Binding) -> GradientLayerName<V> {
		return GradientLayerName<V>(source: source, downcast: Binding.gradientLayerBinding)
	}
}
extension BindingName where Binding: GradientLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GradientLayerName<$2> { return .name(GradientLayer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var colors: GradientLayerName<Dynamic<[CGColor]>> { return .name(GradientLayer.Binding.colors) }
	static var locations: GradientLayerName<Dynamic<[CGFloat]>> { return .name(GradientLayer.Binding.locations) }
	static var endPoint: GradientLayerName<Dynamic<CGPoint>> { return .name(GradientLayer.Binding.endPoint) }
	static var startPoint: GradientLayerName<Dynamic<CGPoint>> { return .name(GradientLayer.Binding.startPoint) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol GradientLayerConvertible: LayerConvertible {
	func caGradientLayer() -> GradientLayer.Instance
}
extension GradientLayerConvertible {
	func caLayer() -> Layer.Instance { return caGradientLayer() }
}
extension CAGradientLayer: GradientLayerConvertible {
	func caGradientLayer() -> GradientLayer.Instance { return self }
}
extension GradientLayer {
	func caGradientLayer() -> GradientLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol GradientLayerBinding: LayerBinding {
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> Self
}
extension GradientLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self {
		return gradientLayerBinding(.inheritedBinding(binding))
	}
}
extension GradientLayer.Binding {
	typealias Preparer = GradientLayer.Preparer
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> GradientLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
class Layer: Binder, LayerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Layer {
	enum Binding: LayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case actions(Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>)
		case affineTransform(Dynamic<CGAffineTransform>)
		case anchorPoint(Dynamic<CGPoint>)
		case anchorPointZ(Dynamic<CGFloat>)
		case backgroundColor(Dynamic<CGColor>)
		case borderColor(Dynamic<CGColor>)
		case borderWidth(Dynamic<CGFloat>)
		case bounds(Dynamic<CGRect>)
		case contents(Dynamic<Any?>)
		case contentsCenter(Dynamic<CGRect>)
		case contentsGravity(Dynamic<CALayerContentsGravity>)
		case contentsRect(Dynamic<CGRect>)
		case contentsScale(Dynamic<CGFloat>)
		case cornerRadius(Dynamic<CGFloat>)
		case drawsAsynchronously(Dynamic<Bool>)
		case edgeAntialiasingMask(Dynamic<CAEdgeAntialiasingMask>)
		case frame(Dynamic<CGRect>)
		case isDoubleSided(Dynamic<Bool>)
		case isGeometryFlipped(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case isOpaque(Dynamic<Bool>)
		case magnificationFilter(Dynamic<CALayerContentsFilter>)
		case mask(Dynamic<LayerConvertible?>)
		case masksToBounds(Dynamic<Bool>)
		case minificationFilter(Dynamic<CALayerContentsFilter>)
		case minificationFilterBias(Dynamic<Float>)
		case name(Dynamic<String>)
		case needsDisplayOnBoundsChange(Dynamic<Bool>)
		case opacity(Dynamic<Float>)
		case position(Dynamic<CGPoint>)
		case rasterizationScale(Dynamic<CGFloat>)
		case shadowColor(Dynamic<CGColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case shadowOpacity(Dynamic<Float>)
		case shadowPath(Dynamic<CGPath?>)
		case shadowRadius(Dynamic<CGFloat>)
		case shouldRasterize(Dynamic<Bool>)
		case style(Dynamic<[AnyHashable: Any]>)
		case sublayers(Dynamic<[LayerConvertible]>)
		case sublayerTransform(Dynamic<CATransform3D>)
		case transform(Dynamic<CATransform3D>)
		case zPosition(Dynamic<CGFloat>)

		@available(macOS 10.13, *) @available(iOS, unavailable) case autoresizingMask(Dynamic<CAAutoresizingMask>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case backgroundFilters(Dynamic<[CIFilter]?>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case compositingFilter(Dynamic<CIFilter?>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case constraints(Dynamic<[CAConstraint]>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case filters(Dynamic<[CIFilter]?>)

		//	2. Signal bindings are performed on the object after construction.
		case addAnimation(Signal<AnimationForKey>)
		case needsDisplay(Signal<Void>)
		case needsDisplayInRect(Signal<CGRect>)
		case removeAllAnimations(Signal<Void>)
		case removeAnimationForKey(Signal<String>)
		case scrollRectToVisible(Signal<CGRect>)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case display((CALayer) -> Void)
		case draw((CALayer, CGContext) -> Void)
		case layoutSublayers((CALayer) -> Void)
		case willDraw((CALayer) -> Void)
	}

	#if os(macOS)
		typealias CAAutoresizingMask = QuartzCore.CAAutoresizingMask
		typealias CIFilter = QuartzCore.CIFilter
		typealias CAConstraint = QuartzCore.CAConstraint
	#else
		typealias CAConstraint = ()
		typealias CAAutoresizingMask = ()
		typealias CIFilter = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension Layer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Layer.Binding
		typealias Inherited = BinderBase
		typealias Instance = CALayer
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Layer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .display(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.display(_:)))
		case .draw(let x): delegate().addMultiHandler2(x, #selector(CALayerDelegate.draw(_:in:)))
		case .willDraw(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layerWillDraw(_:)))
		case .layoutSublayers(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layoutSublayers(of:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .actions(let x):
			return x.apply(instance, storage) { i, s, v in
				var actions = i.actions ?? [String: CAAction]()
				for (key, input) in v {
					if let i = input {
						actions[key] = s
						storage.layerActions[key] = i
					} else {
						actions[key] = NSNull()
						s.layerActions.removeValue(forKey: key)
					}
				}
				i.actions = actions
			}
		case .affineTransform(let x): return x.apply(instance) { i, v in i.setAffineTransform(v) }
		case .anchorPoint(let x): return x.apply(instance) { i, v in i.anchorPoint = v }
		case .anchorPointZ(let x): return x.apply(instance) { i, v in i.anchorPointZ = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .borderColor(let x): return x.apply(instance) { i, v in i.borderColor = v }
		case .borderWidth(let x): return x.apply(instance) { i, v in i.borderWidth = v }
		case .bounds(let x): return x.apply(instance) { i, v in i.bounds = v }
		case .contents(let x): return x.apply(instance) { i, v in i.contents = v }
		case .contentsCenter(let x): return x.apply(instance) { i, v in i.contentsCenter = v }
		case .contentsGravity(let x): return x.apply(instance) { i, v in i.contentsGravity = v }
		case .contentsRect(let x): return x.apply(instance) { i, v in i.contentsRect = v }
		case .contentsScale(let x): return x.apply(instance) { i, v in i.contentsScale = v }
		case .cornerRadius(let x): return x.apply(instance) { i, v in i.cornerRadius = v }
		case .drawsAsynchronously(let x): return x.apply(instance) { i, v in i.drawsAsynchronously = v }
		case .edgeAntialiasingMask(let x): return x.apply(instance) { i, v in i.edgeAntialiasingMask = v }
		case .frame(let x): return x.apply(instance) { i, v in i.frame = v }
		case .isDoubleSided(let x): return x.apply(instance) { i, v in i.isDoubleSided = v }
		case .isGeometryFlipped(let x): return x.apply(instance) { i, v in i.isGeometryFlipped = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .magnificationFilter(let x): return x.apply(instance) { i, v in i.magnificationFilter = v }
		case .mask(let x): return x.apply(instance) { i, v in i.mask = v?.caLayer() }
		case .masksToBounds(let x): return x.apply(instance) { i, v in i.masksToBounds = v }
		case .minificationFilter(let x): return x.apply(instance) { i, v in i.minificationFilter = v }
		case .minificationFilterBias(let x): return x.apply(instance) { i, v in i.minificationFilterBias = v }
		case .name(let x): return x.apply(instance) { i,v in i.name = v }
		case .needsDisplayOnBoundsChange(let x): return x.apply(instance) { i, v in i.needsDisplayOnBoundsChange = v }
		case .opacity(let x): return x.apply(instance) { i, v in i.opacity = v }
		case .position(let x): return x.apply(instance) { i, v in i.position = v }
		case .rasterizationScale(let x): return x.apply(instance) { i, v in i.rasterizationScale = v }
		case .shadowColor(let x): return x.apply(instance) { i, v in i.shadowColor = v }
		case .shadowOffset(let x): return x.apply(instance) { i, v in i.shadowOffset = v }
		case .shadowOpacity(let x): return x.apply(instance) { i, v in i.shadowOpacity = v }
		case .shadowPath(let x): return x.apply(instance) { i, v in i.shadowPath = v }
		case .shadowRadius(let x): return x.apply(instance) { i, v in i.shadowRadius = v }
		case .shouldRasterize(let x): return x.apply(instance) { i, v in i.shouldRasterize = v }
		case .style(let x): return x.apply(instance) { i,v in i.style = v }
		case .sublayers(let x): return x.apply(instance) { i, v in i.sublayers = v.map { $0.caLayer() } }
		case .sublayerTransform(let x): return x.apply(instance) { i, v in i.sublayerTransform = v }
		case .transform(let x): return x.apply(instance) { i, v in i.transform = v }
		case .zPosition(let x): return x.apply(instance) { i, v in i.zPosition = v }
		
		case .autoresizingMask(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.autoresizingMask = v }
			#else
				return nil
			#endif
		case .backgroundFilters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.backgroundFilters = v }
			#else
				return nil
			#endif
		case .compositingFilter(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.compositingFilter = v }
			#else
				return nil
			#endif
		case .constraints(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.constraints = v }
			#else
				return nil
			#endif
		case .filters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.filters = v }
			#else
				return nil
			#endif

		//	2. Signal bindings are performed on the object after construction.
		case .addAnimation(let x): return x.apply(instance) { i, v in i.addAnimationForKey(v) }
		case .needsDisplay(let x): return x.apply(instance) { i, v in i.setNeedsDisplay() }
		case .needsDisplayInRect(let x): return x.apply(instance) { i, v in i.setNeedsDisplay(v) }
		case .removeAllAnimations(let x): return x.apply(instance) { i, v in i.removeAllAnimations() }
		case .removeAnimationForKey(let x): return x.apply(instance) { i, v in i.removeAnimation(forKey: v) }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollRectToVisible(v) }

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .display: return nil
		case .draw: return nil
		case .layoutSublayers: return nil
		case .willDraw: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Layer.Preparer {
	class Storage: AssociatedBinderStorage, CAAction, CALayerDelegate {
		// LayerBinderStorage implementation
		var layerActions = [String: SignalInput<[AnyHashable: Any]?>]()
		@objc func run(forKey event: String, object anObject: Any, arguments dict: [AnyHashable: Any]?) {
			_ = layerActions[event]?.send(value: dict)
		}

		func action(for layer: CALayer, forKey event: String) -> CAAction? {
			return layerActions[event] != nil ? self : nil
		}
	}
	
	class Delegate: DynamicDelegate, CALayerDelegate {
		func layerWillDraw(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		func display(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		@objc(drawLayer:inContext:) func draw(_ layer: CALayer, in ctx: CGContext) {
			multiHandler(layer, ctx)
		}
		
		func layoutSublayers(of layer: CALayer) {
			multiHandler(layer)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LayerBinding {
	typealias LayerName<V> = BindingName<V, Layer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Layer.Binding) -> LayerName<V> {
		return LayerName<V>(source: source, downcast: Binding.layerBinding)
	}
}
extension BindingName where Binding: LayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LayerName<$2> { return .name(Layer.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var actions: LayerName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>> { return .name(Layer.Binding.actions) }
	static var affineTransform: LayerName<Dynamic<CGAffineTransform>> { return .name(Layer.Binding.affineTransform) }
	static var anchorPoint: LayerName<Dynamic<CGPoint>> { return .name(Layer.Binding.anchorPoint) }
	static var anchorPointZ: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.anchorPointZ) }
	static var backgroundColor: LayerName<Dynamic<CGColor>> { return .name(Layer.Binding.backgroundColor) }
	static var borderColor: LayerName<Dynamic<CGColor>> { return .name(Layer.Binding.borderColor) }
	static var borderWidth: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.borderWidth) }
	static var bounds: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.bounds) }
	static var contents: LayerName<Dynamic<Any?>> { return .name(Layer.Binding.contents) }
	static var contentsCenter: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.contentsCenter) }
	static var contentsGravity: LayerName<Dynamic<CALayerContentsGravity>> { return .name(Layer.Binding.contentsGravity) }
	static var contentsRect: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.contentsRect) }
	static var contentsScale: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.contentsScale) }
	static var cornerRadius: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.cornerRadius) }
	static var drawsAsynchronously: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.drawsAsynchronously) }
	static var edgeAntialiasingMask: LayerName<Dynamic<CAEdgeAntialiasingMask>> { return .name(Layer.Binding.edgeAntialiasingMask) }
	static var frame: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.frame) }
	static var isDoubleSided: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isDoubleSided) }
	static var isGeometryFlipped: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isGeometryFlipped) }
	static var isHidden: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isHidden) }
	static var isOpaque: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isOpaque) }
	static var magnificationFilter: LayerName<Dynamic<CALayerContentsFilter>> { return .name(Layer.Binding.magnificationFilter) }
	static var mask: LayerName<Dynamic<LayerConvertible?>> { return .name(Layer.Binding.mask) }
	static var masksToBounds: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.masksToBounds) }
	static var minificationFilter: LayerName<Dynamic<CALayerContentsFilter>> { return .name(Layer.Binding.minificationFilter) }
	static var minificationFilterBias: LayerName<Dynamic<Float>> { return .name(Layer.Binding.minificationFilterBias) }
	static var name: LayerName<Dynamic<String>> { return .name(Layer.Binding.name) }
	static var needsDisplayOnBoundsChange: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.needsDisplayOnBoundsChange) }
	static var opacity: LayerName<Dynamic<Float>> { return .name(Layer.Binding.opacity) }
	static var position: LayerName<Dynamic<CGPoint>> { return .name(Layer.Binding.position) }
	static var rasterizationScale: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.rasterizationScale) }
	static var shadowColor: LayerName<Dynamic<CGColor?>> { return .name(Layer.Binding.shadowColor) }
	static var shadowOffset: LayerName<Dynamic<CGSize>> { return .name(Layer.Binding.shadowOffset) }
	static var shadowOpacity: LayerName<Dynamic<Float>> { return .name(Layer.Binding.shadowOpacity) }
	static var shadowPath: LayerName<Dynamic<CGPath?>> { return .name(Layer.Binding.shadowPath) }
	static var shadowRadius: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.shadowRadius) }
	static var shouldRasterize: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.shouldRasterize) }
	static var style: LayerName<Dynamic<[AnyHashable: Any]>> { return .name(Layer.Binding.style) }
	static var sublayers: LayerName<Dynamic<[LayerConvertible]>> { return .name(Layer.Binding.sublayers) }
	static var sublayerTransform: LayerName<Dynamic<CATransform3D>> { return .name(Layer.Binding.sublayerTransform) }
	static var transform: LayerName<Dynamic<CATransform3D>> { return .name(Layer.Binding.transform) }
	static var zPosition: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.zPosition) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var autoresizingMask: LayerName<Dynamic<Layer.CAAutoresizingMask>> { return .name(Layer.Binding.autoresizingMask) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var backgroundFilters: LayerName<Dynamic<[Layer.CIFilter]?>> { return .name(Layer.Binding.backgroundFilters) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var compositingFilter: LayerName<Dynamic<Layer.CIFilter?>> { return .name(Layer.Binding.compositingFilter) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var constraints: LayerName<Dynamic<[Layer.CAConstraint]>> { return .name(Layer.Binding.constraints) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var filters: LayerName<Dynamic<[Layer.CIFilter]?>> { return .name(Layer.Binding.filters) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var addAnimation: LayerName<Signal<AnimationForKey>> { return .name(Layer.Binding.addAnimation) }
	static var needsDisplay: LayerName<Signal<Void>> { return .name(Layer.Binding.needsDisplay) }
	static var needsDisplayInRect: LayerName<Signal<CGRect>> { return .name(Layer.Binding.needsDisplayInRect) }
	static var removeAllAnimations: LayerName<Signal<Void>> { return .name(Layer.Binding.removeAllAnimations) }
	static var removeAnimationForKey: LayerName<Signal<String>> { return .name(Layer.Binding.removeAnimationForKey) }
	static var scrollRectToVisible: LayerName<Signal<CGRect>> { return .name(Layer.Binding.scrollRectToVisible) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var display: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.display) }
	static var draw: LayerName<(CALayer, CGContext) -> Void> { return .name(Layer.Binding.draw) }
	static var layoutSublayers: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.layoutSublayers) }
	static var willDraw: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.willDraw) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol LayerConvertible {
	func caLayer() -> Layer.Instance
}
extension CALayer: LayerConvertible, HasDelegate, DefaultConstructable {
	func caLayer() -> Layer.Instance { return self }
}
extension Layer {
	 func caLayer() -> Layer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol LayerBinding: BinderBaseBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self
}
extension LayerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return layerBinding(.inheritedBinding(binding))
	}
}
extension Layer.Binding {
	typealias Preparer = Layer.Preparer
	static func layerBinding(_ binding: Layer.Binding) -> Layer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct AnimationForKey {
	let animation: CAAnimation
	let key: String?
	
	init(animation: CAAnimation, forKey: String? = nil) {
		self.animation = animation
		self.key = forKey
	}
	
	static var fade: AnimationForKey {
		let t = CATransition()
		t.type = CATransitionType.fade
		
		// NOTE: fade animations are always applied under key kCATransition so it's pointless trying to set a key
		return AnimationForKey(animation: t, forKey: nil)
	}
	
	enum Direction {
		case left, right, top, bottom
		func transition(ofType: CATransitionType, forKey: String? = nil) -> AnimationForKey {
			let t = CATransition()
			t.type = ofType
			switch self {
			case .left: t.subtype = CATransitionSubtype.fromLeft
			case .right: t.subtype = CATransitionSubtype.fromRight
			case .top: t.subtype = CATransitionSubtype.fromTop
			case .bottom: t.subtype = CATransitionSubtype.fromBottom
			}
			return AnimationForKey(animation: t, forKey: forKey)
		}
	}
	
	static func moveIn(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.moveIn, forKey: forKey)
	}
	
	static func push(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.push, forKey: forKey)
	}
	
	static func reveal(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.reveal, forKey: forKey)
	}
}

extension CALayer {
	func addAnimationForKey(_ animationForKey: AnimationForKey) {
		add(animationForKey.animation, forKey: animationForKey.key)
	}
}

// MARK: - Binder Part 1: Binder
class ShapeLayer: Binder, ShapeLayerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ShapeLayer {
	enum Binding: ShapeLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case fillColor(Dynamic<CGColor?>)
		case fillRule(Dynamic<CAShapeLayerFillRule>)
		case lineCap(Dynamic<CAShapeLayerLineCap>)
		case lineDashPattern(Dynamic<[NSNumber]?>)
		case lineDashPhase(Dynamic<CGFloat>)
		case lineJoin(Dynamic<CAShapeLayerLineJoin>)
		case lineWidth(Dynamic<CGFloat>)
		case miterLimit(Dynamic<CGFloat>)
		case path(Dynamic<CGPath>)
		case strokeColor(Dynamic<CGColor?>)
		case strokeEnd(Dynamic<CGFloat>)
		case strokeStart(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ShapeLayer {
	struct Preparer: BinderDelegateDerived {
		typealias Binding = ShapeLayer.Binding
		typealias Delegate = Inherited.Delegate
		typealias Inherited = Layer.Preparer
		typealias Instance = CAShapeLayer
		
		var inherited = Inherited()
		init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ShapeLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .fillColor(let x): return x.apply(instance) { i, v in i.fillColor = v }
		case .fillRule(let x): return x.apply(instance) { i, v in i.fillRule = v }
		case .lineCap(let x): return x.apply(instance) { i, v in i.lineCap = v }
		case .lineDashPattern(let x): return x.apply(instance) { i, v in i.lineDashPattern = v }
		case .lineDashPhase(let x): return x.apply(instance) { i, v in i.lineDashPhase = v }
		case .lineJoin(let x): return x.apply(instance) { i, v in i.lineJoin = v }
		case .lineWidth(let x): return x.apply(instance) { i, v in i.lineWidth = v }
		case .miterLimit(let x): return x.apply(instance) { i, v in i.miterLimit = v }
		case .path(let x): return x.apply(instance) { i, v in i.path = v }
		case .strokeColor(let x): return x.apply(instance) { i, v in i.strokeColor = v }
		case .strokeEnd(let x): return x.apply(instance) { i, v in i.strokeEnd = v }
		case .strokeStart(let x): return x.apply(instance) { i, v in i.strokeStart = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ShapeLayer.Preparer {
	typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ShapeLayerBinding {
	typealias ShapeLayerName<V> = BindingName<V, ShapeLayer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ShapeLayer.Binding) -> ShapeLayerName<V> {
		return ShapeLayerName<V>(source: source, downcast: Binding.shapeLayerBinding)
	}
}
extension BindingName where Binding: ShapeLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ShapeLayerName<$2> { return .name(ShapeLayer.Binding.$1) }
	static var fillColor: ShapeLayerName<Dynamic<CGColor?>> { return .name(ShapeLayer.Binding.fillColor) }
	static var fillRule: ShapeLayerName<Dynamic<CAShapeLayerFillRule>> { return .name(ShapeLayer.Binding.fillRule) }
	static var lineCap: ShapeLayerName<Dynamic<CAShapeLayerLineCap>> { return .name(ShapeLayer.Binding.lineCap) }
	static var lineDashPattern: ShapeLayerName<Dynamic<[NSNumber]?>> { return .name(ShapeLayer.Binding.lineDashPattern) }
	static var lineDashPhase: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.lineDashPhase) }
	static var lineJoin: ShapeLayerName<Dynamic<CAShapeLayerLineJoin>> { return .name(ShapeLayer.Binding.lineJoin) }
	static var lineWidth: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.lineWidth) }
	static var miterLimit: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.miterLimit) }
	static var path: ShapeLayerName<Dynamic<CGPath>> { return .name(ShapeLayer.Binding.path) }
	static var strokeColor: ShapeLayerName<Dynamic<CGColor?>> { return .name(ShapeLayer.Binding.strokeColor) }
	static var strokeEnd: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.strokeEnd) }
	static var strokeStart: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.strokeStart) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ShapeLayerConvertible: LayerConvertible {
	func caShapeLayer() -> ShapeLayer.Instance
}
extension ShapeLayerConvertible {
	func caLayer() -> Layer.Instance { return caShapeLayer() }
}
extension CAShapeLayer: ShapeLayerConvertible {
	func caShapeLayer() -> ShapeLayer.Instance { return self }
}
extension ShapeLayer {
	func caShapeLayer() -> ShapeLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ShapeLayerBinding: LayerBinding {
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -> Self
}
extension ShapeLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self {
		return shapeLayerBinding(.inheritedBinding(binding))
	}
}
extension ShapeLayer.Binding {
	typealias Preparer = ShapeLayer.Preparer
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -> ShapeLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
class StackView: Binder, StackViewConvertible {
	#if os(macOS)
		typealias NSUIView = NSView
		typealias NSUIStackView = NSStackView
		typealias NSUIStackViewDistribution = NSStackView.Distribution
		typealias NSUIStackViewAlignment = NSLayoutConstraint.Attribute
		typealias NSUIUserInterfaceLayoutOrientation = NSUserInterfaceLayoutOrientation
		typealias NSUILayoutPriority = NSLayoutConstraint.Priority
	#else
		typealias NSUIView = UIView
		typealias NSUIStackView = UIStackView
		typealias NSUIStackViewDistribution = UIStackView.Distribution
		typealias NSUIStackViewAlignment = UIStackView.Alignment
		typealias NSUIUserInterfaceLayoutOrientation = NSLayoutConstraint.Axis
		typealias NSUILayoutPriority = UILayoutPriority
	#endif

	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension StackView {
	enum Binding: StackViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic<NSUIStackViewAlignment>)
		case arrangedSubviews(Dynamic<[ViewConvertible]>)
		case axis(Dynamic<NSUIUserInterfaceLayoutOrientation>)
		case distribution(Dynamic<NSUIStackViewDistribution>)
		case spacing(Dynamic<CGFloat>)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case edgeInsets(Dynamic<EdgeInsets>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
		@available(macOS, unavailable) @available(iOS 11, *) case isLayoutMarginsRelativeArrangement(Dynamic<Bool>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	#if os(macOS)
		typealias EdgeInsets = NSEdgeInsets
	#else
		typealias EdgeInsets = UIEdgeInsets
	#endif
}

// MARK: - Binder Part 3: Preparer
extension StackView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = StackView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSUIStackView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension StackView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .axis(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.orientation = v
				#else
					i.axis = v
				#endif
			}
		case .arrangedSubviews(let x):
			return x.apply(instance) { i, v in
				i.arrangedSubviews.forEach { $0.removeFromSuperview() }
				#if os(macOS)
					v.forEach { i.addArrangedSubview($0.nsView()) }
				#else
					v.forEach { i.addArrangedSubview($0.uiView()) }
				#endif
			}
		case .distribution(let x): return x.apply(instance) { i, v in i.distribution = v }
		case .spacing(let x): return x.apply(instance) { i, v in i.spacing = v }

		case .edgeInsets(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.edgeInsets = v }
			#else
				return nil
			#endif
		case .horizontalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .horizontalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .isLayoutMarginsRelativeArrangement(let x):
			#if os(macOS)
				return nil
			#else
				return x.apply(instance) { i, v in i.isLayoutMarginsRelativeArrangement = v }
			#endif
		case .verticalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .vertical) }
			#else
				return nil
			#endif
		case .verticalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .vertical) }
			#else
				return nil
			#endif
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension StackView.Preparer {
	#if os(macOS)
		class Storage: View.Preparer.Storage {
			var gravity: NSStackView.Gravity = .center
		}
	#else
		typealias Storage = View.Preparer.Storage
	#endif
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: StackViewBinding {
	typealias StackViewName<V> = BindingName<V, StackView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> StackView.Binding) -> StackViewName<V> {
		return StackViewName<V>(source: source, downcast: Binding.stackViewBinding)
	}
}
extension BindingName where Binding: StackViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: StackViewName<$2> { return .name(StackView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: StackViewName<Dynamic<StackView.NSUIStackViewAlignment>> { return .name(StackView.Binding.alignment) }
	static var arrangedSubviews: StackViewName<Dynamic<[ViewConvertible]>> { return .name(StackView.Binding.arrangedSubviews) }
	static var axis: StackViewName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>> { return .name(StackView.Binding.axis) }
	static var distribution: StackViewName<Dynamic<StackView.NSUIStackViewDistribution>> { return .name(StackView.Binding.distribution) }
	static var spacing: StackViewName<Dynamic<CGFloat>> { return .name(StackView.Binding.spacing) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var edgeInsets: StackViewName<Dynamic<StackView.EdgeInsets>> { return .name(StackView.Binding.edgeInsets) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalClippingResistance: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.horizontalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalHuggingPriority: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.horizontalHuggingPriority) }
	@available(macOS, unavailable) @available(iOS 11, *) static var isLayoutMarginsRelativeArrangement: StackViewName<Dynamic<Bool>> { return .name(StackView.Binding.isLayoutMarginsRelativeArrangement) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalClippingResistance: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.verticalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalHuggingPriority: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.verticalHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
#if os(macOS)
	protocol StackViewConvertible: ViewConvertible {
		func nsStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		func nsView() -> View.Instance { return nsStackView() }
	}
	extension NSStackView: StackViewConvertible {
		func nsStackView() -> StackView.Instance { return self }
	}
	extension StackView {
		func nsStackView() -> StackView.Instance { return instance() }
	}
#else
	protocol StackViewConvertible: ViewConvertible {
		func uiStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		func uiView() -> View.Instance { return uiStackView() }
	}
	extension UIStackView: StackViewConvertible {
		func uiStackView() -> StackView.Instance { return self }
	}
	extension StackView {
		func uiStackView() -> StackView.Instance { return instance() }
	}
#endif

// MARK: - Binder Part 8: Downcast protocols
protocol StackViewBinding: ViewBinding {
	static func stackViewBinding(_ binding: StackView.Binding) -> Self
}
extension StackViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return stackViewBinding(.inheritedBinding(binding))
	}
}
extension StackView.Binding {
	typealias Preparer = StackView.Preparer
	static func stackViewBinding(_ binding: StackView.Binding) -> StackView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

import WebKit

// MARK: - Binder Part 1: Binder
class WebView: Binder, WebViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	#if os(macOS)
		static func scrollEmbedded(type: WKWebView.Type = WKWebView.self, _ bindings: Binding...) -> ScrollView {
			return ScrollView(
				.borderType -- .noBorder,
				.hasVerticalScroller -- true,
				.hasHorizontalScroller -- true,
				.autohidesScrollers -- true,
				.contentView -- ClipView(
					.documentView -- WebView(type: type, bindings: bindings)
				)
			)
		}
	#endif
}

// MARK: - Binder Part 2: Binding
extension WebView {
	enum Binding: WebViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case allowsAirPlayForMediaPlayback(Constant<Bool>)
		case allowsInlineMediaPlayback(Constant<Bool>)
		case allowsPictureInPictureForMediaPlayback(Constant<Bool>)
		case applicationNameForUserAgent(Constant<String?>)
		case dataDetectorTypes(Constant<WKDataDetectorTypes>)
		case ignoresViewportScaleLimits(Constant<Bool>)
		case javaScriptCanOpenWindowsAutomatically(Constant<Bool>)
		case javaScriptEnabled(Constant<Bool>)
		case mediaTypesRequiringUserActionForPlayback(Constant<WKAudiovisualMediaTypes>)
		case minimumFontSize(Constant<CGFloat>)
		case processPool(Constant<WKProcessPool>)
		case selectionGranularity(Constant<WKSelectionGranularity>)
		case suppressesIncrementalRendering(Constant<Bool>)
		case urlSchemeHandlers(Constant<[String: WKURLSchemeHandler]>)
		case userContentController(Constant<WKUserContentController>)

		@available(macOS 10.10, *) @available(iOS, unavailable) case javaEnabled(Constant<Bool>)
		@available(macOS 10.10, *) @available(iOS, unavailable) case plugInsEnabled(Constant<Bool>)
		@available(macOS 10.10, *) @available(iOS, unavailable) case tabFocusesLinks(Constant<Bool>)
		@available(macOS 10.12, *) @available(iOS, unavailable) case userInterfaceDirectionPolicy(Constant<WKUserInterfaceDirectionPolicy>)
		@available(macOS, unavailable) @available(iOS 9, *) case allowsPictureInPictureMediaPlayback(Constant<Bool>)
		@available(macOS, unavailable) @available(iOS 11, *) case scrollView(Constant<ScrollView>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsBackForwardNavigationGestures(Dynamic<Bool>)
		case allowsLinkPreview(Dynamic<Bool>)
		case customUserAgent(Dynamic<String?>)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case allowsMagnification(Dynamic<Bool>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case magnification(Dynamic<(factor: CGFloat, centeredAt: CGPoint)>)
		
		//	2. Signal bindings are performed on the object after construction.
		case evaluateJavaScript(Signal<Callback<String, (Any?, Error?)>>)
		case goBack(Signal<Callback<Void, WKNavigation?>>)
		case goForward(Signal<Callback<Void, WKNavigation?>>)
		case goTo(Signal<Callback<WKBackForwardListItem, WKNavigation?>>)
		case load(Signal<Callback<URLRequest, WKNavigation?>>)
		case loadData(Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>)
		case loadFile(Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>)
		case loadHTMLString(Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>)
		case reload(Signal<Callback<Void, WKNavigation?>>)
		case reloadFromOrigin(Signal<Callback<Void, WKNavigation?>>)
		case stopLoading(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case createWebView((_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)
		case didClose((WKWebView) -> Void)
		case didCommit((WKWebView, WKNavigation) -> Void)
		case didStartProvisionalNavigation((WKWebView, WKNavigation) -> Void)
		case didReceiveServerRedirectForProvisionalNavigation((WKWebView, WKNavigation) -> Void)
		case didFail((WKWebView, WKNavigation, Error) -> Void)
		case didFailProvisionalNavigation((WKWebView, WKNavigation, Error) -> Void)
		case didFinish((WKWebView, WKNavigation) -> Void)
		case contentProcessDidTerminate((WKWebView) -> Void)
		case decideActionPolicy((WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void)
		case decideResponsePolicy((WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void)
		case didReceiveAuthenticationChallenge((WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void)
		case runJavaScriptAlertPanel((WKWebView, String, WKFrameInfo, () -> Void) -> Void)
		case runJavaScriptConfirmPanel((WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void)
		case runJavaScriptTextInputPanel((WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void)
		
		@available(macOS, unavailable) @available(iOS 10.0, *) case commitPreviewingViewController((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case previewingViewController((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)
		@available(macOS 10.12, *) @available(iOS, unavailable) case runOpenPanel((WKWebView, WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case shouldPreviewElement((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)
	}

	#if os(macOS)
		typealias UIViewController = ()
		typealias WKDataDetectorTypes = ()
		typealias WKPreviewElementInfo = ()
		typealias WKPreviewActionItem = ()
		typealias WKOpenPanelParameters = WebKit.WKOpenPanelParameters
		typealias WKSelectionGranularity = ()
		typealias WKUserInterfaceDirectionPolicy = WebKit.WKUserInterfaceDirectionPolicy
	#else
		typealias UIViewController = UIKit.UIViewController
		typealias WKDataDetectorTypes = WebKit.WKDataDetectorTypes
		typealias WKOpenPanelParameters = ()
		typealias WKPreviewElementInfo = WebKit.WKPreviewElementInfo
		typealias WKPreviewActionItem = WebKit.WKPreviewActionItem
		typealias WKSelectionGranularity = WebKit.WKSelectionGranularity
		typealias WKUserInterfaceDirectionPolicy = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension WebView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = WebView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = WKWebView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		mutating func webConfiguration() -> WKWebViewConfiguration {
			if let pwc = possibleWebConfiguration {
				return pwc
			}
			let newConfiguration = WKWebViewConfiguration()
			possibleWebConfiguration = newConfiguration
			return newConfiguration
		}
		var possibleWebConfiguration: WKWebViewConfiguration?
		
		mutating func webPreferences() -> WKPreferences {
			return webConfiguration().preferences
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension WebView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .allowsAirPlayForMediaPlayback(let x): webConfiguration().allowsAirPlayForMediaPlayback = x.value
		case .allowsInlineMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsInlineMediaPlayback = x.value
			#endif
		case .allowsPictureInPictureMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsPictureInPictureMediaPlayback = x.value
			#endif
		case .applicationNameForUserAgent(let x): webConfiguration().applicationNameForUserAgent = x.value
		case .dataDetectorTypes(let x): 
			#if os(iOS)
				webConfiguration().dataDetectorTypes = x.value
			#endif
		case .ignoresViewportScaleLimits(let x):
			#if os(iOS)
				webConfiguration().ignoresViewportScaleLimits = x.value
			#endif
		case .javaEnabled(let x):
			#if os(macOS)
				webPreferences().javaEnabled = x.value
			#endif
		case .javaScriptCanOpenWindowsAutomatically(let x): webPreferences().javaScriptCanOpenWindowsAutomatically = x.value
		case .javaScriptEnabled(let x): webPreferences().javaScriptEnabled = x.value
		case .mediaTypesRequiringUserActionForPlayback(let x): webConfiguration().mediaTypesRequiringUserActionForPlayback = x.value
		case .minimumFontSize(let x): webPreferences().minimumFontSize = x.value
		case .plugInsEnabled(let x):
			#if os(macOS)
				webPreferences().plugInsEnabled = x.value
			#endif
		case .processPool(let x): webConfiguration().processPool = x.value
		case .selectionGranularity(let x): 
			#if os(iOS)
				webConfiguration().selectionGranularity = x.value
			#endif
		case .suppressesIncrementalRendering(let x): webConfiguration().suppressesIncrementalRendering = x.value
		case .tabFocusesLinks(let x):
			#if os(macOS)
				webPreferences().tabFocusesLinks = x.value
			#endif
		case .urlSchemeHandlers(let x):
			for (key, value) in x.value {
				webConfiguration().setURLSchemeHandler(value, forURLScheme: key)
			}
		case .userContentController(let x): webConfiguration().userContentController = x.value

		case .didClose(let x): delegate().addMultiHandler1(x, #selector(WKUIDelegate.webViewDidClose(_:)))
		case .didCommit(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didCommit:)))
		case .didStartProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didStartProvisionalNavigation:)))
		case .didReceiveServerRedirectForProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didReceiveServerRedirectForProvisionalNavigation:)))
		case .didFail(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFail:withError:)))
		case .didFailProvisionalNavigation(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFailProvisionalNavigation:withError:)))
		case .didFinish(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didFinish:)))
		case .contentProcessDidTerminate(let x): delegate().addMultiHandler1(x, #selector(WKNavigationDelegate.webViewWebContentProcessDidTerminate(_:)))
		case .decideActionPolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView,WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?))
		case .decideResponsePolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView, WKNavigationResponse, @escaping (WKNavigationResponsePolicy) -> Void) -> Void)?))
		case .didReceiveAuthenticationChallenge(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didReceive:completionHandler:)))
		case .runJavaScriptAlertPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptConfirmPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptTextInputPanel(let x): delegate().addMultiHandler5(x, #selector(WKUIDelegate.webView(_:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler:)))
		case .createWebView(let x): delegate().addSingleHandler4(x, #selector(WKUIDelegate.webView(_:createWebViewWith:for:windowFeatures:)))
		case .runOpenPanel(let x):
			#if os(macOS)
				delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runOpenPanelWith:initiatedByFrame:completionHandler:)))
			#endif
		case .shouldPreviewElement(let x):
			#if os(iOS)
				delegate().addSingleHandler2(x, #selector(WKUIDelegate.webView(_:shouldPreviewElement:)))
			#endif
		case .previewingViewController(let x):
			#if os(iOS)
				delegate().addSingleHandler3(x, #selector(WKUIDelegate.webView(_:previewingViewControllerForElement:defaultActions:)))
			#endif
		case .commitPreviewingViewController(let x):
			#if os(iOS)
				delegate().addMultiHandler2(x, #selector(WKUIDelegate.webView(_:commitPreviewingViewController:)))
			#endif
		default: break
		}
	}
	
	func constructInstance(type: WKWebView.Type, parameters: ()) -> WKWebView {
		if let configuration = possibleWebConfiguration {
			return type.init(frame: .zero, configuration: configuration)
		} else {
			return type.init(frame: .zero)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if delegateIsRequired {
			precondition(instance.uiDelegate == nil, "Conflicting delegate applied to instance")
			instance.uiDelegate = storage
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .allowsAirPlayForMediaPlayback: return nil
		case .allowsInlineMediaPlayback: return nil
		case .allowsPictureInPictureForMediaPlayback: return nil
		case .applicationNameForUserAgent: return nil
		case .dataDetectorTypes: return nil
		case .ignoresViewportScaleLimits: return nil
		case .javaScriptCanOpenWindowsAutomatically: return nil
		case .javaScriptEnabled: return nil
		case .mediaTypesRequiringUserActionForPlayback: return nil
		case .minimumFontSize: return nil
		case .processPool: return nil
		case .selectionGranularity: return nil
		case .suppressesIncrementalRendering: return nil
		case .urlSchemeHandlers: return nil
		case .userContentController: return nil
		case .javaEnabled: return nil
		case .plugInsEnabled: return nil
		case .tabFocusesLinks: return nil
		case .userInterfaceDirectionPolicy: return nil
		case .allowsPictureInPictureMediaPlayback: return nil
		
		case .scrollView(let x):
			#if os(macOS)
				return nil
			#else
				x.value.apply(to: instance.scrollView)
				return nil
			#endif
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsBackForwardNavigationGestures(let x): return x.apply(instance) { i, v in i.allowsBackForwardNavigationGestures = v }
		
		case .allowsLinkPreview(let x):
			return x.apply(instance) { i, v in
				i.allowsLinkPreview = v
			}
		case .allowsMagnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.allowsMagnification = v }
			#else
				return nil
			#endif
		case .customUserAgent(let x):
			return x.apply(instance) { i, v in
				i.customUserAgent = v
			}
		case .magnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setMagnification(v.factor, centeredAt: v.centeredAt) }
			#else
				return nil
			#endif
		
		//	2. Signal bindings are performed on the object after construction.
		case .evaluateJavaScript(let x): return x.apply(instance) { i, v in i.evaluateJavaScript(v.value) { (output, error) in v.callback.send(value: (output, error)) } }
		case .goBack(let x): return x.apply(instance) { i, v in v.callback.send(value: i.goBack()) }
		case .goForward(let x):return x.apply(instance) { i, v in v.callback.send(value: i.goForward()) }
		case .goTo(let x): return x.apply(instance) { i, v in v.callback.send(value: i.go(to: v.value)) }
		case .load(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value)) }
		case .loadHTMLString(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadHTMLString(v.value.string, baseURL: v.value.baseURL)) }
		case .reload(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reload()) }
		case .reloadFromOrigin(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reloadFromOrigin()) }
		case .stopLoading(let x): return x.apply(instance) { i, v in i.stopLoading() }

		case .loadData(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value.data, mimeType: v.value.mimeType, characterEncodingName: v.value.characterEncodingName, baseURL: v.value.baseURL)) }
		case .loadFile(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadFileURL(v.value.url, allowingReadAccessTo: v.value.allowingReadAccessTo)) }
			
		//	3. Action bindings are triggered by the object after construction.
		case .contentProcessDidTerminate: return nil
		case .decideActionPolicy: return nil
		case .decideResponsePolicy: return nil
		case .didCommit: return nil
		case .didFail: return nil
		case .didFailProvisionalNavigation: return nil
		case .didFinish: return nil
		case .didReceiveAuthenticationChallenge: return nil
		case .didReceiveServerRedirectForProvisionalNavigation: return nil
		case .didStartProvisionalNavigation: return nil
		case .runJavaScriptAlertPanel: return nil
		case .runJavaScriptConfirmPanel: return nil
		case .runJavaScriptTextInputPanel: return nil

		case .didClose: return nil
		case .runOpenPanel: return nil

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .createWebView: return nil
		
		case .commitPreviewingViewController: return nil
		case .previewingViewController: return nil
		case .shouldPreviewElement: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension WebView.Preparer {
	class Storage: View.Preparer.Storage, WKUIDelegate, WKNavigationDelegate {}

	class Delegate: DynamicDelegate, WKUIDelegate, WKNavigationDelegate {
		func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
			multiHandler(webView, ())
		}
		
		func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
			multiHandler(webView, navigationAction, decisionHandler)
		}
		
		func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
			multiHandler(webView, navigationResponse, decisionHandler)
		}
		
		func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
			multiHandler(webView, challenge, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
			multiHandler(webView, prompt, defaultText, frame)
		}
		
		func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
			return singleHandler(webView, configuration, navigationAction, windowFeatures)
		}

		func webViewDidClose(_ webView: WKWebView) {
			multiHandler(webView)
		}

		#if os(iOS)
			func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
				return singleHandler(webView, elementInfo)
			}
			
			func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
				multiHandler(webView, previewingViewController)
			}
			
			func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
				return singleHandler(webView, elementInfo, previewActions)
			}
		#else
			func webView(_ webView: WKWebView, runOpenPanelWith parameters: WebView.WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
				multiHandler(webView, parameters, frame, completionHandler)
			}
		#endif
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WebViewBinding {
	typealias WebViewName<V> = BindingName<V, WebView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> WebView.Binding) -> WebViewName<V> {
		return WebViewName<V>(source: source, downcast: Binding.webViewBinding)
	}
}
extension BindingName where Binding: WebViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WebViewName<$2> { return .name(WebView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var allowsAirPlayForMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsAirPlayForMediaPlayback) }
	static var allowsInlineMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsInlineMediaPlayback) }
	static var allowsPictureInPictureForMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsPictureInPictureForMediaPlayback) }
	static var applicationNameForUserAgent: WebViewName<Constant<String?>> { return .name(WebView.Binding.applicationNameForUserAgent) }
	static var dataDetectorTypes: WebViewName<Constant<WebView.WKDataDetectorTypes>> { return .name(WebView.Binding.dataDetectorTypes) }
	static var ignoresViewportScaleLimits: WebViewName<Constant<Bool>> { return .name(WebView.Binding.ignoresViewportScaleLimits) }
	static var javaScriptCanOpenWindowsAutomatically: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaScriptCanOpenWindowsAutomatically) }
	static var javaScriptEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaScriptEnabled) }
	static var mediaTypesRequiringUserActionForPlayback: WebViewName<Constant<WKAudiovisualMediaTypes>> { return .name(WebView.Binding.mediaTypesRequiringUserActionForPlayback) }
	static var minimumFontSize: WebViewName<Constant<CGFloat>> { return .name(WebView.Binding.minimumFontSize) }
	static var processPool: WebViewName<Constant<WKProcessPool>> { return .name(WebView.Binding.processPool) }
	static var selectionGranularity: WebViewName<Constant<WebView.WKSelectionGranularity>> { return .name(WebView.Binding.selectionGranularity) }
	static var suppressesIncrementalRendering: WebViewName<Constant<Bool>> { return .name(WebView.Binding.suppressesIncrementalRendering) }
	static var urlSchemeHandlers: WebViewName<Constant<[String: WKURLSchemeHandler]>> { return .name(WebView.Binding.urlSchemeHandlers) }
	static var userContentController: WebViewName<Constant<WKUserContentController>> { return .name(WebView.Binding.userContentController) }
	
	@available(macOS 10.10, *) @available(iOS, unavailable) static var javaEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var plugInsEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.plugInsEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var tabFocusesLinks: WebViewName<Constant<Bool>> { return .name(WebView.Binding.tabFocusesLinks) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var userInterfaceDirectionPolicy: WebViewName<Constant<WebView.WKUserInterfaceDirectionPolicy>> { return .name(WebView.Binding.userInterfaceDirectionPolicy) }
	@available(macOS, unavailable) @available(iOS 9, *) static var allowsPictureInPictureMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsPictureInPictureMediaPlayback) }
	@available(macOS, unavailable) @available(iOS 11, *) static var scrollView: WebViewName<Constant<ScrollView>> { return .name(WebView.Binding.scrollView) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsBackForwardNavigationGestures: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsBackForwardNavigationGestures) }
	
	static var allowsLinkPreview: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsLinkPreview) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var allowsMagnification: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsMagnification) }
	static var customUserAgent: WebViewName<Dynamic<String?>> { return .name(WebView.Binding.customUserAgent) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var magnification: WebViewName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>> { return .name(WebView.Binding.magnification) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var evaluateJavaScript: WebViewName<Signal<Callback<String, (Any?, Error?)>>> { return .name(WebView.Binding.evaluateJavaScript) }
	static var goBack: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.goBack) }
	static var goForward: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.goForward) }
	static var goTo: WebViewName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>> { return .name(WebView.Binding.goTo) }
	static var load: WebViewName<Signal<Callback<URLRequest, WKNavigation?>>> { return .name(WebView.Binding.load) }
	static var loadHTMLString: WebViewName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>> { return .name(WebView.Binding.loadHTMLString) }
	static var reload: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.reload) }
	static var reloadFromOrigin: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.reloadFromOrigin) }
	static var stopLoading: WebViewName<Signal<Void>> { return .name(WebView.Binding.stopLoading) }
	
	static var loadData: WebViewName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>> { return .name(WebView.Binding.loadData) }
	static var loadFile: WebViewName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>> { return .name(WebView.Binding.loadFile) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var createWebView: WebViewName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?> { return .name(WebView.Binding.createWebView) }
	static var didClose: WebViewName<(WKWebView) -> Void> { return .name(WebView.Binding.didClose) }
	static var didCommit: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didCommit) }
	static var didStartProvisionalNavigation: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didStartProvisionalNavigation) }
	static var didReceiveServerRedirectForProvisionalNavigation: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didReceiveServerRedirectForProvisionalNavigation) }
	static var didFail: WebViewName<(WKWebView, WKNavigation, Error) -> Void> { return .name(WebView.Binding.didFail) }
	static var didFailProvisionalNavigation: WebViewName<(WKWebView, WKNavigation, Error) -> Void> { return .name(WebView.Binding.didFailProvisionalNavigation) }
	static var didFinish: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didFinish) }
	static var contentProcessDidTerminate: WebViewName<(WKWebView) -> Void> { return .name(WebView.Binding.contentProcessDidTerminate) }
	static var decideActionPolicy: WebViewName<(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void> { return .name(WebView.Binding.decideActionPolicy) }
	static var decideResponsePolicy: WebViewName<(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void> { return .name(WebView.Binding.decideResponsePolicy) }
	static var didReceiveAuthenticationChallenge: WebViewName<(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void> { return .name(WebView.Binding.didReceiveAuthenticationChallenge) }
	static var runJavaScriptAlertPanel: WebViewName<(WKWebView, String, WKFrameInfo, () -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptAlertPanel) }
	static var runJavaScriptConfirmPanel: WebViewName<(WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptConfirmPanel) }
	static var runJavaScriptTextInputPanel: WebViewName<(WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptTextInputPanel) }
	
	@available(macOS, unavailable) @available(iOS 10.0, *) static var commitPreviewingViewController: WebViewName<(_ webView: WKWebView, _ previewingViewController: WebView.UIViewController) -> Void> { return .name(WebView.Binding.commitPreviewingViewController) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var previewingViewController: WebViewName<(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo, _ previewActions: [WebView.WKPreviewActionItem]) -> WebView.UIViewController?> { return .name(WebView.Binding.previewingViewController) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var runOpenPanel: WebViewName<(WKWebView, WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void> { return .name(WebView.Binding.runOpenPanel) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var shouldPreviewElement: WebViewName<(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo) -> Bool> { return .name(WebView.Binding.shouldPreviewElement) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol WebViewConvertible: ViewConvertible {
	func wkWebView() -> WebView.Instance
}
extension WebViewConvertible {
	#if os(macOS)
		func nsView() -> View.Instance { return wkWebView() }
	#else
		func uiView() -> View.Instance { return wkWebView() }
	#endif
}
extension WKWebView: WebViewConvertible, HasDelegate {
	func wkWebView() -> WebView.Instance { return self }
	var delegate: WKNavigationDelegate? {
		get { return navigationDelegate }
		set { navigationDelegate = newValue }
	}
}
extension WebView {
	func wkWebView() -> WebView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol WebViewBinding: ViewBinding {
	static func webViewBinding(_ binding: WebView.Binding) -> Self
}
extension WebViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return webViewBinding(.inheritedBinding(binding))
	}
}
extension WebView.Binding {
	typealias Preparer = WebView.Preparer
	static func webViewBinding(_ binding: WebView.Binding) -> WebView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types


#if os(iOS)

// MARK: - Binder Part 1: Binder
class AlertAction: Binder, AlertActionConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension AlertAction {
	enum Binding: AlertActionBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case style(Constant<UIAlertAction.Style>)
		case title(Constant<String>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case handler(SignalInput<Void>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension AlertAction {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = AlertAction.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIAlertAction
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var title: String? = nil
		var style: UIAlertAction.Style = .default
		var handler: MultiOutput<Void>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension AlertAction.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(title: title, style: style, handler: handler.map { h in
			{ _ in h.input.send(value: ()) }
		})
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let s): return inherited.prepareBinding(s)
		
		case .style(let x): style = x.value
		case .title(let x): title = x.value
		
		case .handler(let x):
			handler = handler ?? Input<Void>().multicast()
			handler?.signal.bind(to: x)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .style: return nil
		case .title: return nil
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case .handler: return handler?.input

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension AlertAction.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: AlertActionBinding {
	typealias AlertActionName<V> = BindingName<V, AlertAction.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> AlertAction.Binding) -> AlertActionName<V> {
		return AlertActionName<V>(source: source, downcast: Binding.alertActionBinding)
	}
}
extension BindingName where Binding: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: AlertActionName<$2> { return .name(AlertAction.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var style: AlertActionName<Constant<UIAlertAction.Style>> { return .name(AlertAction.Binding.style) }
	static var title: AlertActionName<Constant<String>> { return .name(AlertAction.Binding.title) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: AlertActionName<Dynamic<Bool>> { return .name(AlertAction.Binding.isEnabled) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var handler: AlertActionName<SignalInput<Void>> { return .name(AlertAction.Binding.handler) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol AlertActionConvertible {
	func uiAlertAction() -> AlertAction.Instance
}
extension UIAlertAction: AlertActionConvertible, DefaultConstructable {
	func uiAlertAction() -> AlertAction.Instance { return self }
}
extension AlertAction {
	func uiAlertAction() -> AlertAction.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol AlertActionBinding: BinderBaseBinding {
	static func alertActionBinding(_ binding: AlertAction.Binding) -> Self
}
extension AlertActionBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return alertActionBinding(.inheritedBinding(binding))
	}
}
extension AlertAction.Binding {
	typealias Preparer = AlertAction.Preparer
	static func alertActionBinding(_ binding: AlertAction.Binding) -> AlertAction.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class AlertController: Binder, AlertControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension AlertController {
	enum Binding: AlertControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case actions(Constant<[AlertActionConvertible]>)
		case preferredStyle(Constant<UIAlertController.Style>)
		case textFields(Constant<[TextField]>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case message(Dynamic<String?>)
		case preferredActionIndex(Dynamic<Int?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension AlertController {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = AlertController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = UIAlertController
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var title = InitialSubsequent<String>()
		var message = InitialSubsequent<String?>()
		var preferredStyle: UIAlertController.Style = .alert
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension AlertController.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(title: title.initial, message: message.initial ?? nil, preferredStyle: preferredStyle)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let s): return inherited.prepareBinding(s)
		case .preferredStyle(let x): preferredStyle = x.value
		case .message(let x): message = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .actions(let x):
			for a in x.value {
				instance.addAction(a.uiAlertAction())
			}
			return nil
		case .preferredStyle: return nil
		case .textFields(let x):
			for bindings in x.value {
				instance.addTextField { textField in bindings.apply(to: textField) }
			}
			return nil
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .message(let x): return x.apply(instance) { i, v in i.message = v }
		case .preferredActionIndex(let x): return x.apply(instance) { i, v in i.preferredAction = v.map { i.actions[$0] } }
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension AlertController.Preparer {
	typealias Storage = ViewController.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: AlertControllerBinding {
	typealias AlertControllerName<V> = BindingName<V, AlertController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> AlertController.Binding) -> AlertControllerName<V> {
		return AlertControllerName<V>(source: source, downcast: Binding.alertControllerBinding)
	}
}
extension BindingName where Binding: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: AlertControllerName<$2> { return .name(AlertController.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var actions: AlertControllerName<Constant<[AlertActionConvertible]>> { return .name(AlertController.Binding.actions) }
	static var preferredStyle: AlertControllerName<Constant<UIAlertController.Style>> { return .name(AlertController.Binding.preferredStyle) }
	static var textFields: AlertControllerName<Constant<[TextField]>> { return .name(AlertController.Binding.textFields) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var message: AlertControllerName<Dynamic<String?>> { return .name(AlertController.Binding.message) }
	static var preferredActionIndex: AlertControllerName<Dynamic<Int?>> { return .name(AlertController.Binding.preferredActionIndex) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol AlertControllerConvertible: ViewControllerConvertible {
	func uiAlertController() -> AlertController.Instance
}
extension AlertControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiAlertController() }
}
extension UIAlertController: AlertControllerConvertible {
	func uiAlertController() -> AlertController.Instance { return self }
}
extension AlertController {
	func uiAlertController() -> AlertController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol AlertControllerBinding: ViewControllerBinding {
	static func alertControllerBinding(_ binding: AlertController.Binding) -> Self
}
extension AlertControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return alertControllerBinding(.inheritedBinding(binding))
	}
}
extension AlertController.Binding {
	typealias Preparer = AlertController.Preparer
	static func alertControllerBinding(_ binding: AlertController.Binding) -> AlertController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

import UIKit

func applicationMain(type: UIApplication.Type = UIApplication.self, application: @escaping () -> Application) -> Never {
	Application.Preparer.Storage.storedApplicationConstructor = application
	_ = UIApplicationMain(CommandLine.argc, CommandLine.unsafeArgv, NSStringFromClass(type), NSStringFromClass(Application.Preparer.Storage.self))
	fatalError("UIApplicationMain completed unexpectedly")
}

// MARK: - Binder Part 1: Binder
class Application: Binder {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		precondition(type == Preparer.Instance.self, "Custom application subclass must be specified as parameter to `applicationMain`")
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Application {
	enum Binding: ApplicationBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case iconBadgeNumber(Dynamic<Int>)
		case isIdleTimerDisabled(Dynamic<Bool>)
		case isNetworkActivityIndicatorVisible(Dynamic<Bool>)
		case shortcutItems(Dynamic<[UIApplicationShortcutItem]?>)
		case supportShakeToEdit(Dynamic<Bool>)
		case window(Dynamic<WindowConvertible?>)

		//	2. Signal bindings are performed on the object after construction.
		case ignoreInteractionEvents(Signal<Bool>)
		case registerForRemoteNotifications(Signal<Bool>)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case continueUserActivity((_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool)
		case didBecomeActive((UIApplication) -> Void)
		case didDecodeRestorableState((UIApplication, NSKeyedUnarchiver) -> Void)
		case didEnterBackground((UIApplication) -> Void)
		case didFailToContinueUserActivity((UIApplication, String, Error) -> Void)
		case didFinishLaunching((_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case didReceiveMemoryWarning((UIApplication) -> Void)
		case didReceiveRemoteNotification((UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void)
		case didRegisterRemoteNotifications((UIApplication, Error) -> Void)
		case didUpdate((_ application: UIApplication, NSUserActivity) -> Void)
		case handleEventsForBackgroundURLSession((UIApplication, String, @escaping () -> Void) -> Void)
		case handleWatchKitExtensionRequest((UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void)
		case open((_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool)
		case performAction((UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void)
		case performFetch((UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void)
		case protectedDataDidBecomeAvailable((UIApplication) -> Void)
		case protectedDataWillBecomeUnavailable((UIApplication) -> Void)
		case shouldAllowExtensionPointIdentifier((_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool)
		case shouldRequestHealthAuthorization((_ application: UIApplication) -> Void)
		case significantTimeChange((UIApplication) -> Void)
		case viewControllerWithRestorationPath((_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?)
		case willContinueUserActivity((_ application: UIApplication, String) -> Bool)
		case willEncodeRestorableState((_ application: UIApplication, NSKeyedArchiver) -> Void)
		case willEnterForeground((UIApplication) -> Void)
		case willFinishLaunching((_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case willResignActive((UIApplication) -> Void)
		case willTerminate((_ application: UIApplication) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension Application {
	struct Preparer: BinderDelegateEmbedder {
		typealias Binding = Application.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIApplication
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage.storedStorage! }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Application.Preparer {
	var delegateIsRequired: Bool { return true }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let s): inherited.prepareBinding(s)

		case .continueUserActivity(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:continue:restorationHandler:)))
		case .didBecomeActive(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidBecomeActive(_:)))
		case .didDecodeRestorableState(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didDecodeRestorableStateWith:)))
			delegate().addSingleHandler2({ (a: UIApplication, c: NSCoder) in true }, #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:)))
		case .didEnterBackground(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidEnterBackground(_:)))
		case .didFailToContinueUserActivity(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:)))
		case .didFinishLaunching(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:didFinishLaunchingWithOptions:)))
		case .didReceiveMemoryWarning(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidReceiveMemoryWarning(_:)))
		case .didReceiveRemoteNotification(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:didReceiveRemoteNotification:fetchCompletionHandler:)))
		case .didRegisterRemoteNotifications(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:)))
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:)))
		case .didUpdate(let x): delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didUpdate:)))
		case .handleEventsForBackgroundURLSession(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:handleEventsForBackgroundURLSession:completionHandler:)))
		case .handleWatchKitExtensionRequest(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:handleWatchKitExtensionRequest:reply:)))
		case .open(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:open:options:)))
		case .performAction(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:performActionFor:completionHandler:)))
		case .performFetch(let x): delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:performFetchWithCompletionHandler:)))
		case .protectedDataWillBecomeUnavailable(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationProtectedDataWillBecomeUnavailable(_:)))
		case .protectedDataDidBecomeAvailable(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:)))
		case .shouldAllowExtensionPointIdentifier(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:shouldAllowExtensionPointIdentifier:)))
		case .shouldRequestHealthAuthorization(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationShouldRequestHealthAuthorization(_:)))
		case .significantTimeChange(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationSignificantTimeChange(_:)))
		case .viewControllerWithRestorationPath(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:viewControllerWithRestorationIdentifierPath:coder:)))
		case .willContinueUserActivity(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:willContinueUserActivityWithType:)))
		case .willEncodeRestorableState(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:willEncodeRestorableStateWith:)))
			delegate().addSingleHandler2({ (a: UIApplication, c: NSCoder) in true }, #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:)))
		case .willEnterForeground(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillEnterForeground(_:)))
		case .willResignActive(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillResignActive(_:)))
		case .willTerminate(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillTerminate(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .iconBadgeNumber(let x): return x.apply(instance) { i, v in i.applicationIconBadgeNumber = v }
		case .isIdleTimerDisabled(let x): return x.apply(instance) { i, v in i.isIdleTimerDisabled = v }
		case .isNetworkActivityIndicatorVisible(let x): return x.apply(instance) { i, v in i.isNetworkActivityIndicatorVisible = v }
		case .shortcutItems(let x): return x.apply(instance) { i, v in i.shortcutItems = v }
		case .supportShakeToEdit(let x): return x.apply(instance) { i, v in i.applicationSupportsShakeToEdit = v }
		case .window(let x): return x.apply(instance, storage) { i, s, v in s.window = v?.uiWindow() }

		//	2. Signal bindings are performed on the object after construction.
		case .ignoreInteractionEvents(let x):
			return x.apply(instance) { i, v in
				switch (i.isIgnoringInteractionEvents, v) {
				case (false, true): i.beginIgnoringInteractionEvents()
				case (true, false): i.endIgnoringInteractionEvents()
				default: break
				}
			}
		case .registerForRemoteNotifications(let x):
			return x.apply(instance) { i, v in
				switch (i.isRegisteredForRemoteNotifications, v) {
				case (false, true): i.registerForRemoteNotifications()
				case (true, false): i.unregisterForRemoteNotifications()
				default: break
				}
			}

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .didBecomeActive: return nil
		case .didEnterBackground: return nil
		case .didFailToContinueUserActivity: return nil
		case .didReceiveMemoryWarning: return nil
		case .didReceiveRemoteNotification: return nil
		case .didRegisterRemoteNotifications: return nil
		case .handleEventsForBackgroundURLSession: return nil
		case .handleWatchKitExtensionRequest: return nil
		case .performAction: return nil
		case .performFetch: return nil
		case .protectedDataDidBecomeAvailable: return nil
		case .protectedDataWillBecomeUnavailable: return nil
		case .significantTimeChange: return nil
		case .willEnterForeground: return nil
		case .willResignActive: return nil
		case .continueUserActivity: return nil
		case .didDecodeRestorableState: return nil
		case .didFinishLaunching: return nil
		case .didUpdate: return nil
		case .open: return nil
		case .shouldAllowExtensionPointIdentifier: return nil
		case .shouldRequestHealthAuthorization: return nil
		case .viewControllerWithRestorationPath: return nil
		case .willContinueUserActivity: return nil
		case .willEncodeRestorableState: return nil
		case .willFinishLaunching(let x):
			storage.willFinishLaunching = x
			return nil
		case .willTerminate: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Application.Preparer {
	class Storage: AssociatedBinderStorage, UIApplicationDelegate {
		static var storedApplicationConstructor: (() -> Application)? = nil
		static var storedStorage: Storage? = nil
		
		var window: UIWindow? = nil
		var additionalWindows: [UIWindow] = []
		var willFinishLaunching: ((UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)?

		override var isInUse: Bool {
			return true
		}
		
		func applyToSharedApplication() {
			// If the storageApplicationConstructor is not set, this function is a no-op. This is useful during testing.
			guard let application = Storage.storedApplicationConstructor else { return }
			
			// Disconnect the delegate since we're about to change the handled delegate methods
			UIApplication.shared.delegate = nil
			Application.Preparer.Storage.storedStorage = self
			
			// Apply the styles to the application and delegate.
			application().apply(to: UIApplication.shared)
			
			Application.Preparer.Storage.storedApplicationConstructor = nil
			Application.Preparer.Storage.storedStorage = nil
			
			// Ensure that the delegate was reapplied
			assert(UIApplication.shared.delegate === self, "Failed to reconnect delegate")
			
			// Apply the view hierarchy
			window?.makeKeyAndVisible()
		}
		
		func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
			applyToSharedApplication()
			
			// Invoke any user-supplied code
			return willFinishLaunching?(application, launchOptions) ?? true
		}
	}

	class Delegate: DynamicDelegate, UIApplicationDelegate {
		func applicationDidBecomeActive(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func applicationWillResignActive(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func applicationDidEnterBackground(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func applicationWillEnterForeground(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
			return singleHandler(application, launchOptions)
		}
		
		func applicationWillTerminate(_ application: UIApplication) {
			return singleHandler(application)
		}
		
		func applicationProtectedDataWillBecomeUnavailable(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func applicationProtectedDataDidBecomeAvailable(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func application(_ application: UIApplication, willEncodeRestorableStateWith coder: NSCoder) {
			return multiHandler(application, coder as! NSKeyedArchiver)
		}
		
		func application(_ application: UIApplication, didDecodeRestorableStateWith coder: NSCoder) {
			return multiHandler(application, coder as! NSKeyedUnarchiver)
		}
		
		func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			multiHandler(application, completionHandler)
		}
		
		func application(_ application: UIApplication, handleEventsForBackgroundURLSession session: String, completionHandler: @escaping () -> Void) {
			multiHandler(application, session, completionHandler)
		}
		
		func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			multiHandler(application, deviceToken)
		}
		
		func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			multiHandler(application, error)
		}
		
		func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			multiHandler(application, userInfo, completionHandler)
		}
		
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], completionHandler: @escaping () -> Void) {
			multiHandler(application, identifier, userInfo, completionHandler)
		}
		
		func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			multiHandler(application, identifier, userInfo, responseInfo, completionHandler)
		}
		
		func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			multiHandler(application, userActivityType, error)
		}
		
		func application(_ application: UIApplication, handleWatchKitExtensionRequest userInfo: [AnyHashable : Any]?, reply: @escaping ([AnyHashable : Any]?) -> Void) {
			multiHandler(application, userInfo, reply)
		}
		
		func applicationShouldRequestHealthAuthorization(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
			return singleHandler(application, userActivityType)
		}
		
		func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
			return singleHandler(application, userActivity, restorationHandler)
		}
		
		func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity) {
			multiHandler(application, userActivity)
		}
		
		func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
			// The existence of this selector on the dynamic delegate triggers an always true response
			return true
		}
		
		func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
			// The existence of this selector on the dynamic delegate triggers an always true response
			return true
		}
		
		func applicationSignificantTimeChange(_ application: UIApplication) {
			multiHandler(application)
		}
		
		func application(_ application: UIApplication, viewControllerWithRestorationIdentifierPath identifierComponents: [String], coder: NSCoder) -> UIViewController? {
			return singleHandler(application, identifierComponents, coder)
		}
		
		func application(_ application: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
			return singleHandler(application, url, options)
		}
		
		func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier) -> Bool {
			return singleHandler(application, extensionPointIdentifier)
		}
		
		func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
			multiHandler(application, shortcutItem, completionHandler)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ApplicationBinding {
	typealias ApplicationName<V> = BindingName<V, Application.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Application.Binding) -> ApplicationName<V> {
		return ApplicationName<V>(source: source, downcast: Binding.applicationBinding)
	}
}
extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ApplicationName<$2> { return .name(Application.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var iconBadgeNumber: ApplicationName<Dynamic<Int>> { return .name(Application.Binding.iconBadgeNumber) }
	static var isIdleTimerDisabled: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.isIdleTimerDisabled) }
	static var isNetworkActivityIndicatorVisible: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.isNetworkActivityIndicatorVisible) }
	static var shortcutItems: ApplicationName<Dynamic<[UIApplicationShortcutItem]?>> { return .name(Application.Binding.shortcutItems) }
	static var supportShakeToEdit: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.supportShakeToEdit) }
	static var window: ApplicationName<Dynamic<WindowConvertible?>> { return .name(Application.Binding.window) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var ignoreInteractionEvents: ApplicationName<Signal<Bool>> { return .name(Application.Binding.ignoreInteractionEvents) }
	static var registerForRemoteNotifications: ApplicationName<Signal<Bool>> { return .name(Application.Binding.registerForRemoteNotifications) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: ApplicationName<(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool> { return .name(Application.Binding.continueUserActivity) }
	static var didBecomeActive: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didBecomeActive) }
	static var didDecodeRestorableState: ApplicationName<(_ application: UIApplication, NSKeyedUnarchiver) -> Void> { return .name(Application.Binding.didDecodeRestorableState) }
	static var didEnterBackground: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didEnterBackground) }
	static var didFailToContinueUserActivity: ApplicationName<(UIApplication, String, Error) -> Void> { return .name(Application.Binding.didFailToContinueUserActivity) }
	static var didFinishLaunching: ApplicationName<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> { return .name(Application.Binding.didFinishLaunching) }
	static var didReceiveMemoryWarning: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didReceiveMemoryWarning) }
	static var didReceiveRemoteNotification: ApplicationName<(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void> { return .name(Application.Binding.didReceiveRemoteNotification) }
	static var didRegisterRemoteNotifications: ApplicationName<(UIApplication, Error) -> Void> { return .name(Application.Binding.didRegisterRemoteNotifications) }
	static var didUpdate: ApplicationName<(_ application: UIApplication, NSUserActivity) -> Void> { return .name(Application.Binding.didUpdate) }
	static var handleEventsForBackgroundURLSession: ApplicationName<(UIApplication, String, @escaping () -> Void) -> Void> { return .name(Application.Binding.handleEventsForBackgroundURLSession) }
	static var handleWatchKitExtensionRequest: ApplicationName<(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void> { return .name(Application.Binding.handleWatchKitExtensionRequest) }
	static var open: ApplicationName<(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool> { return .name(Application.Binding.open) }
	static var performAction: ApplicationName<(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void> { return .name(Application.Binding.performAction) }
	static var performFetch: ApplicationName<(UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void> { return .name(Application.Binding.performFetch) }
	static var protectedDataDidBecomeAvailable: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.protectedDataDidBecomeAvailable) }
	static var protectedDataWillBecomeUnavailable: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.protectedDataWillBecomeUnavailable) }
	static var shouldAllowExtensionPointIdentifier: ApplicationName<(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool> { return .name(Application.Binding.shouldAllowExtensionPointIdentifier) }
	static var shouldRequestHealthAuthorization: ApplicationName<(_ application: UIApplication) -> Void> { return .name(Application.Binding.shouldRequestHealthAuthorization) }
	static var significantTimeChange: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.significantTimeChange) }
	static var viewControllerWithRestorationPath: ApplicationName<(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?> { return .name(Application.Binding.viewControllerWithRestorationPath) }
	static var willContinueUserActivity: ApplicationName<(_ application: UIApplication, String) -> Bool> { return .name(Application.Binding.willContinueUserActivity) }
	static var willEncodeRestorableState: ApplicationName<(_ application: UIApplication, NSKeyedArchiver) -> Void> { return .name(Application.Binding.willEncodeRestorableState) }
	static var willEnterForeground: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.willEnterForeground) }
	static var willFinishLaunching: ApplicationName<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> { return .name(Application.Binding.willFinishLaunching) }
	static var willResignActive: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.willResignActive) }
	static var willTerminate: ApplicationName<(_ application: UIApplication) -> Void> { return .name(Application.Binding.willTerminate) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension UIApplication: HasDelegate {}

// MARK: - Binder Part 8: Downcast protocols
protocol ApplicationBinding: BinderBaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -> Self
}
extension ApplicationBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}
extension Application.Binding {
	typealias Preparer = Application.Preparer
	static func applicationBinding(_ binding: Application.Binding) -> Application.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
enum ApplicationTerminateReply {
	case now
	case cancel
	case later(Signal<Bool>)
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class BarButtonItem: Binder, BarButtonItemConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension BarButtonItem {
	enum Binding: BarButtonItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UIBarButtonItem.SystemItem>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case backButtonBackgroundImage(Dynamic<ScopedValues<StateAndMetrics, UIImage?>>)
		case backButtonTitlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case backgroundImage(Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>)
		case backgroundVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case customView(Dynamic<ViewConvertible?>)
		case itemStyle(Dynamic<UIBarButtonItem.Style>)
		case possibleTitles(Dynamic<Set<String>?>)
		case tintColor(Dynamic<UIColor?>)
		case titlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case width(Dynamic<CGFloat>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension BarButtonItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = BarButtonItem.Binding
		typealias Inherited = BarItem.Preparer
		typealias Instance = UIBarButtonItem
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var systemItem: UIBarButtonItem.SystemItem?
		var customView = InitialSubsequent<ViewConvertible?>()
		var itemStyle = InitialSubsequent<UIBarButtonItem.Style>()
		var image = InitialSubsequent<UIImage?>()
		var landscapeImagePhone = InitialSubsequent<UIImage?>()
		var title = InitialSubsequent<String>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension BarButtonItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		let x: UIBarButtonItem
		if let si = systemItem {
			x = type.init(barButtonSystemItem: si, target: nil, action: nil)
		} else if case .some(.some(let cv)) = customView.initial {
			x = type.init(customView: cv.uiView())
		} else if case .some(.some(let i)) = image.initial {
			x = type.init(image: i, landscapeImagePhone: landscapeImagePhone.initial ?? nil, style: itemStyle.initial ?? .plain, target: nil, action: nil)
		} else {
			x = type.init(title: title.initial ?? nil, style: itemStyle.initial ?? .plain, target: nil, action: nil)
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.image(let x)): image = x.initialSubsequent()
		case .inheritedBinding(.landscapeImagePhone(let x)): landscapeImagePhone = x.initialSubsequent()
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .systemItem(let x): systemItem = x.value
		case .customView(let x): customView = x.initialSubsequent()
		case .itemStyle(let x): itemStyle = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.image): return image.apply(instance) { i, v in i.image = v }
		case .inheritedBinding(.landscapeImagePhone): return landscapeImagePhone.apply(instance) { i, v in i.landscapeImagePhone = v }
		case .inheritedBinding(.title): return title.apply(instance) { i, v in i.title = v }
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .systemItem: return nil
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .backButtonBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackButtonBackgroundImage(nil, for: scope.controlState, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackButtonBackgroundImage(v, for: scope.controlState, barMetrics: scope.barMetrics) }
			)
		case .backButtonTitlePositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackButtonTitlePositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setBackButtonTitlePositionAdjustment(v, for: scope) }
			)
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.controlState, style: scope.itemStyle, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.controlState, style: scope.itemStyle, barMetrics: scope.barMetrics) }
			)
		case .backgroundVerticalPositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundVerticalPositionAdjustment(0, for: scope) },
				applyNew: { i, scope, v in i.setBackgroundVerticalPositionAdjustment(v, for: scope) }
			)
		case .customView: return customView.apply(instance) { i, v in i.customView = v?.uiView() }
		case .itemStyle: return itemStyle.apply(instance) { i, v in i.style = v }
		case .possibleTitles(let x): return x.apply(instance) { i, v in i.possibleTitles = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .titlePositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitlePositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setTitlePositionAdjustment(v, for: scope) }
			)
		case .width(let x): return x.apply(instance) { i, v in i.width = v }
			
		//	2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension BarButtonItem.Preparer {
	typealias Storage = BarItem.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: BarButtonItemBinding {
	typealias BarButtonItemName<V> = BindingName<V, BarButtonItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BarButtonItem.Binding) -> BarButtonItemName<V> {
		return BarButtonItemName<V>(source: source, downcast: Binding.barButtonItemBinding)
	}
}
extension BindingName where Binding: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BarButtonItemName<$2> { return .name(BarButtonItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BarButtonItemName<Constant<UIBarButtonItem.SystemItem>> { return .name(BarButtonItem.Binding.systemItem) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backButtonBackgroundImage: BarButtonItemName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>> { return .name(BarButtonItem.Binding.backButtonBackgroundImage) }
	static var backButtonTitlePositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> { return .name(BarButtonItem.Binding.backButtonTitlePositionAdjustment) }
	static var backgroundImage: BarButtonItemName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>> { return .name(BarButtonItem.Binding.backgroundImage) }
	static var backgroundVerticalPositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> { return .name(BarButtonItem.Binding.backgroundVerticalPositionAdjustment) }
	static var customView: BarButtonItemName<Dynamic<ViewConvertible?>> { return .name(BarButtonItem.Binding.customView) }
	static var itemStyle: BarButtonItemName<Dynamic<UIBarButtonItem.Style>> { return .name(BarButtonItem.Binding.itemStyle) }
	static var possibleTitles: BarButtonItemName<Dynamic<Set<String>?>> { return .name(BarButtonItem.Binding.possibleTitles) }
	static var tintColor: BarButtonItemName<Dynamic<UIColor?>> { return .name(BarButtonItem.Binding.tintColor) }
	static var titlePositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> { return .name(BarButtonItem.Binding.titlePositionAdjustment) }
	static var width: BarButtonItemName<Dynamic<CGFloat>> { return .name(BarButtonItem.Binding.width) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: BarButtonItemName<TargetAction> { return .name(BarButtonItem.Binding.action) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> BarButtonItemName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, BarButtonItem.Binding.action, Binding.barButtonItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol BarButtonItemConvertible: BarItemConvertible {
	func uiBarButtonItem() -> BarButtonItem.Instance
}
extension BarButtonItemConvertible {
	func uiBarItem() -> BarItem.Instance { return uiBarButtonItem() }
}
extension UIBarButtonItem: BarButtonItemConvertible, TargetActionSender {
	func uiBarButtonItem() -> BarButtonItem.Instance { return self }
}
extension BarButtonItem {
	func uiBarButtonItem() -> BarButtonItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol BarButtonItemBinding: BarItemBinding {
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> Self
}
extension BarButtonItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return barButtonItemBinding(.inheritedBinding(binding))
	}
}
extension BarButtonItem.Binding {
	typealias Preparer = BarButtonItem.Preparer
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> BarButtonItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct StateStyleAndMetrics {
	let controlState: UIControl.State
	let itemStyle: UIBarButtonItem.Style
	let barMetrics: UIBarMetrics
	init(state: UIControl.State = .normal, style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.itemStyle = style
		self.barMetrics = metrics
	}
}

struct StateAndMetrics {
	let controlState: UIControl.State
	let barMetrics: UIBarMetrics
	init(state: UIControl.State = .normal, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == StateAndMetrics {
	static func normal(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .selected, metrics: metrics))
	}
	static func focused(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == StateStyleAndMetrics {
	static func normal(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .selected, metrics: metrics))
	}
	static func focused(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == UIBarMetrics {
	static func `default`(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .default, value: value)
	}
	static func compact(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compact, value: value)
	}
	static func defaultPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .defaultPrompt, value: value)
	}
	static func compactPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compactPrompt, value: value)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class BarItem: Binder, BarItemConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension BarItem {
	enum Binding: BarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case imageInsets(Dynamic<UIEdgeInsets>)
		case isEnabled(Dynamic<Bool>)
		case landscapeImagePhone(Dynamic<UIImage?>)
		case landscapeImagePhoneInsets(Dynamic<UIEdgeInsets>)
		case tag(Dynamic<Int>)
		case title(Dynamic<String>)
		case titleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension BarItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = BarItem.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIBarItem
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension BarItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageInsets(let x): return x.apply(instance) { i, v in i.imageInsets = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .landscapeImagePhone(let x): return x.apply(instance) { i, v in i.landscapeImagePhone = v }
		case .landscapeImagePhoneInsets(let x): return x.apply(instance) { i, v in i.landscapeImagePhoneInsets = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titleTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleTextAttributes([:], for: scope) },
				applyNew: { i, scope, v in i.setTitleTextAttributes(v, for: scope) }
			)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension BarItem.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: BarItemBinding {
	typealias BarItemName<V> = BindingName<V, BarItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BarItem.Binding) -> BarItemName<V> {
		return BarItemName<V>(source: source, downcast: Binding.barItemBinding)
	}
}
extension BindingName where Binding: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BarItemName<$2> { return .name(BarItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var image: BarItemName<Dynamic<UIImage?>> { return .name(BarItem.Binding.image) }
	static var imageInsets: BarItemName<Dynamic<UIEdgeInsets>> { return .name(BarItem.Binding.imageInsets) }
	static var isEnabled: BarItemName<Dynamic<Bool>> { return .name(BarItem.Binding.isEnabled) }
	static var landscapeImagePhone: BarItemName<Dynamic<UIImage?>> { return .name(BarItem.Binding.landscapeImagePhone) }
	static var landscapeImagePhoneInsets: BarItemName<Dynamic<UIEdgeInsets>> { return .name(BarItem.Binding.landscapeImagePhoneInsets) }
	static var tag: BarItemName<Dynamic<Int>> { return .name(BarItem.Binding.tag) }
	static var title: BarItemName<Dynamic<String>> { return .name(BarItem.Binding.title) }
	static var titleTextAttributes: BarItemName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>> { return .name(BarItem.Binding.titleTextAttributes) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol BarItemConvertible {
	func uiBarItem() -> BarItem.Instance
}
extension UIBarItem: BarItemConvertible, DefaultConstructable {
	func uiBarItem() -> BarItem.Instance { return self }
}
extension BarItem {
	func uiBarItem() -> BarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol BarItemBinding: BinderBaseBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self
}
extension BarItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return barItemBinding(.inheritedBinding(binding))
	}
}
extension BarItem.Binding {
	typealias Preparer = BarItem.Preparer
	static func barItemBinding(_ binding: BarItem.Binding) -> BarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Button: Binder, ButtonConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Button {
	enum Binding: ButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case imageView(Constant<ImageView>)
		case titleLabel(Constant<Label>)
		case type(Constant<UIButton.ButtonType>)
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsImageWhenDisabled(Dynamic<Bool>)
		case adjustsImageWhenHighlighted(Dynamic<Bool>)
		case attributedTitle(Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>)
		case backgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case contentEdgeInsets(Dynamic<UIEdgeInsets>)
		case image(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case imageEdgeInsets(Dynamic<UIEdgeInsets>)
		case showsTouchWhenHighlighted(Dynamic<Bool>)
		case title(Dynamic<ScopedValues<UIControl.State, String?>>)
		case titleColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case titleEdgeInsets(Dynamic<UIEdgeInsets>)
		case titleShadowColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Button {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Button.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = UIButton
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var type: UIButton.ButtonType = .roundedRect
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Button.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(type: self.type)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .type(let x): type = x.value
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .imageView(let x):
			if let iv = instance.imageView {
				x.value.apply(to: iv)
			}
			return nil
		case .titleLabel(let x):
			if let tl = instance.titleLabel {
				x.value.apply(to: tl)
			}
			return nil
		case .type: return nil
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsImageWhenDisabled(let x): return x.apply(instance) { i, v in i.adjustsImageWhenDisabled = v }
		case .adjustsImageWhenHighlighted(let x): return x.apply(instance) { i, v in i.adjustsImageWhenHighlighted = v }
		case .attributedTitle(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setAttributedTitle(nil, for: scope) },
				applyNew: { i, scope, v in i.setAttributedTitle(v, for: scope) }
			)
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope) }
			)
		case .contentEdgeInsets(let x): return x.apply(instance) { i, v in i.contentEdgeInsets = v }
		case .image(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setImage(v, for: scope) }
			)
		case .imageEdgeInsets(let x): return x.apply(instance) { i, v in i.imageEdgeInsets = v }
		case .showsTouchWhenHighlighted(let x): return x.apply(instance) { i, v in i.showsTouchWhenHighlighted = v }
		case .title(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitle(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitle(v, for: scope) }
			)
		case .titleColor(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleColor(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitleColor(v, for: scope) }
			)
		case .titleEdgeInsets(let x): return x.apply(instance) { i, v in i.titleEdgeInsets = v }
		case .titleShadowColor(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleShadowColor(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitleShadowColor(v, for: scope) }
			)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Button.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ButtonBinding {
	typealias ButtonName<V> = BindingName<V, Button.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Button.Binding) -> ButtonName<V> {
		return ButtonName<V>(source: source, downcast: Binding.buttonBinding)
	}
}
extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ButtonName<$2> { return .name(Button.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var imageView: ButtonName<Constant<ImageView>> { return .name(Button.Binding.imageView) }
	static var titleLabel: ButtonName<Constant<Label>> { return .name(Button.Binding.titleLabel) }
	static var type: ButtonName<Constant<UIButton.ButtonType>> { return .name(Button.Binding.type) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsImageWhenDisabled: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.adjustsImageWhenDisabled) }
	static var adjustsImageWhenHighlighted: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.adjustsImageWhenHighlighted) }
	static var attributedTitle: ButtonName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>> { return .name(Button.Binding.attributedTitle) }
	static var backgroundImage: ButtonName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Button.Binding.backgroundImage) }
	static var contentEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.contentEdgeInsets) }
	static var image: ButtonName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Button.Binding.image) }
	static var imageEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.imageEdgeInsets) }
	static var showsTouchWhenHighlighted: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.showsTouchWhenHighlighted) }
	static var title: ButtonName<Dynamic<ScopedValues<UIControl.State, String?>>> { return .name(Button.Binding.title) }
	static var titleColor: ButtonName<Dynamic<ScopedValues<UIControl.State, UIColor?>>> { return .name(Button.Binding.titleColor) }
	static var titleEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.titleEdgeInsets) }
	static var titleShadowColor: ButtonName<Dynamic<ScopedValues<UIControl.State, UIColor?>>> { return .name(Button.Binding.titleShadowColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ButtonConvertible: ControlConvertible {
	func uiButton() -> Button.Instance
}
extension ButtonConvertible {
	func uiControl() -> Control.Instance { return uiButton() }
}
extension UIButton: ButtonConvertible {
	func uiButton() -> Button.Instance { return self }
}
extension Button {
	func uiButton() -> Button.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
}
extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}
extension Button.Binding {
	typealias Preparer = Button.Preparer
	static func buttonBinding(_ binding: Button.Binding) -> Button.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Control: Binder, ControlConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Control {
	enum Binding: ControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case isSelected(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case contentVerticalAlignment(Dynamic<UIControl.ContentVerticalAlignment>)
		case contentHorizontalAlignment(Dynamic<UIControl.ContentHorizontalAlignment>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case actions(ControlActions)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Control {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Control.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UIControl
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Control.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .contentHorizontalAlignment(let x): return x.apply(instance) { i, v in i.contentHorizontalAlignment = v }
		case .contentVerticalAlignment(let x): return x.apply(instance) { i, v in i.contentVerticalAlignment = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .isSelected(let x): return x.apply(instance) { i, v in i.isSelected = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .actions(let x):
			var lifetimes = [Lifetime]()
			for (scope, value) in x.pairs {
				switch value {
				case .firstResponder(let s):
					instance.addTarget(nil, action: s, for: scope)
				case .singleTarget(let s):
					let target = SignalControlEventActionTarget()
					instance.addTarget(target, action: target.selector, for: scope)
					lifetimes += target.source.cancellableBind(to: s)
				}
			}
			return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Control.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ControlBinding {
	typealias ControlName<V> = BindingName<V, Control.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Control.Binding) -> ControlName<V> {
		return ControlName<V>(source: source, downcast: Binding.controlBinding)
	}
}
extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ControlName<$2> { return .name(Control.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isEnabled) }
	static var isSelected: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isSelected) }
	static var isHighlighted: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isHighlighted) }
	static var contentVerticalAlignment: ControlName<Dynamic<UIControl.ContentVerticalAlignment>> { return .name(Control.Binding.contentVerticalAlignment) }
	static var contentHorizontalAlignment: ControlName<Dynamic<UIControl.ContentHorizontalAlignment>> { return .name(Control.Binding.contentHorizontalAlignment) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var actions: ControlName<ControlActions> { return .name(Control.Binding.actions) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action<Value>(_ scope: UIControl.Event, _ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> ControlName<SignalInput<Value>> {
		return Binding.mappedWrappedInputName(
			map: { tuple in
				(tuple.0 as! Binding.Preparer.Instance)[keyPath: keyPath]
			},
			wrap: { input in ControlActions(scope: scope, value: ControlAction.singleTarget(input)) },
			binding: Control.Binding.actions,
			downcast: Binding.controlBinding
		)
	}
	static func action(_ scope: UIControl.Event) -> ControlName<SignalInput<Void>> {
		return Binding.mappedWrappedInputName(
			map: { tuple in () },
			wrap: { input in ControlActions(scope: scope, value: ControlAction.singleTarget(input)) },
			binding: Control.Binding.actions,
			downcast: Binding.controlBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ControlConvertible: ViewConvertible {
	func uiControl() -> Control.Instance
}
extension ControlConvertible {
	func uiView() -> View.Instance { return uiControl() }
}
extension UIControl: ControlConvertible {
	func uiControl() -> Control.Instance { return self }
}
extension Control {
	func uiControl() -> Control.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
}
extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return controlBinding(.inheritedBinding(binding))
	}
}
extension Control.Binding {
	typealias Preparer = Control.Preparer
	static func controlBinding(_ binding: Control.Binding) -> Control.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
enum ControlAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<(control: UIControl, event: UIEvent)>)
}

typealias ControlActions = ScopedValues<UIControl.Event, ControlAction>

extension ScopedValues where Scope == UIControl.State {
	static func normal(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .normal)
	}
	static func highlighted(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .highlighted)
	}
	static func disabled(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .disabled)
	}
	static func selected(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .selected)
	}
	static func focused(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .focused)
	}
	static func application(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .application)
	}
	static func reserved(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .reserved)
	}
}

class SignalControlEventActionTarget: NSObject {
	private var signalInput: SignalInput<(control: UIControl, event: UIEvent)>? = nil
	
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var signalOutput: SignalMulti<(control: UIControl, event: UIEvent)>? = nil
	
	/// The `signal` emits the actions received
	var source: SignalMulti<(control: UIControl, event: UIEvent)> {
		// If there's a current signal output, return it
		if let so = signalOutput {
			return so
		}
		
		let s = Signal<(control: UIControl, event: UIEvent)>.generate { i in self.signalInput = i }.continuous()
		self.signalOutput = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSendAction(_ sender: UIControl, forEvent event: UIEvent) {
		_ = signalInput?.send(value: (sender, event))
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.action(_:))`
	var selector: Selector { return #selector(SignalControlEventActionTarget.cwlSendAction(_:forEvent:)) }
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class ExtendedViewController<Subclass: UIViewController & ViewControllerWithDelegate & HasDelegate>: Binder, ViewControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Subclass.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

extension ExtendedViewController where Subclass == CwlExtendedViewController {
	convenience init(bindings: [Preparer.Binding]) {
		self.init(type: CwlExtendedViewController.self, parameters: (), bindings: bindings)
	}
	
	convenience init(_ bindings: Preparer.Binding...) {
		self.init(type: CwlExtendedViewController.self, parameters: (), bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ExtendedViewController {
	enum Binding: ExtendedViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didAppear((UIViewController, Bool) -> Void)
		case didDisappear((UIViewController, Bool) -> Void)
		case didReceiveMemoryWarning((UIViewController) -> Void)
		case loadView(() -> ViewConvertible)
		case traitCollectionDidChange((UIViewController, UITraitCollection?) -> Void)
		case willAppear((UIViewController, Bool) -> Void)
		case willDisappear((UIViewController, Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension ExtendedViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = ExtendedViewController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = Subclass
		typealias Parameters = () /* change if non-default construction required */
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var loadView: (() -> ViewConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ExtendedViewController.Preparer {
	var delegateIsRequired: Bool { return dynamicDelegate != nil || loadView != nil }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.view(let x)):
			precondition(loadView == nil, "Construct the view using either .loadView or .view, not both.")
			inherited.prepareBinding(.view(x))
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didAppear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewDidAppear(controller:animated:)))
		case .didDisappear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewDidDisappear(controller:animated:)))
		case .traitCollectionDidChange(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.traitCollectionDidChange(controller:previousTraitCollection:)))
		case .willAppear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewWillAppear(controller:animated:)))
		case .willDisappear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewWillDisappear(controller:animated:)))
		case .didReceiveMemoryWarning(let x): delegate().addMultiHandler1(x, #selector(ViewControllerDelegate.didReceiveMemoryWarning(controller:)))
		case .loadView(let x):
			precondition(inherited.view == nil, "Construct the view using either .loadView or .view, not both.")
			loadView = x
		}
	}
	
	func prepareInstance(_ instance: Subclass, storage: ExtendedViewController<Subclass>.Preparer.Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if let lv = loadView {
			storage.viewConstructor = lv
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .didAppear: return nil
		case .didDisappear: return nil
		case .traitCollectionDidChange: return nil
		case .willAppear: return nil
		case .willDisappear: return nil
			
		case .didReceiveMemoryWarning: return nil
		case .loadView: return nil
		}
	}
	
	func finalizeInstance(_ instance: Subclass, storage: ExtendedViewController<Subclass>.Preparer.Storage) -> Lifetime? {
		// Send the initial "traitsCollection" once construction is complete.
		if let dd = dynamicDelegate, dd.handlesSelector(#selector(ViewControllerDelegate.traitCollectionDidChange(controller:previousTraitCollection:))) {
			dd.traitCollectionDidChange(controller: instance, previousTraitCollection: nil)
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ExtendedViewController.Preparer {
	class Storage: ViewController.Preparer.Storage, ViewControllerDelegate {
		var viewConstructor: (() -> ViewConvertible?)?
		
		func loadView(controller: UIViewController) -> UIView? {
			if let wrapper = viewConstructor?() {
				return wrapper.uiView()
			}
			return nil
		}
		
		func didReceiveMemoryWarning(controller: UIViewController) {
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(ViewControllerDelegate.didReceiveMemoryWarning(controller:))) {
				(dd as? ViewControllerDelegate)?.didReceiveMemoryWarning?(controller: controller)
			}
			
			if viewConstructor != nil, let view = controller.viewIfLoaded, view.window == nil {
				controller.view = nil
			}
		}
	}

	class Delegate: DynamicDelegate, ViewControllerDelegate {
		func loadView(controller: UIViewController) -> UIView? {
			return nil
		}
		
		func didReceiveMemoryWarning(controller: UIViewController) {
			multiHandler(controller)
		}
		
		func traitCollectionDidChange(controller: UIViewController, previousTraitCollection: UITraitCollection?) {
			multiHandler(controller, previousTraitCollection)
		}
		
		func viewWillAppear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		func viewDidAppear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		func viewWillDisappear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		func viewDidDisappear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ExtendedViewControllerBinding {
	typealias ExtendedViewControllerName<V> = BindingName<V, ExtendedViewController<Binding.SubclassType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ExtendedViewController<Binding.SubclassType>.Binding) -> ExtendedViewControllerName<V> {
		return ExtendedViewControllerName<V>(source: source, downcast: Binding.extendedViewControllerBinding)
	}
}
extension BindingName where Binding: ExtendedViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ExtendedViewControllerName<$2> { return .name(ExtendedViewController.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didAppear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.didAppear) }
	static var didDisappear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.didDisappear) }
	static var didReceiveMemoryWarning: ExtendedViewControllerName<(UIViewController) -> Void> { return .name(ExtendedViewController.Binding.didReceiveMemoryWarning) }
	static var loadView: ExtendedViewControllerName<() -> ViewConvertible> { return .name(ExtendedViewController.Binding.loadView) }
	static var traitCollectionDidChange: ExtendedViewControllerName<(UIViewController, UITraitCollection?) -> Void> { return .name(ExtendedViewController.Binding.traitCollectionDidChange) }
	static var willAppear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.willAppear) }
	static var willDisappear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.willDisappear) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension ExtendedViewController {
	func uiViewController() -> ViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ExtendedViewControllerBinding: ViewControllerBinding {
	associatedtype SubclassType: UIViewController & ViewControllerWithDelegate & HasDelegate
	static func extendedViewControllerBinding(_ binding: ExtendedViewController<SubclassType>.Binding) -> Self

}
extension ExtendedViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return extendedViewControllerBinding(.inheritedBinding(binding))
	}
}
extension ExtendedViewController.Binding {
	typealias Preparer = ExtendedViewController.Preparer
	static func extendedViewControllerBinding(_ binding: ExtendedViewController.Binding) -> ExtendedViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
@objc protocol ViewControllerDelegate: class {
	@objc optional func loadView(controller: UIViewController) -> UIView?
	@objc optional func didReceiveMemoryWarning(controller: UIViewController)
	@objc optional func traitCollectionDidChange(controller: UIViewController, previousTraitCollection: UITraitCollection?)
	@objc optional func viewWillAppear(controller: UIViewController, animated: Bool)
	@objc optional func viewDidAppear(controller: UIViewController, animated: Bool)
	@objc optional func viewWillDisappear(controller: UIViewController, animated: Bool)
	@objc optional func viewDidDisappear(controller: UIViewController, animated: Bool)
}

protocol ViewControllerWithDelegate {
	var delegate: ViewControllerDelegate? { get set }
}

/// Implementation of ViewControllerWithDelegate on top of the base UIViewController.
/// You can use this view controller directly, subclass it or implement `ViewControllerWithDelegate` and `HasDelegate` on top of another `UIViewController` to use that view controller with the `ExtendedViewController` binder.
class CwlExtendedViewController: UIViewController, ViewControllerWithDelegate, HasDelegate {
	unowned var delegate: ViewControllerDelegate?
	
	override func loadView() {
		if let loaded = delegate?.loadView?(controller: self) {
			view = loaded
		} else {
			super.loadView()
		}
	}
	
	override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
		delegate?.traitCollectionDidChange?(controller: self, previousTraitCollection: previousTraitCollection)
		super.traitCollectionDidChange(previousTraitCollection)
	}
	
	override func viewWillAppear(_ animated: Bool) {
		delegate?.viewWillAppear?(controller: self, animated: animated)
		super.viewWillAppear(animated)
	}
	
	override func viewDidAppear(_ animated: Bool) {
		delegate?.viewDidAppear?(controller: self, animated: animated)
		super.viewDidAppear(animated)
	}
	
	override func viewWillDisappear(_ animated: Bool) {
		delegate?.viewWillDisappear?(controller: self, animated: animated)
		super.viewWillDisappear(animated)
	}
	
	override func viewDidDisappear(_ animated: Bool) {
		delegate?.viewDidDisappear?(controller: self, animated: animated)
		super.viewDidDisappear(animated)
	}
	
	override func didReceiveMemoryWarning() {
		delegate?.didReceiveMemoryWarning?(controller: self)
		super.didReceiveMemoryWarning()
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class GestureRecognizer: Binder, GestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension GestureRecognizer {
	enum Binding: GestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowedPressTypes(Dynamic<[NSNumber]>)
		case allowedTouchTypes(Dynamic<[NSNumber]>)
		case cancelsTouchesInView(Dynamic<Bool>)
		case delaysTouchesBegan(Dynamic<Bool>)
		case delaysTouchesEnded(Dynamic<Bool>)
		case requiresExclusiveTouchType(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(SignalInput<Any?>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBegin((UIGestureRecognizer) -> Bool)
		case shouldBeRequiredToFail((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)
		case shouldReceivePress((UIGestureRecognizer, UIPress) -> Bool)
		case shouldReceiveTouch((UIGestureRecognizer, UITouch) -> Bool)
		case shouldRecognizeSimultanously((UIGestureRecognizer, UIGestureRecognizer) -> Bool)
		case shouldRequireFailure((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension GestureRecognizer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = GestureRecognizer.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIGestureRecognizer
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension GestureRecognizer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .shouldBegin(let x): delegate().addSingleHandler1(x, #selector(UIGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:)))
		case .shouldBeRequiredToFail(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:)))
		case .shouldReceivePress(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UIPress) -> Bool)?))
		case .shouldReceiveTouch(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UITouch) -> Bool)?))
		case .shouldRecognizeSimultanously(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)))
		case .shouldRequireFailure(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowedPressTypes(let x): return x.apply(instance) { i, v in i.allowedPressTypes = v }
		case .allowedTouchTypes(let x): return x.apply(instance) { i, v in i.allowedTouchTypes = v }
		case .cancelsTouchesInView(let x): return x.apply(instance) { i, v in i.cancelsTouchesInView = v }
		case .delaysTouchesBegan(let x): return x.apply(instance) { i, v in i.delaysTouchesBegan = v }
		case .delaysTouchesEnded(let x): return x.apply(instance) { i, v in i.delaysTouchesEnded = v }
		
		case .requiresExclusiveTouchType(let x): return x.apply(instance) { i, v in i.requiresExclusiveTouchType = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case .action(let x):
			let target = SignalActionTarget()
			instance.addTarget(target, action: SignalActionTarget.selector)
			return target.signal.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBegin: return nil
		case .shouldReceiveTouch: return nil
		case .shouldRecognizeSimultanously: return nil
		case .shouldRequireFailure: return nil
		case .shouldBeRequiredToFail: return nil
		case .shouldReceivePress: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GestureRecognizer.Preparer {
	class Storage: AssociatedBinderStorage, UIGestureRecognizerDelegate {}

	class Delegate: DynamicDelegate, UIGestureRecognizerDelegate {
		func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
			return singleHandler(gestureRecognizer, touch)
		}
		
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool {
			return singleHandler(gestureRecognizer, press)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GestureRecognizerBinding {
	typealias GestureRecognizerName<V> = BindingName<V, GestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> GestureRecognizer.Binding) -> GestureRecognizerName<V> {
		return GestureRecognizerName<V>(source: source, downcast: Binding.gestureRecognizerBinding)
	}
}
extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GestureRecognizerName<$2> { return .name(GestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedPressTypes: GestureRecognizerName<Dynamic<[NSNumber]>> { return .name(GestureRecognizer.Binding.allowedPressTypes) }
	static var allowedTouchTypes: GestureRecognizerName<Dynamic<[NSNumber]>> { return .name(GestureRecognizer.Binding.allowedTouchTypes) }
	static var cancelsTouchesInView: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.cancelsTouchesInView) }
	static var delaysTouchesBegan: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.delaysTouchesBegan) }
	static var delaysTouchesEnded: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.delaysTouchesEnded) }
	static var requiresExclusiveTouchType: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.requiresExclusiveTouchType) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: GestureRecognizerName<SignalInput<Any?>> { return .name(GestureRecognizer.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBegin: GestureRecognizerName<(UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldBegin) }
	static var shouldBeRequiredToFail: GestureRecognizerName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldBeRequiredToFail) }
	static var shouldReceivePress: GestureRecognizerName<(UIGestureRecognizer, UIPress) -> Bool> { return .name(GestureRecognizer.Binding.shouldReceivePress) }
	static var shouldReceiveTouch: GestureRecognizerName<(UIGestureRecognizer, UITouch) -> Bool> { return .name(GestureRecognizer.Binding.shouldReceiveTouch) }
	static var shouldRecognizeSimultanously: GestureRecognizerName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRecognizeSimultanously) }
	static var shouldRequireFailure: GestureRecognizerName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRequireFailure) }

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> GestureRecognizerName<SignalInput<Value>> {
		return Binding.mappedInputName(
			map: { sender in (sender as! Binding.Preparer.Instance)[keyPath: keyPath] },
			binding: GestureRecognizer.Binding.action,
			downcast: Binding.gestureRecognizerBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol GestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance
}
extension UIGestureRecognizer: GestureRecognizerConvertible, DefaultConstructable, HasDelegate {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return self }
}
extension GestureRecognizer {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol GestureRecognizerBinding: BinderBaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
}
extension GestureRecognizerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension GestureRecognizer.Binding {
	typealias Preparer = GestureRecognizer.Preparer
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> GestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class ImageView: Binder, ImageViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ImageView {
	enum Binding: ImageViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case highlightedImage(Dynamic<UIImage?>)
		case animationImages(Dynamic<[UIImage]?>)
		case highlightedAnimationImages(Dynamic<[UIImage]?>)
		case animationDuration(Dynamic<TimeInterval>)
		case animationRepeatCount(Dynamic<Int>)
		case isHighlighted(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case animating(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ImageView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ImageView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UIImageView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var image = InitialSubsequent<UIImage?>()
		var highlightedImage = InitialSubsequent<UIImage?>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ImageView.Preparer {
	func constructInstance(type: UIImageView.Type, parameters: Void) -> UIImageView {
		return type.init(image: image.initial ?? nil, highlightedImage: highlightedImage.initial ?? nil)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .image(let x): image = x.initialSubsequent()
		case .highlightedImage(let x): highlightedImage = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .animationDuration(let x): return x.apply(instance) { i, v in i.animationDuration = v }
		case .animationImages(let x): return x.apply(instance) { i, v in i.animationImages = v }
		case .animationRepeatCount(let x): return x.apply(instance) { i, v in i.animationRepeatCount = v }
		case .highlightedAnimationImages(let x): return x.apply(instance) { i, v in i.highlightedAnimationImages = v }
		case .highlightedImage: return highlightedImage.apply(instance) { i, v in i.highlightedImage = v }
		case .image: return image.apply(instance) { i, v in i.image = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .animating(let x):
			return x.apply(instance) { i, v in
				if v && !i.isAnimating {
					i.startAnimating()
				} else if !v && i.isAnimating {
					i.stopAnimating()
				}
			}
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ImageView.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ImageViewBinding {
	typealias ImageViewName<V> = BindingName<V, ImageView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ImageView.Binding) -> ImageViewName<V> {
		return ImageViewName<V>(source: source, downcast: Binding.imageViewBinding)
	}
}
extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ImageViewName<$2> { return .name(ImageView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: ImageViewName<Dynamic<UIImage?>> { return .name(ImageView.Binding.image) }
	static var highlightedImage: ImageViewName<Dynamic<UIImage?>> { return .name(ImageView.Binding.highlightedImage) }
	static var animationImages: ImageViewName<Dynamic<[UIImage]?>> { return .name(ImageView.Binding.animationImages) }
	static var highlightedAnimationImages: ImageViewName<Dynamic<[UIImage]?>> { return .name(ImageView.Binding.highlightedAnimationImages) }
	static var animationDuration: ImageViewName<Dynamic<TimeInterval>> { return .name(ImageView.Binding.animationDuration) }
	static var animationRepeatCount: ImageViewName<Dynamic<Int>> { return .name(ImageView.Binding.animationRepeatCount) }
	static var isHighlighted: ImageViewName<Dynamic<Bool>> { return .name(ImageView.Binding.isHighlighted) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var animating: ImageViewName<Signal<Bool>> { return .name(ImageView.Binding.animating) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ImageViewConvertible: ViewConvertible {
	func uiImageView() -> ImageView.Instance
}
extension ImageViewConvertible {
	func uiView() -> View.Instance { return uiImageView() }
}
extension UIImageView: ImageViewConvertible {
	func uiImageView() -> ImageView.Instance { return self }
}
extension ImageView {
	func uiImageView() -> ImageView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ImageViewBinding: ViewBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
}
extension ImageViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}
extension ImageView.Binding {
	typealias Preparer = ImageView.Preparer
	static func imageViewBinding(_ binding: ImageView.Binding) -> ImageView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Label: Binder, LabelConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Label {
	enum Binding: LabelBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsDefaultTighteningForTruncation(Dynamic<Bool>)
		case attributedText(Dynamic<NSAttributedString?>)
		case baselineAdjustment(Dynamic<UIBaselineAdjustment>)
		case font(Dynamic<UIFont>)
		case highlightedTextColor(Dynamic<UIColor?>)
		case isEnabled(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case lineBreakMode(Dynamic<NSLineBreakMode>)
		case minimumScaleFactor(Dynamic<CGFloat>)
		case numberOfLines(Dynamic<Int>)
		case preferredMaxLayoutWidth(Dynamic<CGFloat>)
		case shadowColor(Dynamic<UIColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Label {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Label.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UILabel
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Label.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsFontSizeToFitWidth(let x): return x.apply(instance) { i, v in i.adjustsFontSizeToFitWidth = v }
		case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance) { i, v in i.allowsDefaultTighteningForTruncation = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .baselineAdjustment(let x): return x.apply(instance) { i, v in i.baselineAdjustment = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .highlightedTextColor(let x): return x.apply(instance) { i, v in i.highlightedTextColor = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .lineBreakMode(let x): return x.apply(instance) { i, v in i.lineBreakMode = v }
		case .minimumScaleFactor(let x): return x.apply(instance) { i, v in i.minimumScaleFactor = v }
		case .numberOfLines(let x): return x.apply(instance) { i, v in i.numberOfLines = v }
		case .preferredMaxLayoutWidth(let x): return x.apply(instance) { i, v in i.preferredMaxLayoutWidth = v }
		case .shadowColor(let x): return x.apply(instance) { i, v in i.shadowColor = v }
		case .shadowOffset(let x): return x.apply(instance) { i, v in i.shadowOffset = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Label.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LabelBinding {
	typealias LabelName<V> = BindingName<V, Label.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Label.Binding) -> LabelName<V> {
		return LabelName<V>(source: source, downcast: Binding.windowBinding)
	}
}
extension BindingName where Binding: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LabelName<$2> { return .name(Label.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: LabelName<Dynamic<Bool>> { return .name(Label.Binding.adjustsFontSizeToFitWidth) }
	static var allowsDefaultTighteningForTruncation: LabelName<Dynamic<Bool>> { return .name(Label.Binding.allowsDefaultTighteningForTruncation) }
	static var attributedText: LabelName<Dynamic<NSAttributedString?>> { return .name(Label.Binding.attributedText) }
	static var baselineAdjustment: LabelName<Dynamic<UIBaselineAdjustment>> { return .name(Label.Binding.baselineAdjustment) }
	static var font: LabelName<Dynamic<UIFont>> { return .name(Label.Binding.font) }
	static var highlightedTextColor: LabelName<Dynamic<UIColor?>> { return .name(Label.Binding.highlightedTextColor) }
	static var isEnabled: LabelName<Dynamic<Bool>> { return .name(Label.Binding.isEnabled) }
	static var isHighlighted: LabelName<Dynamic<Bool>> { return .name(Label.Binding.isHighlighted) }
	static var lineBreakMode: LabelName<Dynamic<NSLineBreakMode>> { return .name(Label.Binding.lineBreakMode) }
	static var minimumScaleFactor: LabelName<Dynamic<CGFloat>> { return .name(Label.Binding.minimumScaleFactor) }
	static var numberOfLines: LabelName<Dynamic<Int>> { return .name(Label.Binding.numberOfLines) }
	static var preferredMaxLayoutWidth: LabelName<Dynamic<CGFloat>> { return .name(Label.Binding.preferredMaxLayoutWidth) }
	static var shadowColor: LabelName<Dynamic<UIColor?>> { return .name(Label.Binding.shadowColor) }
	static var shadowOffset: LabelName<Dynamic<CGSize>> { return .name(Label.Binding.shadowOffset) }
	static var text: LabelName<Dynamic<String>> { return .name(Label.Binding.text) }
	static var textAlignment: LabelName<Dynamic<NSTextAlignment>> { return .name(Label.Binding.textAlignment) }
	static var textColor: LabelName<Dynamic<UIColor>> { return .name(Label.Binding.textColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol LabelConvertible: ViewConvertible {
	func uiLabel() -> Label.Instance
}
extension LabelConvertible {
	func uiView() -> View.Instance { return uiLabel() }
}
extension UILabel: LabelConvertible {
	func uiLabel() -> Label.Instance { return self }
}
extension Label {
	func uiLabel() -> Label.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol LabelBinding: ViewBinding {
	static func windowBinding(_ binding: Label.Binding) -> Self
}
extension LabelBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
extension Label.Binding {
	typealias Preparer = Label.Preparer
	static func windowBinding(_ binding: Label.Binding) -> Label.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class LongPressGestureRecognizer: Binder, LongPressGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension LongPressGestureRecognizer {
	enum Binding: LongPressGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowableMovement(Dynamic<CGFloat>)
		case minimumPressDuration(Dynamic<CFTimeInterval>)
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension LongPressGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = LongPressGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UILongPressGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension LongPressGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowableMovement(let x): return x.apply(instance) { i, v in i.allowableMovement = v }
		case .minimumPressDuration(let x): return x.apply(instance) { i, v in i.minimumPressDuration = v }
		case .numberOfTapsRequired(let x): return x.apply(instance) { i, v in i.numberOfTapsRequired = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension LongPressGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LongPressGestureRecognizerBinding {
	typealias LongPressGestureRecognizerName<V> = BindingName<V, LongPressGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> LongPressGestureRecognizer.Binding) -> LongPressGestureRecognizerName<V> {
		return LongPressGestureRecognizerName<V>(source: source, downcast: Binding.longPressGestureRecognizerBinding)
	}
}
extension BindingName where Binding: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LongPressGestureRecognizerName<$2> { return .name(LongPressGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: LongPressGestureRecognizerName<Dynamic<CGFloat>> { return .name(LongPressGestureRecognizer.Binding.allowableMovement) }
	static var minimumPressDuration: LongPressGestureRecognizerName<Dynamic<CFTimeInterval>> { return .name(LongPressGestureRecognizer.Binding.minimumPressDuration) }
	static var numberOfTapsRequired: LongPressGestureRecognizerName<Dynamic<Int>> { return .name(LongPressGestureRecognizer.Binding.numberOfTapsRequired) }
	static var numberOfTouchesRequired: LongPressGestureRecognizerName<Dynamic<Int>> { return .name(LongPressGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol LongPressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance
}
extension LongPressGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiLongPressGestureRecognizer() }
}
extension UILongPressGestureRecognizer: LongPressGestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return self }
}
extension LongPressGestureRecognizer {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol LongPressGestureRecognizerBinding: GestureRecognizerBinding {
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> Self
}
extension LongPressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return longPressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension LongPressGestureRecognizer.Binding {
	typealias Preparer = LongPressGestureRecognizer.Preparer
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> LongPressGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class NavigationBar: Binder, NavigationBarConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension NavigationBar {
	enum Binding: NavigationBarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case backIndicatorImage(Dynamic<UIImage?>)
		case backIndicatorTransitionMaskImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case items(Dynamic<StackMutation<NavigationItemConvertible>>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor?>)
		case titleTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case titleVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didPop((UINavigationBar, UINavigationItem) -> Void)
		case didPush((UINavigationBar, UINavigationItem) -> Void)
		case position((UIBarPositioning) -> UIBarPosition)
		case shouldPop((UINavigationBar, UINavigationItem) -> Bool)
		case shouldPush((UINavigationBar, UINavigationItem) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension NavigationBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = NavigationBar.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UINavigationBar
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension NavigationBar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding { 
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didPop(let x): delegate().addMultiHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:didPop:)))
		case .didPush(let x): delegate().addMultiHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:didPush:)))
		case .position(let x): delegate().addSingleHandler1(x, #selector(UINavigationBarDelegate.position(for:)))
		case .shouldPop(let x): delegate().addSingleHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:shouldPop:)))
		case .shouldPush(let x): delegate().addSingleHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:shouldPush:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .backIndicatorImage(let x): return x.apply(instance) { i, v in i.backIndicatorImage = v }
		case .backIndicatorTransitionMaskImage(let x): return x.apply(instance) { i, v in i.backIndicatorTransitionMaskImage = v }
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				switch v {
				case .push(let e):
					i.pushItem(e.uiNavigationItem(), animated: true)
				case .pop:
					i.popItem(animated: true)
				case .popToCount(let c):
					i.setItems(i.items?.dropLast((i.items?.count ?? 0) - c) ?? [], animated: true)
				case .reload(let newStack):
					i.setItems(newStack.map { $0.uiNavigationItem() }, animated: false)
				}
			}
		case .shadowImage(let x): return x.apply(instance) { i, v in i.shadowImage = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .titleTextAttributes(let x): return x.apply(instance) { i, v in i.titleTextAttributes = v }
		case .titleVerticalPositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleVerticalPositionAdjustment(0, for: scope) },
				applyNew: { i, scope, v in i.setTitleVerticalPositionAdjustment(v, for: scope) }
			)
			
		// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .didPush: return nil
		case .didPop: return nil
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		case .shouldPop: return nil
		case .shouldPush: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationBar.Preparer {
	class Storage: View.Preparer.Storage, UINavigationBarDelegate {}

	class Delegate: DynamicDelegate, UINavigationBarDelegate {
		func navigationBar(_ navigationBar: UINavigationBar, shouldPop item: UINavigationItem) -> Bool {
			return singleHandler(navigationBar, item)
		}
		
		func navigationBar(_ navigationBar: UINavigationBar, shouldPush item: UINavigationItem) -> Bool {
			return singleHandler(navigationBar, item)
		}
		
		func navigationBar(_ navigationBar: UINavigationBar, didPop item: UINavigationItem) {
			multiHandler(navigationBar, item)
		}
		
		func navigationBar(_ navigationBar: UINavigationBar, didPush item: UINavigationItem) {
			multiHandler(navigationBar, item)
		}
		
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationBarBinding {
	typealias NavigationBarName<V> = BindingName<V, NavigationBar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationBar.Binding) -> NavigationBarName<V> {
		return NavigationBarName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
extension BindingName where Binding: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationBarName<$2> { return .name(NavigationBar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: NavigationBarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(NavigationBar.Binding.backgroundImage) }
	static var backIndicatorImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.backIndicatorImage) }
	static var backIndicatorTransitionMaskImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.backIndicatorTransitionMaskImage) }
	static var barStyle: NavigationBarName<Dynamic<UIBarStyle>> { return .name(NavigationBar.Binding.barStyle) }
	static var barTintColor: NavigationBarName<Dynamic<UIColor?>> { return .name(NavigationBar.Binding.barTintColor) }
	static var isTranslucent: NavigationBarName<Dynamic<Bool>> { return .name(NavigationBar.Binding.isTranslucent) }
	static var items: NavigationBarName<Dynamic<StackMutation<NavigationItemConvertible>>> { return .name(NavigationBar.Binding.items) }
	static var shadowImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.shadowImage) }
	static var tintColor: NavigationBarName<Dynamic<UIColor?>> { return .name(NavigationBar.Binding.tintColor) }
	static var titleTextAttributes: NavigationBarName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(NavigationBar.Binding.titleTextAttributes) }
	static var titleVerticalPositionAdjustment: NavigationBarName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> { return .name(NavigationBar.Binding.titleVerticalPositionAdjustment) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didPop: NavigationBarName<(UINavigationBar, UINavigationItem) -> Void> { return .name(NavigationBar.Binding.didPop) }
	static var didPush: NavigationBarName<(UINavigationBar, UINavigationItem) -> Void> { return .name(NavigationBar.Binding.didPush) }
	static var position: NavigationBarName<(UIBarPositioning) -> UIBarPosition> { return .name(NavigationBar.Binding.position) }
	static var shouldPop: NavigationBarName<(UINavigationBar, UINavigationItem) -> Bool> { return .name(NavigationBar.Binding.shouldPop) }
	static var shouldPush: NavigationBarName<(UINavigationBar, UINavigationItem) -> Bool> { return .name(NavigationBar.Binding.shouldPush) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol NavigationBarConvertible: ViewConvertible {
	func uiNavigationBar() -> NavigationBar.Instance
}
extension NavigationBarConvertible {
	func uiView() -> View.Instance { return uiNavigationBar() }
}
extension UINavigationBar: NavigationBarConvertible, HasDelegate {
	func uiNavigationBar() -> NavigationBar.Instance { return self }
}
extension NavigationBar {
	func uiNavigationBar() -> NavigationBar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol NavigationBarBinding: ViewBinding {
	static func scrollViewBinding(_ binding: NavigationBar.Binding) -> Self
}
extension NavigationBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
extension NavigationBar.Binding {
	typealias Preparer = NavigationBar.Preparer
	static func scrollViewBinding(_ binding: NavigationBar.Binding) -> NavigationBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct PositionAndMetrics {
	let barPosition: UIBarPosition
	let barMetrics: UIBarMetrics
	init(position: UIBarPosition = .any, metrics: UIBarMetrics = .default) {
		self.barPosition = position
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == PositionAndMetrics {
	static func any(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .any, metrics: metrics))
	}
	static func bottom(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .bottom, metrics: metrics))
	}
	static func top(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .top, metrics: metrics))
	}
	static func topAttached(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .topAttached, metrics: metrics))
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class NavigationController: Binder, NavigationControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension NavigationController {
	enum Binding: NavigationControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationBar(Constant<NavigationBar>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case hidesBarsOnSwipe(Dynamic<Bool>)
		case hidesBarsOnTap(Dynamic<Bool>)
		case hidesBarsWhenKeyboardAppears(Dynamic<Bool>)
		case hidesBarsWhenVerticallyCompact(Dynamic<Bool>)
		case isNavigationBarHidden(Dynamic<SetOrAnimate<Bool>>)
		case isToolbarHidden(Dynamic<SetOrAnimate<Bool>>)
		case stack(Dynamic<StackMutation<ViewControllerConvertible>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case poppedToCount(SignalInput<Int>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationController((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)
		case interactionController((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case preferredInterfaceOrientation((_ navigationController: UINavigationController) -> UIInterfaceOrientation)
		case supportedInterfaceOrientations((_ navigationController: UINavigationController) -> UIInterfaceOrientationMask)
		case didShow((_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void)
		case willShow((_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension NavigationController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = NavigationController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = UINavigationController
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage(popSignal: popSignal) }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var popSignal: MultiOutput<Int>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension NavigationController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance { return type.init(nibName: nil, bundle: nil) }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .animationController(let x): delegate().addSingleHandler4(x, #selector(UINavigationControllerDelegate.navigationController(_:animationControllerFor:from:to:)))
		case .interactionController(let x): delegate().addSingleHandler2(x, #selector(UINavigationControllerDelegate.navigationController(_:interactionControllerFor:)))
		case .didShow(let x): delegate().addMultiHandler3(x, #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:)))
		case .poppedToCount(let x):
			popSignal = popSignal ?? Input().multicast()
			popSignal?.signal.bind(to: x)
		case .preferredInterfaceOrientation(let x): delegate().addSingleHandler1(x, #selector(UINavigationControllerDelegate.navigationControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UINavigationControllerDelegate.navigationControllerSupportedInterfaceOrientations(_:)))
		case .willShow(let x): delegate().addMultiHandler3(x, #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationBar(let x):
			x.value.apply(to: instance.navigationBar)
			return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .hidesBarsOnSwipe(let x): return x.apply(instance) { i, v in i.hidesBarsOnSwipe = v }
		case .hidesBarsOnTap(let x): return x.apply(instance) { i, v in i.hidesBarsOnTap = v }
		case .hidesBarsWhenKeyboardAppears(let x): return x.apply(instance) { i, v in i.hidesBarsWhenKeyboardAppears = v }
		case .hidesBarsWhenVerticallyCompact(let x): return x.apply(instance) { i, v in i.hidesBarsWhenVerticallyCompact = v }
		case .isNavigationBarHidden(let x): return x.apply(instance) { i, v in i.setNavigationBarHidden(v.value, animated: v.isAnimated) }
		case .isToolbarHidden(let x): return x.apply(instance) { i, v in i.setToolbarHidden(v.value, animated: v.isAnimated) }
		case .preferredInterfaceOrientation: return nil
		case .stack(let x):
			return x.apply(instance, storage) { i, s, v in
				switch v {
				case .push(let e):
					s.expectedStackCount += 1
					i.pushViewController(e.uiViewController(), animated: true)
				case .pop:
					s.expectedStackCount -= 1
					i.popViewController(animated: true)
				case .popToCount(let c):
					s.expectedStackCount = c
					i.popToViewController(i.viewControllers[c - 1], animated: true)
				case .reload(let newStack):
					s.expectedStackCount = newStack.count
					i.setViewControllers(newStack.map { $0.uiViewController() }, animated: false)
				}
			}
		case .supportedInterfaceOrientations: return nil
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .didShow: return nil
		case .poppedToCount: return nil
		case .willShow: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .animationController: return nil
		case .interactionController: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationController.Preparer {
	class Storage: ViewController.Preparer.Storage, UINavigationControllerDelegate {
		var supportedInterfaceOrientations: UIInterfaceOrientationMask = .all
		var preferredInterfaceOrientation: UIInterfaceOrientation = .portrait
		var expectedStackCount: Int = 0
		let popSignal: MultiOutput<Int>?
		weak var collapsedController: UINavigationController?
		
		override var isInUse: Bool {
			return true
		}
		
		init(popSignal: MultiOutput<Int>?) {
			self.popSignal = popSignal
			super.init()
		}
		
		func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
			// Handle pop operations triggered by the back button
			if animated, navigationController.viewControllers.count < expectedStackCount, let ps = popSignal {
				ps.input.send(value: navigationController.viewControllers.count)
			}
			
			// Handle removal of collapsed split view details
			if animated, navigationController.viewControllers.count == expectedStackCount, let collapsed = collapsedController, let splitView = navigationController.splitViewController, let splitViewStorage = splitView.associatedBinderStorage(subclass: SplitViewController.Preparer.Storage.self) {
				collapsedController = nil
				splitViewStorage.collapsedController(collapsed)
			}
			
			// Track when a collapsed split view is added
			if navigationController.viewControllers.count == expectedStackCount + 1, let collapsed = navigationController.viewControllers.last as? UINavigationController {
				collapsedController = collapsed
			}
			
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UINavigationControllerDelegate.navigationController(_:didShow:animated:))), let d = dd as? UINavigationControllerDelegate {
				d.navigationController?(navigationController, didShow: viewController, animated: animated)
			}
		}
	}

	class Delegate: DynamicDelegate, UINavigationControllerDelegate {
		func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
			return singleHandler(navigationController, viewController, animated)
		}
		
		func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
			return singleHandler(navigationController)
		}
		
		func navigationControllerPreferredInterfaceOrientationForPresentation(_ navigationController: UINavigationController) -> UIInterfaceOrientation {
			return singleHandler(navigationController)
		}
		
		func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			return singleHandler(navigationController, operation, fromVC, toVC)
		}
		
		func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?
		{
			return singleHandler(navigationController, animationController)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationControllerBinding {
	typealias NavigationControllerName<V> = BindingName<V, NavigationController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationController.Binding) -> NavigationControllerName<V> {
		return NavigationControllerName<V>(source: source, downcast: Binding.navigationControllerBinding)
	}
}
extension BindingName where Binding: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationControllerName<$2> { return .name(NavigationController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationBar: NavigationControllerName<Constant<NavigationBar>> { return .name(NavigationController.Binding.navigationBar) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var hidesBarsOnSwipe: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsOnSwipe) }
	static var hidesBarsOnTap: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsOnTap) }
	static var hidesBarsWhenKeyboardAppears: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsWhenKeyboardAppears) }
	static var hidesBarsWhenVerticallyCompact: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsWhenVerticallyCompact) }
	static var isNavigationBarHidden: NavigationControllerName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationController.Binding.isNavigationBarHidden) }
	static var isToolbarHidden: NavigationControllerName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationController.Binding.isToolbarHidden) }
	static var stack: NavigationControllerName<Dynamic<StackMutation<ViewControllerConvertible>>> { return .name(NavigationController.Binding.stack) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var poppedToCount: NavigationControllerName<SignalInput<Int>> { return .name(NavigationController.Binding.poppedToCount) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationController: NavigationControllerName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?> { return .name(NavigationController.Binding.animationController) }
	static var interactionController: NavigationControllerName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> { return .name(NavigationController.Binding.interactionController) }
	static var preferredInterfaceOrientation: NavigationControllerName<(_ navigationController: UINavigationController) -> UIInterfaceOrientation> { return .name(NavigationController.Binding.preferredInterfaceOrientation) }
	static var supportedInterfaceOrientations: NavigationControllerName<(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask> { return .name(NavigationController.Binding.supportedInterfaceOrientations) }
	static var didShow: NavigationControllerName<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> { return .name(NavigationController.Binding.didShow) }
	static var willShow: NavigationControllerName<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> { return .name(NavigationController.Binding.willShow) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol NavigationControllerConvertible: ViewControllerConvertible {
	func uiNavigationController() -> NavigationController.Instance
}
extension NavigationControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiNavigationController() }
}
extension UINavigationController: NavigationControllerConvertible, HasDelegate {
	func uiNavigationController() -> NavigationController.Instance { return self }
}
extension NavigationController {
	func uiNavigationController() -> NavigationController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol NavigationControllerBinding: ViewControllerBinding {
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> Self
}
extension NavigationControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return navigationControllerBinding(.inheritedBinding(binding))
	}
}
extension NavigationController.Binding {
	typealias Preparer = NavigationController.Preparer
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> NavigationController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class NavigationItem: Binder, NavigationItemConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension NavigationItem {
	enum Binding: NavigationItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backBarButtonItem(Dynamic<BarButtonItemConvertible?>)
		case hidesBackButton(Dynamic<SetOrAnimate<Bool>>)
		case leftBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case leftItemsSupplementBackButton(Dynamic<Bool>)
		case prompt(Dynamic<String?>)
		case rightBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case title(Dynamic<String>)
		case titleView(Dynamic<ViewConvertible?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension NavigationItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = NavigationItem.Binding
		typealias Inherited = BinderBase
		typealias Instance = UINavigationItem
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}
		
// MARK: - Binder Part 4: Preparer overrides
extension NavigationItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .backBarButtonItem(let x): return x.apply(instance) { i, v in i.backBarButtonItem = v?.uiBarButtonItem() }
		case .hidesBackButton(let x): return x.apply(instance) { i, v in i.setHidesBackButton(v.value, animated: v.isAnimated) }
		case .leftBarButtonItems(let x): return x.apply(instance) { i, v in i.setLeftBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .leftItemsSupplementBackButton(let x): return x.apply(instance) { i, v in i.leftItemsSupplementBackButton = v }
		case .prompt(let x): return x.apply(instance) { i, v in i.prompt = v }
		case .rightBarButtonItems(let x): return x.apply(instance) { i, v in i.setRightBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titleView(let x): return x.apply(instance) { i, v in i.titleView = v?.uiView() }

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationItem.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationItemBinding {
	typealias NavigationItemName<V> = BindingName<V, NavigationItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationItem.Binding) -> NavigationItemName<V> {
		return NavigationItemName<V>(source: source, downcast: Binding.navigationItemBinding)
	}
}
extension BindingName where Binding: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationItemName<$2> { return .name(NavigationItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backBarButtonItem: NavigationItemName<Dynamic<BarButtonItemConvertible?>> { return .name(NavigationItem.Binding.backBarButtonItem) }
	static var hidesBackButton: NavigationItemName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationItem.Binding.hidesBackButton) }
	static var leftBarButtonItems: NavigationItemName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(NavigationItem.Binding.leftBarButtonItems) }
	static var leftItemsSupplementBackButton: NavigationItemName<Dynamic<Bool>> { return .name(NavigationItem.Binding.leftItemsSupplementBackButton) }
	static var prompt: NavigationItemName<Dynamic<String?>> { return .name(NavigationItem.Binding.prompt) }
	static var rightBarButtonItems: NavigationItemName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(NavigationItem.Binding.rightBarButtonItems) }
	static var title: NavigationItemName<Dynamic<String>> { return .name(NavigationItem.Binding.title) }
	static var titleView: NavigationItemName<Dynamic<ViewConvertible?>> { return .name(NavigationItem.Binding.titleView) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	
	// Composite binding names
	static func leftBarButtonItems(animate: AnimationChoice = .subsequent) -> NavigationItemName<Dynamic<[BarButtonItemConvertible]>> {
		return Binding.compositeName(
			value: { dynamicArray in 
				switch dynamicArray {
				case .constant(let b) where animate == .always: return .constant(.animate(b))
				case .constant(let b): return .constant(.set(b))
				case .dynamic(let b): return .dynamic(b.animate(animate))
				}
			},
			binding: NavigationItem.Binding.leftBarButtonItems,
			downcast: Binding.navigationItemBinding
		)
	}
	static func rightBarButtonItems(animate: AnimationChoice = .subsequent) -> NavigationItemName<Dynamic<[BarButtonItemConvertible]>> {
		return Binding.compositeName(
			value: { dynamicArray in 
				switch dynamicArray {
				case .constant(let b) where animate == .always: return .constant(.animate(b))
				case .constant(let b): return .constant(.set(b))
				case .dynamic(let b): return .dynamic(b.animate(animate))
				}
			},
			binding: NavigationItem.Binding.rightBarButtonItems,
			downcast: Binding.navigationItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol NavigationItemConvertible {
	func uiNavigationItem() -> NavigationItem.Instance
}
extension UINavigationItem: NavigationItemConvertible, DefaultConstructable {
	func uiNavigationItem() -> NavigationItem.Instance { return self }
}
extension NavigationItem {
	func uiNavigationItem() -> NavigationItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol NavigationItemBinding: BinderBaseBinding {
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> Self
}
extension NavigationItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return navigationItemBinding(.inheritedBinding(binding))
	}
}
extension NavigationItem.Binding {
	typealias Preparer = NavigationItem.Preparer
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> NavigationItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class PageControl: Binder, PageControlConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PageControl {
	enum Binding: PageControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case currentPage(Dynamic<Int>)
		case currentPageIndicatorTintColor(Dynamic<UIColor?>)
		case defersCurrentPageDisplay(Dynamic<Bool>)
		case numberOfPages(Dynamic<Int>)
		case pageIndicatorTintColor(Dynamic<UIColor?>)

		// 2. Signal bindings are performed on the object after construction.
		case updateCurrentPageDisplay(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PageControl {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PageControl.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = UIPageControl
		typealias Parameters = () /* change if non-default construction required */
		
		var inherited = Inherited()
		init() {}
		
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PageControl.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		case .currentPage(let x): return x.apply(instance) { i, v in i.currentPage = v }
		case .currentPageIndicatorTintColor(let x): return x.apply(instance) { i, v in i.currentPageIndicatorTintColor = v }
		case .defersCurrentPageDisplay(let x): return x.apply(instance) { i, v in i.defersCurrentPageDisplay = v }
		case .numberOfPages(let x): return x.apply(instance) { i, v in i.numberOfPages = v }
		case .pageIndicatorTintColor(let x): return x.apply(instance) { i, v in i.pageIndicatorTintColor = v }
		case .updateCurrentPageDisplay(let x): return x.apply(instance) { i, _ in i.updateCurrentPageDisplay() }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PageControl.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PageControlBinding {
	typealias PageControlName<V> = BindingName<V, PageControl.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PageControl.Binding) -> PageControlName<V> {
		return PageControlName<V>(source: source, downcast: Binding.pageControlBinding)
	}
}
extension BindingName where Binding: PageControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PageControlName<$2> { return .name(PageControl.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var currentPage: PageControlName<Dynamic<Int>> { return .name(PageControl.Binding.currentPage) }
	static var currentPageIndicatorTintColor: PageControlName<Dynamic<UIColor?>> { return .name(PageControl.Binding.currentPageIndicatorTintColor) }
	static var defersCurrentPageDisplay: PageControlName<Dynamic<Bool>> { return .name(PageControl.Binding.defersCurrentPageDisplay) }
	static var numberOfPages: PageControlName<Dynamic<Int>> { return .name(PageControl.Binding.numberOfPages) }
	static var pageIndicatorTintColor: PageControlName<Dynamic<UIColor?>> { return .name(PageControl.Binding.pageIndicatorTintColor) }

	// 2. Signal bindings are performed on the object after construction.
	static var updateCurrentPageDisplay: PageControlName<Signal<Void>> { return .name(PageControl.Binding.updateCurrentPageDisplay) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PageControlConvertible: ControlConvertible {
	func uiPageControl() -> PageControl.Instance
}
extension PageControlConvertible {
	func uiControl() -> Control.Instance { return uiPageControl() }
}
extension UIPageControl: PageControlConvertible {
	func uiPageControl() -> PageControl.Instance { return self }
}
extension PageControl {
	func uiPageControl() -> PageControl.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PageControlBinding: ControlBinding {
	static func pageControlBinding(_ binding: PageControl.Binding) -> Self
}
extension PageControlBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return pageControlBinding(.inheritedBinding(binding))
	}
}
extension PageControl.Binding {
	typealias Preparer = PageControl.Preparer
	static func pageControlBinding(_ binding: PageControl.Binding) -> PageControl.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class PageViewController<PageData>: Binder, PageViewControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PageViewController {
	enum Binding: PageViewControllerBinding {
		typealias PageDataType = PageData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		case navigationOrientation(Constant<UIPageViewController.NavigationOrientation>)
		case pageSpacing(Constant<CGFloat>)
		case spineLocation(Constant<UIPageViewController.SpineLocation>)
		case transitionStyle(Constant<UIPageViewController.TransitionStyle>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case isDoubleSided(Dynamic<Bool>)
		case pageData(Dynamic<Animatable<[PageData], UIPageViewController.NavigationDirection>>)

		// 2. Signal bindings are performed on the object after construction.
		case changeCurrentPage(Signal<Animatable<Int, UIPageViewController.NavigationDirection>>)

		// 3. Action bindings are triggered by the object after construction.
		case pageChanged(SignalInput<(index: Int, data: PageData)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case constructPage((PageData) -> ViewControllerConvertible)
		case didFinishAnimating((UIPageViewController, Bool, [UIViewController], Bool) -> Void)
		case interfaceOrientationForPresentation((UIPageViewController) -> UIInterfaceOrientation)
		case spineLocationFor((UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation)
		case supportedInterfaceOrientations((UIPageViewController) -> UIInterfaceOrientationMask)
		case willTransitionTo((UIPageViewController, [UIViewController]) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension PageViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = PageViewController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = UIPageViewController
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage(pageChanged: pageChanged) }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var transitionStyle = UIPageViewController.TransitionStyle.scroll
		var navigationOrientation = UIPageViewController.NavigationOrientation.horizontal
		var spineLocation = UIPageViewController.SpineLocation.min
		var pageSpacing = CGFloat(0)
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		var pageChanged: MultiOutput<(index: Int, data: PageData)>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PageViewController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(transitionStyle: transitionStyle, navigationOrientation: navigationOrientation, options: [UIPageViewController.OptionsKey.spineLocation: spineLocation.rawValue, UIPageViewController.OptionsKey.interPageSpacing: pageSpacing])
	}
	
	mutating func prepareBinding(_ binding: PageViewController<PageData>.Binding) {
		switch binding {
		case .inheritedBinding(let x): return inherited.prepareBinding(x)
		
		case .constructPage(let x): pageConstructor = x
		case .transitionStyle(let x): transitionStyle = x.value
		case .navigationOrientation(let x): navigationOrientation = x.value
		case .spineLocation(let x): spineLocation = x.value
		case .pageSpacing(let x): pageSpacing = x.value
		case .pageChanged(let x):
			pageChanged = pageChanged ?? Input().multicast()
			pageChanged?.signal.bind(to: x)
		case .willTransitionTo(let x): delegate().addMultiHandler2(x, #selector(UIPageViewControllerDelegate.pageViewController(_:willTransitionTo:)))
		case .didFinishAnimating(let x): delegate().addMultiHandler4(x, #selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)))
		case .spineLocationFor(let x): delegate().addSingleHandler2(x, #selector(UIPageViewControllerDelegate.pageViewController(_:spineLocationFor:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UIPageViewControllerDelegate.pageViewControllerSupportedInterfaceOrientations(_:)))
		case .interfaceOrientationForPresentation(let x): delegate().addSingleHandler1(x, #selector(UIPageViewControllerDelegate.pageViewControllerPreferredInterfaceOrientationForPresentation(_:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		storage.pageConstructor = pageConstructor
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationOrientation: return nil
		case .pageSpacing: return nil
		case .spineLocation: return nil
		case .transitionStyle: return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .isDoubleSided(let x): return x.apply(instance) { i, v in i.isDoubleSided = v }
		case .pageData(let x):
			return x.apply(instance, storage) { i, s, v in
				s.changePageData(v.value, in: i, animation: v.animation)
			}

		// 2. Signal bindings are performed on the object after construction.
		case .changeCurrentPage(let x):
			return x.apply(instance, storage) { i, s, v in
				s.changeCurrentPage(v.value, in: i, animation: v.animation)
			}

		// 3. Action bindings are triggered by the object after construction.
		case .pageChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .constructPage: return nil
		case .didFinishAnimating: return nil
		case .interfaceOrientationForPresentation: return nil
		case .spineLocationFor: return nil
		case .supportedInterfaceOrientations: return nil
		case .willTransitionTo: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PageViewController.Preparer {
	class Storage: ViewController.Preparer.Storage, UIPageViewControllerDelegate, UIPageViewControllerDataSource {
		var activeViewControllers: [(Int, Weak<UIViewController>)] = []
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		var pageData: [PageData] = []
		let pageChanged: MultiOutput<(index: Int, data: PageData)>?
		
		init(pageChanged: MultiOutput<(index: Int, data: PageData)>?) {
			self.pageChanged = pageChanged
		}
		
		func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i - 1)
			}
			return nil
		}
		
		func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i + 1)
			}
			return nil
		}

		func changeCurrentPage(_ index: Int, in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			if let vc = viewController(at: index), !(vc === pvc.viewControllers?.first) {
				pvc.setViewControllers([vc], direction: animation ?? .forward, animated: animation != nil, completion: nil)
			}
		}
		
		func changePageData(_ newPageData: [PageData], in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			let indexes = pvc.viewControllers?.compactMap { self.index(of: $0) }.sorted() ?? (newPageData.isEmpty ? [] : [0])
			pageData = newPageData
			activeViewControllers.removeAll()
			var newViewControllers = indexes.compactMap { self.viewController(at: $0) }
			if !newPageData.isEmpty && newViewControllers.isEmpty, let vc = viewController(at: 0) {
				newViewControllers.append(vc)
			}
			pvc.setViewControllers(newViewControllers, direction: animation ?? .forward, animated: animation != nil, completion: nil)
		}
		
		func viewController(at: Int) -> UIViewController? {
			guard let constructor = pageConstructor, pageData.indices.contains(at) else { return nil }
			var i = 0
			var match: UIViewController? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if tuple.0 == at {
						match = vc
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			if let m = match {
				return m
			}
			let vc = constructor(pageData[at]).uiViewController()
			activeViewControllers.append((at, Weak(vc)))
			return vc
		}
		
		func index(of: UIViewController) -> Int? {
			var i = 0
			var match: Int? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if vc === of {
						match = tuple.0
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			return match
		}
		
		func presentationCount(for pageViewController: UIPageViewController) -> Int {
			return pageData.count
		}
		
		func presentationIndex(for pageViewController: UIPageViewController) -> Int {
			guard let vc = pageViewController.viewControllers?.first else { return 0 }
			return index(of: vc) ?? 0
		}

		func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			if completed, let input = pageChanged?.input, let vc = pageViewController.children.first, let index = index(of: vc), let data = pageData.at(index) {
				input.send(value: (index, data))
			}
			
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:))) {
				(dd as? UIPageViewControllerDelegate)?.pageViewController?(pageViewController, didFinishAnimating: finished, previousViewControllers: previousViewControllers, transitionCompleted: completed)
			}
		}
	}

	class Delegate: DynamicDelegate, UIPageViewControllerDelegate {
		func pageViewController(_ pageViewController: UIPageViewController, willTransitionTo pendingViewControllers: [UIViewController]) {
			multiHandler(pageViewController, pendingViewControllers)
		}
		
		func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) -> UIPageViewController.SpineLocation {
			return singleHandler(pageViewController, orientation)
		}
		
		func pageViewControllerSupportedInterfaceOrientations(_ pageViewController: UIPageViewController) -> UIInterfaceOrientationMask {
			return singleHandler(pageViewController)
		}
		
		func pageViewControllerPreferredInterfaceOrientationForPresentation(_ pageViewController: UIPageViewController) -> UIInterfaceOrientation {
			return singleHandler(pageViewController)
		}
		
		func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			multiHandler(pageViewController, finished, previousViewControllers, completed)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PageViewControllerBinding {
	typealias PageViewControllerName<V> = BindingName<V, PageViewController<Binding.PageDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PageViewController<Binding.PageDataType>.Binding) -> PageViewControllerName<V> {
		return PageViewControllerName<V>(source: source, downcast: Binding.pageViewControllerBinding)
	}
}
extension BindingName where Binding: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PageViewControllerName<$2> { return .name(PageViewController.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationOrientation: PageViewControllerName<Constant<UIPageViewController.NavigationOrientation>> { return .name(PageViewController.Binding.navigationOrientation) }
	static var pageSpacing: PageViewControllerName<Constant<CGFloat>> { return .name(PageViewController.Binding.pageSpacing) }
	static var spineLocation: PageViewControllerName<Constant<UIPageViewController.SpineLocation>> { return .name(PageViewController.Binding.spineLocation) }
	static var transitionStyle: PageViewControllerName<Constant<UIPageViewController.TransitionStyle>> { return .name(PageViewController.Binding.transitionStyle) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isDoubleSided: PageViewControllerName<Dynamic<Bool>> { return .name(PageViewController.Binding.isDoubleSided) }
	static var pageData: PageViewControllerName<Dynamic<Animatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>> { return .name(PageViewController.Binding.pageData) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var changeCurrentPage: PageViewControllerName<Signal<Animatable<Int, UIPageViewController.NavigationDirection>>> { return .name(PageViewController.Binding.changeCurrentPage) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var pageChanged: PageViewControllerName<SignalInput<(index: Int, data: Binding.PageDataType)>> { return .name(PageViewController.Binding.pageChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var constructPage: PageViewControllerName<(Binding.PageDataType) -> ViewControllerConvertible> { return .name(PageViewController.Binding.constructPage) }
	static var didFinishAnimating: PageViewControllerName<(UIPageViewController, Bool, [UIViewController], Bool) -> Void> { return .name(PageViewController.Binding.didFinishAnimating) }
	static var interfaceOrientationForPresentation: PageViewControllerName<(UIPageViewController) -> UIInterfaceOrientation> { return .name(PageViewController.Binding.interfaceOrientationForPresentation) }
	static var spineLocationFor: PageViewControllerName<(UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation> { return .name(PageViewController.Binding.spineLocationFor) }
	static var supportedInterfaceOrientations: PageViewControllerName<(UIPageViewController) -> UIInterfaceOrientationMask> { return .name(PageViewController.Binding.supportedInterfaceOrientations) }
	static var willTransitionTo: PageViewControllerName<(UIPageViewController, [UIViewController]) -> Void> { return .name(PageViewController.Binding.willTransitionTo) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PageViewControllerConvertible: ViewControllerConvertible {
	func uiPageViewController() -> UIPageViewController
}
extension PageViewControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiPageViewController() }
}
extension UIPageViewController: PageViewControllerConvertible, HasDelegate {
	func uiPageViewController() -> UIPageViewController { return self }
}
extension PageViewController {
	func uiPageViewController() -> UIPageViewController { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PageViewControllerBinding: ViewControllerBinding {
	associatedtype PageDataType
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> Self
}
extension PageViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return pageViewControllerBinding(PageViewController<PageDataType>.Binding.inheritedBinding(binding))
	}
}
extension PageViewController.Binding {
	typealias Preparer = PageViewController.Preparer
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> PageViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class PanGestureRecognizer: Binder, PanGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PanGestureRecognizer {
	enum Binding: PanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumNumberOfTouches(Dynamic<Int>)
		case minimumNumberOfTouches(Dynamic<Int>)
		case translation(Dynamic<CGPoint>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PanGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UIPanGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .maximumNumberOfTouches(let x): return x.apply(instance) { i, v in i.maximumNumberOfTouches = v }
		case .minimumNumberOfTouches(let x): return x.apply(instance) { i, v in i.minimumNumberOfTouches = v }
		case .translation(let x): return x.apply(instance) { i, v in i.setTranslation(v, in: nil) }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PanGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PanGestureRecognizerBinding {
	typealias PanGestureRecognizerName<V> = BindingName<V, PanGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PanGestureRecognizer.Binding) -> PanGestureRecognizerName<V> {
		return PanGestureRecognizerName<V>(source: source, downcast: Binding.panGestureRecognizerBinding)
	}
}
extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PanGestureRecognizerName<$2> { return .name(PanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumNumberOfTouches: PanGestureRecognizerName<Dynamic<Int>> { return .name(PanGestureRecognizer.Binding.maximumNumberOfTouches) }
	static var minimumNumberOfTouches: PanGestureRecognizerName<Dynamic<Int>> { return .name(PanGestureRecognizer.Binding.minimumNumberOfTouches) }
	static var translation: PanGestureRecognizerName<Dynamic<CGPoint>> { return .name(PanGestureRecognizer.Binding.translation) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPanGestureRecognizer() }
}
extension UIPanGestureRecognizer: PanGestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return self }
}
extension PanGestureRecognizer {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
}
extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension PanGestureRecognizer.Binding {
	typealias Preparer = PanGestureRecognizer.Preparer
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> PanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class PinchGestureRecognizer: Binder, PinchGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PinchGestureRecognizer {
	enum Binding: PinchGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case scale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PinchGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PinchGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UIPinchGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PinchGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .scale(let x): return x.apply(instance) { i, v in i.scale = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PinchGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PinchGestureRecognizerBinding {
	typealias PinchGestureRecognizerName<V> = BindingName<V, PinchGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PinchGestureRecognizer.Binding) -> PinchGestureRecognizerName<V> {
		return PinchGestureRecognizerName<V>(source: source, downcast: Binding.pinchGestureRecognizerBinding)
	}
}
extension BindingName where Binding: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PinchGestureRecognizerName<$2> { return .name(PinchGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var scale: PinchGestureRecognizerName<Dynamic<CGFloat>> { return .name(PinchGestureRecognizer.Binding.scale) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PinchGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance
}
extension PinchGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPinchGestureRecognizer() }
}
extension UIPinchGestureRecognizer: PinchGestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return self }
}
extension PinchGestureRecognizer {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PinchGestureRecognizerBinding: GestureRecognizerBinding {
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> Self
}
extension PinchGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return pinchGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension PinchGestureRecognizer.Binding {
	typealias Preparer = PinchGestureRecognizer.Preparer
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> PinchGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class RotationGestureRecognizer: Binder, RotationGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension RotationGestureRecognizer {
	enum Binding: RotationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotation(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension RotationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = RotationGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UIRotationGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension RotationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .rotation(let x): return x.apply(instance) { i, v in i.rotation = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension RotationGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: RotationGestureRecognizerBinding {
	typealias RotationGestureRecognizerName<V> = BindingName<V, RotationGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> RotationGestureRecognizer.Binding) -> RotationGestureRecognizerName<V> {
		return RotationGestureRecognizerName<V>(source: source, downcast: Binding.rotationGestureRecognizerBinding)
	}
}
extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: RotationGestureRecognizerName<$2> { return .name(RotationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotation: RotationGestureRecognizerName<Dynamic<CGFloat>> { return .name(RotationGestureRecognizer.Binding.rotation) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiRotationGestureRecognizer() }
}
extension UIRotationGestureRecognizer: RotationGestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return self }
}
extension RotationGestureRecognizer {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
}
extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension RotationGestureRecognizer.Binding {
	typealias Preparer = RotationGestureRecognizer.Preparer
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> RotationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class ScreenEdgePanGestureRecognizer: Binder, ScreenEdgePanGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ScreenEdgePanGestureRecognizer {
	enum Binding: ScreenEdgePanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case edges(Dynamic<UIRectEdge>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ScreenEdgePanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ScreenEdgePanGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UIScreenEdgePanGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ScreenEdgePanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .edges(let x): return x.apply(instance) { i, v in i.edges = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScreenEdgePanGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	typealias ScreenEdgePanGestureRecognizerName<V> = BindingName<V, ScreenEdgePanGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ScreenEdgePanGestureRecognizer.Binding) -> ScreenEdgePanGestureRecognizerName<V> {
		return ScreenEdgePanGestureRecognizerName<V>(source: source, downcast: Binding.screenEdgePanGestureRecognizerBinding)
	}
}
extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScreenEdgePanGestureRecognizerName<$2> { return .name(ScreenEdgePanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var edges: ScreenEdgePanGestureRecognizerName<Dynamic<UIRectEdge>> { return .name(ScreenEdgePanGestureRecognizer.Binding.edges) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ScreenEdgePanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance
}
extension ScreenEdgePanGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiScreenEdgePanGestureRecognizer() }
}
extension UIScreenEdgePanGestureRecognizer: ScreenEdgePanGestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return self }
}
extension ScreenEdgePanGestureRecognizer {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ScreenEdgePanGestureRecognizerBinding: GestureRecognizerBinding {
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> Self
}
extension ScreenEdgePanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return screenEdgePanGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension ScreenEdgePanGestureRecognizer.Binding {
	typealias Preparer = ScreenEdgePanGestureRecognizer.Preparer
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> ScreenEdgePanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class ScrollView: Binder, ScrollViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ScrollView {
	enum Binding: ScrollViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case panGestureRecognizerStyles(Constant<PanGestureRecognizer>)
		case pinchGestureRecognizerStyles(Constant<PinchGestureRecognizer>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alwaysBounceHorizontal(Dynamic<Bool>)
		case alwaysBounceVertical(Dynamic<Bool>)
		case bounces(Dynamic<Bool>)
		case bouncesZoom(Dynamic<Bool>)
		case canCancelContentTouches(Dynamic<Bool>)
		case contentInset(Dynamic<UIEdgeInsets>)
		case contentInsetAdjustmentBehavior(Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>)
		case contentOffset(Dynamic<SetOrAnimate<CGPoint>>)
		case contentSize(Dynamic<CGSize>)
		case decelerationRate(Dynamic<UIScrollView.DecelerationRate>)
		case delaysContentTouches(Dynamic<Bool>)
		case indicatorStyle(Dynamic<UIScrollView.IndicatorStyle>)
		case isDirectionalLockEnabled(Dynamic<Bool>)
		case isPagingEnabled(Dynamic<Bool>)
		case isScrollEnabled(Dynamic<Bool>)
		case maximumZoomScale(Dynamic<CGFloat>)
		case minimumZoomScale(Dynamic<CGFloat>)
		case refreshControl(Dynamic<UIRefreshControl?>)
		case scrollIndicatorInsets(Dynamic<UIEdgeInsets>)
		case scrollsToTop(Dynamic<Bool>)
		case showsHorizontalScrollIndicator(Dynamic<Bool>)
		case showsVerticalScrollIndicator(Dynamic<Bool>)
		case zoomScale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		case flashScrollIndicators(Signal<Void>)
		case scrollRectToVisible(Signal<(rect: CGRect, animated: Bool)>)
		case zoom(Signal<(rect: CGRect, animated: Bool)>)
		
		// 3. Action bindings are triggered by the object after construction.
		case userDidScroll(SignalInput<CGPoint>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didEndDecelerating((UIScrollView) -> Void)
		case didEndDragging((UIScrollView, Bool) -> Void)
		case didEndScrollingAnimation((UIScrollView) -> Void)
		case didEndZooming((UIScrollView, UIView?, CGFloat) -> Void)
		case didScroll((UIScrollView, CGPoint) -> Void)
		case didScrollToTop((UIScrollView) -> Void)
		case didZoom((UIScrollView) -> Void)
		case shouldScrollToTop((_ scrollView: UIScrollView) -> Bool)
		case viewForZooming((_ scrollView: UIScrollView) -> UIView?)
		case willBeginDecelerating((UIScrollView) -> Void)
		case willBeginDragging((UIScrollView) -> Void)
		case willBeginZooming((UIScrollView, UIView?) -> Void)
		case willEndDragging((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension ScrollView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = ScrollView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UIScrollView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ScrollView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .didEndDecelerating(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:)))
		case .didEndDragging(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:)))
		case .didEndScrollingAnimation(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:)))
		case .didEndZooming(let x): delegate().addMultiHandler3(x, #selector(UIScrollViewDelegate.scrollViewDidEndZooming(_:with:atScale:)))
		case .didScroll(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewDidScroll(_:)))
		case .didScrollToTop(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:)))
		case .didZoom(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidZoom(_:)))
		case .shouldScrollToTop(let x): delegate().addSingleHandler1(x, #selector(UIScrollViewDelegate.scrollViewShouldScrollToTop(_:)))
		case .userDidScroll(let x):
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in x.send(value: sv.contentOffset) },
				#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
			)
			delegate().addMultiHandler2(
				{ (sv: UIScrollView, d: Bool) -> Void in if !d { x.send(value: sv.contentOffset) } },
				#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
			)
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in x.send(value: sv.contentOffset) },
				#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
			)
		case .viewForZooming(let x): delegate().addSingleHandler1(x, #selector(UIScrollViewDelegate.viewForZooming(in:)))
		case .willBeginDecelerating(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewWillBeginDecelerating(_:)))
		case .willBeginDragging(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewWillBeginDragging(_:)))
		case .willBeginZooming(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewWillBeginZooming(_:with:)))
		case .willEndDragging(let x): delegate().addMultiHandler3(x, #selector(UIScrollViewDelegate.scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .panGestureRecognizerStyles(let x):
			x.value.apply(to: instance.panGestureRecognizer)
			return nil
		case .pinchGestureRecognizerStyles(let x):
			if let pgr = instance.pinchGestureRecognizer {
				x.value.apply(to: pgr)
			}
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .alwaysBounceHorizontal(let x): return x.apply(instance) { i, v in i.alwaysBounceHorizontal = v }
		case .alwaysBounceVertical(let x): return x.apply(instance) { i, v in i.alwaysBounceVertical = v }
		case .bounces(let x): return x.apply(instance) { i, v in i.bounces = v }
		case .bouncesZoom(let x): return x.apply(instance) { i, v in i.bouncesZoom = v }
		case .canCancelContentTouches(let x): return x.apply(instance) { i, v in i.canCancelContentTouches = v }
		case .contentInset(let x): return x.apply(instance) { i, v in i.contentInset = v }
		case .contentInsetAdjustmentBehavior(let x): return x.apply(instance) { i, v in i.contentInsetAdjustmentBehavior = v }
		case .contentOffset(let x): return x.apply(instance) { i, v in i.setContentOffset(v.value, animated: v.isAnimated) }
		case .contentSize(let x): return x.apply(instance) { i, v in i.contentSize = v }
		case .decelerationRate(let x): return x.apply(instance) { i, v in i.decelerationRate = v }
		case .delaysContentTouches(let x): return x.apply(instance) { i, v in i.delaysContentTouches = v }
		case .indicatorStyle(let x): return x.apply(instance) { i, v in i.indicatorStyle = v }
		case .isDirectionalLockEnabled(let x): return x.apply(instance) { i, v in i.isDirectionalLockEnabled = v }
		case .isPagingEnabled(let x): return x.apply(instance) { i, v in i.isPagingEnabled = v }
		case .isScrollEnabled(let x): return x.apply(instance) { i, v in i.isScrollEnabled = v }
		case .maximumZoomScale(let x): return x.apply(instance) { i, v in i.maximumZoomScale = v }
		case .minimumZoomScale(let x): return x.apply(instance) { i, v in i.minimumZoomScale = v }
		case .refreshControl(let x): return x.apply(instance) { i, v in i.refreshControl = v }
		case .scrollIndicatorInsets(let x): return x.apply(instance) { i, v in i.scrollIndicatorInsets = v }
		case .scrollsToTop(let x): return x.apply(instance) { i, v in i.scrollsToTop = v }
		case .showsHorizontalScrollIndicator(let x): return x.apply(instance) { i, v in i.showsHorizontalScrollIndicator = v }
		case .showsVerticalScrollIndicator(let x): return x.apply(instance) { i, v in i.showsVerticalScrollIndicator = v }
		case .zoomScale(let x): return x.apply(instance) { i, v in i.zoomScale = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .flashScrollIndicators(let x): return x.apply(instance) { i, v in i.flashScrollIndicators() }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollRectToVisible(v.rect, animated: v.animated) }
		case .zoom(let x): return x.apply(instance) { i, v in i.zoom(to: v.rect, animated: v.animated) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didEndDecelerating: return nil
		case .didEndDragging: return nil
		case .didEndScrollingAnimation: return nil
		case .didEndZooming: return nil
		case .didScroll: return nil
		case .didScrollToTop: return nil
		case .didZoom: return nil
		case .userDidScroll: return nil
		case .willBeginDecelerating: return nil
		case .willBeginDragging: return nil
		case .willBeginZooming: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldScrollToTop: return nil
		case .viewForZooming: return nil
		case .willEndDragging: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScrollView.Preparer {
	class Storage: View.Preparer.Storage, UIScrollViewDelegate {}
	
	class Delegate: DynamicDelegate, UIScrollViewDelegate {
		func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			multiHandler(scrollView, decelerate)
		}
		
		func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewDidScroll(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewDidZoom(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) {
			multiHandler(scrollView, view)
		}
		
		func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
			multiHandler(scrollView, view, scale)
		}
		
		func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
			multiHandler(scrollView, velocity, targetContentOffset)
		}
		
		func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
			return singleHandler(scrollView)
		}
		
		func viewForZooming(in scrollView: UIScrollView) -> UIView? {
			return singleHandler(scrollView)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScrollViewBinding {
	typealias ScrollViewName<V> = BindingName<V, ScrollView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ScrollView.Binding) -> ScrollViewName<V> {
		return ScrollViewName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScrollViewName<$2> { return .name(ScrollView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var panGestureRecognizerStyles: ScrollViewName<Constant<PanGestureRecognizer>> { return .name(ScrollView.Binding.panGestureRecognizerStyles) }
	static var pinchGestureRecognizerStyles: ScrollViewName<Constant<PinchGestureRecognizer>> { return .name(ScrollView.Binding.pinchGestureRecognizerStyles) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alwaysBounceHorizontal: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.alwaysBounceHorizontal) }
	static var alwaysBounceVertical: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.alwaysBounceVertical) }
	static var bounces: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.bounces) }
	static var bouncesZoom: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.bouncesZoom) }
	static var canCancelContentTouches: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.canCancelContentTouches) }
	static var contentInset: ScrollViewName<Dynamic<UIEdgeInsets>> { return .name(ScrollView.Binding.contentInset) }
	static var contentInsetAdjustmentBehavior: ScrollViewName<Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>> { return .name(ScrollView.Binding.contentInsetAdjustmentBehavior) }
	static var contentOffset: ScrollViewName<Dynamic<SetOrAnimate<CGPoint>>> { return .name(ScrollView.Binding.contentOffset) }
	static var contentSize: ScrollViewName<Dynamic<CGSize>> { return .name(ScrollView.Binding.contentSize) }
	static var decelerationRate: ScrollViewName<Dynamic<UIScrollView.DecelerationRate>> { return .name(ScrollView.Binding.decelerationRate) }
	static var delaysContentTouches: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.delaysContentTouches) }
	static var indicatorStyle: ScrollViewName<Dynamic<UIScrollView.IndicatorStyle>> { return .name(ScrollView.Binding.indicatorStyle) }
	static var isDirectionalLockEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isDirectionalLockEnabled) }
	static var isPagingEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isPagingEnabled) }
	static var isScrollEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isScrollEnabled) }
	static var maximumZoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.maximumZoomScale) }
	static var minimumZoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.minimumZoomScale) }
	static var refreshControl: ScrollViewName<Dynamic<UIRefreshControl?>> { return .name(ScrollView.Binding.refreshControl) }
	static var scrollIndicatorInsets: ScrollViewName<Dynamic<UIEdgeInsets>> { return .name(ScrollView.Binding.scrollIndicatorInsets) }
	static var scrollsToTop: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.scrollsToTop) }
	static var showsHorizontalScrollIndicator: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.showsHorizontalScrollIndicator) }
	static var showsVerticalScrollIndicator: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.showsVerticalScrollIndicator) }
	static var zoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.zoomScale) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollIndicators: ScrollViewName<Signal<Void>> { return .name(ScrollView.Binding.flashScrollIndicators) }
	static var scrollRectToVisible: ScrollViewName<Signal<(rect: CGRect, animated: Bool)>> { return .name(ScrollView.Binding.scrollRectToVisible) }
	static var zoom: ScrollViewName<Signal<(rect: CGRect, animated: Bool)>> { return .name(ScrollView.Binding.zoom) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var userDidScroll: ScrollViewName<SignalInput<CGPoint>> { return .name(ScrollView.Binding.userDidScroll) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didEndDecelerating: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didEndDecelerating) }
	static var didEndDragging: ScrollViewName<(UIScrollView, Bool) -> Void> { return .name(ScrollView.Binding.didEndDragging) }
	static var didEndScrollingAnimation: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didEndScrollingAnimation) }
	static var didEndZooming: ScrollViewName<(UIScrollView, UIView?, CGFloat) -> Void> { return .name(ScrollView.Binding.didEndZooming) }
	static var didScroll: ScrollViewName<(UIScrollView, CGPoint) -> Void> { return .name(ScrollView.Binding.didScroll) }
	static var didScrollToTop: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didScrollToTop) }
	static var didZoom: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didZoom) }
	static var shouldScrollToTop: ScrollViewName<(_ scrollView: UIScrollView) -> Bool> { return .name(ScrollView.Binding.shouldScrollToTop) }
	static var viewForZooming: ScrollViewName<(_ scrollView: UIScrollView) -> UIView?> { return .name(ScrollView.Binding.viewForZooming) }
	static var willBeginDecelerating: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.willBeginDecelerating) }
	static var willBeginDragging: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.willBeginDragging) }
	static var willBeginZooming: ScrollViewName<(UIScrollView, UIView?) -> Void> { return .name(ScrollView.Binding.willBeginZooming) }
	static var willEndDragging: ScrollViewName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void> { return .name(ScrollView.Binding.willEndDragging) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ScrollViewConvertible: ViewConvertible {
	func uiScrollView() -> ScrollView.Instance
}
extension ScrollViewConvertible {
	func uiView() -> View.Instance { return uiScrollView() }
}
extension UIScrollView: ScrollViewConvertible, HasDelegate {
	func uiScrollView() -> ScrollView.Instance { return self }
}
extension ScrollView {
	func uiScrollView() -> ScrollView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self
}
extension ScrollViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
extension ScrollView.Binding {
	typealias Preparer = ScrollView.Preparer
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> ScrollView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class SearchBar: Binder, SearchBarConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension SearchBar {
	enum Binding: SearchBarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case barStyle(Dynamic<UIBarStyle>)
		case image(Dynamic<ScopedValues<IconAndControlState, UIImage?>>)
		case inputAccessoryView(Dynamic<UIView?>)
		case isTranslucent(Dynamic<Bool>)
		case placeholder(Dynamic<String>)
		case positionAdjustment(Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>)
		case prompt(Dynamic<String>)
		case scopeBarButtonBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case scopeBarButtonDividerImage(Dynamic<ScopedValues<LeftRightControlState, UIImage?>>)
		case scopeBarButtonTitleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>)
		case scopeButtonTitles(Dynamic<[String]?>)
		case searchFieldBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case searchFieldBackgroundPositionAdjustment(Dynamic<UIOffset>)
		case searchTextPositionAdjustment(Dynamic<UIOffset>)
		case selectedScopeButtonIndex(Dynamic<Int>)
		case showCancelButton(Dynamic<SetOrAnimate<Bool>>)
		case showsBookmarkButton(Dynamic<Bool>)
		case showsScopeBar(Dynamic<Bool>)
		case showsSearchResultsButton(Dynamic<Bool>)
		case text(Dynamic<String>)
		case tintColor(Dynamic<UIColor>)

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case bookmarkButtonClicked((UISearchBar) -> Void)
		case cancelButtonClicked((UISearchBar) -> Void)
		case textDidBeginEditing((UISearchBar) -> Void)
		case textDidChange((UISearchBar) -> Void)
		case textDidEndEditing((UISearchBar) -> Void)
		case position((UIBarPositioning) -> UIBarPosition)
		case resultsListButtonClicked((UISearchBar) -> Void)
		case searchButtonClicked((UISearchBar) -> Void)
		case selectedScopeButtonIndexDidChange((UISearchBar, Int) -> Void)
		case shouldBeginEditing((UISearchBar) -> Bool)
		case shouldChangeText((UISearchBar, NSRange, String) -> Bool)
		case shouldEndEditing((UISearchBar) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension SearchBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = SearchBar.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UISearchBar
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension SearchBar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .bookmarkButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:)))
		case .cancelButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:)))
		case .textDidBeginEditing(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:)))
		case .textDidChange(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBar(_:textDidChange:)))
		case .textDidEndEditing(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:)))
		case .position(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.position(for:)))
		case .resultsListButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:)))
		case .searchButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:)))
		case .selectedScopeButtonIndexDidChange(let x): delegate().addMultiHandler2(x, #selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.searchBarShouldBeginEditing(_:)))
		case .shouldChangeText(let x): delegate().addSingleHandler3(x, #selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.searchBarShouldEndEditing(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .image(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setImage(nil, for: scope.icon, state: scope.controlState) },
				applyNew: { i, scope, v in i.setImage(v, for: scope.icon, state: scope.controlState) }
			)
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .placeholder(let x): return x.apply(instance) { i, v in i.placeholder = v }
		case .positionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setPositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setPositionAdjustment(v, for: scope) }
			)
		case .prompt(let x): return x.apply(instance) { i, v in i.prompt = v }
		case .scopeBarButtonBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonBackgroundImage(v, for: scope) }
			)
		case .scopeBarButtonDividerImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonDividerImage(nil, forLeftSegmentState: scope.left, rightSegmentState: scope.right) },
				applyNew: { i, scope, v in i.setScopeBarButtonDividerImage(v, forLeftSegmentState: scope.left, rightSegmentState: scope.right) }
			)
		case .scopeBarButtonTitleTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonTitleTextAttributes(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonTitleTextAttributes(v, for: scope) }
			)
		case .scopeButtonTitles(let x): return x.apply(instance) { i, v in i.scopeButtonTitles = v }
		case .searchFieldBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonBackgroundImage(v, for: scope) }
			)
		case .searchFieldBackgroundPositionAdjustment(let x): return x.apply(instance) { i, v in i.searchFieldBackgroundPositionAdjustment = v }
		case .searchTextPositionAdjustment(let x): return x.apply(instance) { i, v in i.searchTextPositionAdjustment = v }
		case .selectedScopeButtonIndex(let x): return x.apply(instance) { i, v in i.selectedScopeButtonIndex = v }
		case .showCancelButton(let x): return x.apply(instance) { i, v in i.setShowsCancelButton(v.value, animated: v.isAnimated) }
		case .showsBookmarkButton(let x): return x.apply(instance) { i, v in i.showsBookmarkButton = v }
		case .showsScopeBar(let x): return x.apply(instance) { i, v in i.showsScopeBar = v }
		case .showsSearchResultsButton(let x): return x.apply(instance) { i, v in i.showsSearchResultsButton = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case .textDidChange: return nil
		case .textDidBeginEditing: return nil
		case .textDidEndEditing: return nil
		case .bookmarkButtonClicked: return nil
		case .cancelButtonClicked: return nil
		case .searchButtonClicked: return nil
		case .resultsListButtonClicked: return nil
		case .selectedScopeButtonIndexDidChange: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		case .shouldChangeText: return nil
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SearchBar.Preparer {
	class Storage: View.Preparer.Storage, UISearchBarDelegate {}
	
	class Delegate: DynamicDelegate, UISearchBarDelegate {
		func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
			multiHandler(searchBar, searchText)
		}
		
		func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		func searchBarSelectedScopeButtonIndexDidChange(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
			multiHandler(searchBar, selectedScope)
		}
		
		func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
			return singleHandler(searchBar)
		}
		
		func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
			return singleHandler(searchBar)
		}
		
		func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return singleHandler(searchBar, range, text)
		}
		
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SearchBarBinding {
	typealias SearchBarName<V> = BindingName<V, SearchBar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SearchBar.Binding) -> SearchBarName<V> {
		return SearchBarName<V>(source: source, downcast: Binding.searchBarBinding)
	}
}
extension BindingName where Binding: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SearchBarName<$2> { return .name(SearchBar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: SearchBarName<Constant<TextInputTraits>> { return .name(SearchBar.Binding.textInputTraits) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: SearchBarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(SearchBar.Binding.backgroundImage) }
	static var barStyle: SearchBarName<Dynamic<UIBarStyle>> { return .name(SearchBar.Binding.barStyle) }
	static var image: SearchBarName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>> { return .name(SearchBar.Binding.image) }
	static var inputAccessoryView: SearchBarName<Dynamic<UIView?>> { return .name(SearchBar.Binding.inputAccessoryView) }
	static var isTranslucent: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.isTranslucent) }
	static var placeholder: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.placeholder) }
	static var positionAdjustment: SearchBarName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>> { return .name(SearchBar.Binding.positionAdjustment) }
	static var prompt: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.prompt) }
	static var scopeBarButtonBackgroundImage: SearchBarName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(SearchBar.Binding.scopeBarButtonBackgroundImage) }
	static var scopeBarButtonDividerImage: SearchBarName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>> { return .name(SearchBar.Binding.scopeBarButtonDividerImage) }
	static var scopeBarButtonTitleTextAttributes: SearchBarName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>> { return .name(SearchBar.Binding.scopeBarButtonTitleTextAttributes) }
	static var scopeButtonTitles: SearchBarName<Dynamic<[String]?>> { return .name(SearchBar.Binding.scopeButtonTitles) }
	static var searchFieldBackgroundImage: SearchBarName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(SearchBar.Binding.searchFieldBackgroundImage) }
	static var searchFieldBackgroundPositionAdjustment: SearchBarName<Dynamic<UIOffset>> { return .name(SearchBar.Binding.searchFieldBackgroundPositionAdjustment) }
	static var searchTextPositionAdjustment: SearchBarName<Dynamic<UIOffset>> { return .name(SearchBar.Binding.searchTextPositionAdjustment) }
	static var selectedScopeButtonIndex: SearchBarName<Dynamic<Int>> { return .name(SearchBar.Binding.selectedScopeButtonIndex) }
	static var showCancelButton: SearchBarName<Dynamic<SetOrAnimate<Bool>>> { return .name(SearchBar.Binding.showCancelButton) }
	static var showsBookmarkButton: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsBookmarkButton) }
	static var showsScopeBar: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsScopeBar) }
	static var showsSearchResultsButton: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsSearchResultsButton) }
	static var text: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.text) }
	static var tintColor: SearchBarName<Dynamic<UIColor>> { return .name(SearchBar.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var bookmarkButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.bookmarkButtonClicked) }
	static var cancelButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.cancelButtonClicked) }
	static var textDidBeginEditing: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.textDidBeginEditing) }
	static var textDidChange: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.textDidChange) }
	static var textDidEndEditing: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.textDidEndEditing) }
	static var position: SearchBarName<(UIBarPositioning) -> UIBarPosition> { return .name(SearchBar.Binding.position) }
	static var resultsListButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.resultsListButtonClicked) }
	static var searchButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.searchButtonClicked) }
	static var selectedScopeButtonIndexDidChange: SearchBarName<(UISearchBar, Int) -> Void> { return .name(SearchBar.Binding.selectedScopeButtonIndexDidChange) }
	static var shouldBeginEditing: SearchBarName<(UISearchBar) -> Bool> { return .name(SearchBar.Binding.shouldBeginEditing) }
	static var shouldChangeText: SearchBarName<(UISearchBar, NSRange, String) -> Bool> { return .name(SearchBar.Binding.shouldChangeText) }
	static var shouldEndEditing: SearchBarName<(UISearchBar) -> Bool> { return .name(SearchBar.Binding.shouldEndEditing) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> SearchBarName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { searchBar in searchBar.text.map { input.send(value: $0) } } },
			binding: SearchBar.Binding.textDidChange,
			downcast: Binding.searchBarBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SearchBarConvertible: ViewConvertible {
	func uiSearchBar() -> SearchBar.Instance
}
extension SearchBarConvertible {
	func uiView() -> View.Instance { return uiSearchBar() }
}
extension UISearchBar: SearchBarConvertible, HasDelegate {
	func uiSearchBar() -> SearchBar.Instance { return self }
}
extension SearchBar {
	func uiSearchBar() -> SearchBar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SearchBarBinding: ViewBinding {
	static func searchBarBinding(_ binding: SearchBar.Binding) -> Self
}
extension SearchBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return searchBarBinding(.inheritedBinding(binding))
	}
}
extension SearchBar.Binding {
	typealias Preparer = SearchBar.Preparer
	static func searchBarBinding(_ binding: SearchBar.Binding) -> SearchBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct LeftRightControlState {
	let left: UIControl.State
	let right: UIControl.State
	init(left: UIControl.State = .normal, right: UIControl.State = .normal) {
		self.left = left
		self.right = right
	}
}

struct IconAndControlState {
	let icon: UISearchBar.Icon
	let controlState: UIControl.State
	init(icon: UISearchBar.Icon = .search, state: UIControl.State = .normal) {
		self.icon = icon
		self.controlState = state
	}
}

extension ScopedValues where Scope == LeftRightControlState {
	static func normal(right: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .normal, right: right))
	}
	static func highlighted(right: UIControl.State = .highlighted, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .highlighted, right: right))
	}
	static func disabled(right: UIControl.State = .disabled, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .disabled, right: right))
	}
	static func selected(right: UIControl.State = .selected, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .selected, right: right))
	}
	static func focused(right: UIControl.State = .focused, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .focused, right: right))
	}
	static func application(right: UIControl.State = .application, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .application, right: right))
	}
	static func reserved(right: UIControl.State = .reserved, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .reserved, right: right))
	}
}

extension ScopedValues where Scope == IconAndControlState {
	static func search(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .search, state: state))
	}
	static func clear(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .clear, state: state))
	}
	static func bookmark(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .bookmark, state: state))
	}
	static func resultsList(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .resultsList, state: state))
	}
}

extension ScopedValues where Scope == UISearchBar.Icon {
	static func search(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .search)
	}
	static func clear(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .clear)
	}
	static func bookmark(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .bookmark)
	}
	static func resultsList(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .resultsList)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Slider: Binder, SliderConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Slider {
	enum Binding: SliderBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isContinuous(Dynamic<Bool>)
		case maximumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case maximumTrackTintColor(Dynamic<UIColor?>)
		case maximumValue(Dynamic<Float>)
		case maximumValueImage(Dynamic<UIImage?>)
		case minimumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case minimumTrackTintColor(Dynamic<UIColor?>)
		case minimumValue(Dynamic<Float>)
		case minimumValueImage(Dynamic<UIImage?>)
		case thumbImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case thumbTintColor(Dynamic<UIColor?>)
		case value(Dynamic<SetOrAnimate<Float>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Slider {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Slider.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = UISlider
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Slider.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		case .isContinuous(let x): return x.apply(instance) { i, v in i.isContinuous = v }
		case .maximumTrackImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setMaximumTrackImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setMaximumTrackImage(v, for: scope) }
			)
		case .maximumTrackTintColor(let x): return x.apply(instance) { i, v in i.maximumTrackTintColor = v }
		case .maximumValue(let x): return x.apply(instance) { i, v in i.maximumValue = v }
		case .maximumValueImage(let x): return x.apply(instance) { i, v in i.maximumValueImage = v }
		case .minimumTrackImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setMinimumTrackImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setMinimumTrackImage(v, for: scope) }
			)
		case .minimumTrackTintColor(let x): return x.apply(instance) { i, v in i.minimumTrackTintColor = v }
		case .minimumValue(let x): return x.apply(instance) { i, v in i.minimumValue = v }
		case .minimumValueImage(let x): return x.apply(instance) { i, v in i.minimumValueImage = v }
		case .thumbImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setThumbImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setThumbImage(v, for: scope) }
			)
		case .thumbTintColor(let x): return x.apply(instance) { i, v in i.thumbTintColor = v }
		case .value(let x): return x.apply(instance) { i, v in i.setValue(v.value, animated: v.isAnimated) }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Slider.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SliderBinding {
	typealias SliderName<V> = BindingName<V, Slider.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Slider.Binding) -> SliderName<V> {
		return SliderName<V>(source: source, downcast: Binding.sliderBinding)
	}
}
extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SliderName<$2> { return .name(Slider.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isContinuous: SliderName<Dynamic<Bool>> { return .name(Slider.Binding.isContinuous) }
	static var maximumTrackImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.maximumTrackImage) }
	static var maximumTrackTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.maximumTrackTintColor) }
	static var maximumValue: SliderName<Dynamic<Float>> { return .name(Slider.Binding.maximumValue) }
	static var maximumValueImage: SliderName<Dynamic<UIImage?>> { return .name(Slider.Binding.maximumValueImage) }
	static var minimumTrackImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.minimumTrackImage) }
	static var minimumTrackTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.minimumTrackTintColor) }
	static var minimumValue: SliderName<Dynamic<Float>> { return .name(Slider.Binding.minimumValue) }
	static var minimumValueImage: SliderName<Dynamic<UIImage?>> { return .name(Slider.Binding.minimumValueImage) }
	static var thumbImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.thumbImage) }
	static var thumbTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.thumbTintColor) }
	static var value: SliderName<Dynamic<SetOrAnimate<Float>>> { return .name(Slider.Binding.value) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SliderConvertible: ControlConvertible {
	func uiSlider() -> Slider.Instance
}
extension SliderConvertible {
	func uiControl() -> Control.Instance { return uiSlider() }
}
extension UISlider: SliderConvertible {
	func uiSlider() -> Slider.Instance { return self }
}
extension Slider {
	func uiSlider() -> Slider.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
}
extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}
extension Slider.Binding {
	typealias Preparer = Slider.Preparer
	static func sliderBinding(_ binding: Slider.Binding) -> Slider.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class SplitViewController: Binder, SplitViewControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension SplitViewController {
	enum Binding: SplitViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case backgroundView(Constant<View>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumPrimaryColumnWidth(Dynamic<CGFloat>)
		case minimumPrimaryColumnWidth(Dynamic<CGFloat>)
		case preferredDisplayMode(Dynamic<UISplitViewController.DisplayMode>)
		case preferredPrimaryColumnWidthFraction(Dynamic<CGFloat>)
		case presentsWithGesture(Dynamic<Bool>)
		case primaryViewController(Dynamic<ViewControllerConvertible>)
		case secondaryViewController(Dynamic<ViewControllerConvertible>)
		case shouldShowSecondary(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case dismissedSecondary(SignalInput<Void>)
		case displayModeButton(SignalInput<BarButtonItemConvertible?>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case collapseSecondary((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)
		case preferredInterfaceOrientation((UISplitViewController) -> UIInterfaceOrientation)
		case primaryViewControllerForCollapsing((UISplitViewController) -> UIViewController?)
		case primaryViewControllerForExpanding((UISplitViewController) -> UIViewController?)
		case separateSecondary((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)
		case showPrimaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case showSecondaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case supportedInterfaceOrientations((UISplitViewController) -> UIInterfaceOrientationMask)
		case targetDisplayModeForAction((UISplitViewController) -> UISplitViewController.DisplayMode)
		case willChangeDisplayMode((UISplitViewController, UISplitViewController.DisplayMode) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension SplitViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = SplitViewController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = UISplitViewController
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage(displayModeButton: displayModeButton, dismissedSecondary: dismissedSecondary) }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var primary = InitialSubsequent<ViewControllerConvertible>()
		var secondary = InitialSubsequent<ViewControllerConvertible>()
		var displayModeButton: MultiOutput<BarButtonItemConvertible?>?
		var dismissedSecondary: MultiOutput<Void>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension SplitViewController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance { return type.init(nibName: nil, bundle: nil) }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .collapseSecondary(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:collapseSecondary:onto:)))
		case .preferredInterfaceOrientation(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.splitViewControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .primaryViewController(let x): primary = x.initialSubsequent()
		case .primaryViewControllerForCollapsing(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.primaryViewController(forCollapsing:)))
		case .primaryViewControllerForExpanding(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.primaryViewController(forExpanding:)))
		case .secondaryViewController(let x): secondary = x.initialSubsequent()
		case .separateSecondary(let x): delegate().addSingleHandler2(x, #selector(UISplitViewControllerDelegate.splitViewController(_:separateSecondaryFrom:)))
		case .showPrimaryViewController(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:show:sender:)))
		case .showSecondaryViewController(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:showDetail:sender:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.splitViewControllerSupportedInterfaceOrientations(_:)))
		case .targetDisplayModeForAction(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.targetDisplayModeForAction(in:)))
		case .willChangeDisplayMode(let x): delegate().addMultiHandler2(x, #selector(UISplitViewControllerDelegate.splitViewController(_:willChangeTo:)))
		case .dismissedSecondary(let x):
			dismissedSecondary = dismissedSecondary ?? Input().multicast()
			dismissedSecondary?.signal.bind(to: x)
		case .displayModeButton(let x):
			displayModeButton = displayModeButton ?? Input().multicast()
			displayModeButton?.signal.bind(to: x)
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.secondaryViewController = secondary.initial?.uiViewController()
		instance.viewControllers = [primary.initial?.uiViewController() ?? UIViewController()]
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .backgroundView(let v):
			v.value.apply(to: instance.view)
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .maximumPrimaryColumnWidth(let x): return x.apply(instance) { i, v in i.maximumPrimaryColumnWidth = v }
		case .minimumPrimaryColumnWidth(let x): return x.apply(instance) { i, v in i.minimumPrimaryColumnWidth = v }
		case .preferredDisplayMode(let x): return x.apply(instance) { i, v in i.preferredDisplayMode = v }
		case .preferredPrimaryColumnWidthFraction(let x): return x.apply(instance) { i, v in i.preferredPrimaryColumnWidthFraction = v }
		case .presentsWithGesture(let x): return x.apply(instance) { i, v in i.presentsWithGesture = v }
		case .primaryViewController: return primary.resume()?.apply(instance) { i, v in i.show(v.uiViewController(), sender: nil) }
		case .secondaryViewController:
			return secondary.resume()?.apply(instance, storage) { i, s, v in
				let vc = v.uiViewController()
				s.secondaryViewController = vc
				i.showDetailViewController(vc, sender: nil)
			}
		case .shouldShowSecondary(let x):
			return x.apply(instance, storage) { i, s, v in
				if v == true && s.shouldShowSecondary == false, let svc = s.secondaryViewController {
					i.showDetailViewController(svc, sender: nil)
				}
				s.shouldShowSecondary = v
			}

		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .dismissedSecondary: return nil
		case .displayModeButton: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .collapseSecondary: return nil
		case .preferredInterfaceOrientation: return nil
		case .primaryViewControllerForCollapsing: return nil
		case .primaryViewControllerForExpanding: return nil
		case .separateSecondary: return nil
		case .showPrimaryViewController: return nil
		case .showSecondaryViewController: return nil
		case .supportedInterfaceOrientations: return nil
		case .targetDisplayModeForAction: return nil
		case .willChangeDisplayMode: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		if !instance.isCollapsed {
			storage.displayModeButton?.input.send(value: instance.displayModeButtonItem)
		}
		if let secondary = storage.secondaryViewController {
			instance.viewControllers.append(secondary)
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SplitViewController.Preparer {
	class Storage: ViewController.Preparer.Storage, UISplitViewControllerDelegate {
		var secondaryViewController: UIViewController? = nil
		var shouldShowSecondary: Bool = true
		let dismissedSecondary: MultiOutput<Void>?
		let displayModeButton: MultiOutput<BarButtonItemConvertible?>?
		
		init(displayModeButton: MultiOutput<BarButtonItemConvertible?>?, dismissedSecondary: MultiOutput<Void>?) {
			self.dismissedSecondary = dismissedSecondary
			self.displayModeButton = displayModeButton
			super.init()
		}
		
		override var isInUse: Bool {
			return true
		}
		
		func collapsedController(_ controller: UINavigationController) {
			if let svc = secondaryViewController, svc === controller {
				dismissedSecondary?.input.send(value: ())
			}
		}

		func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
			displayModeButton?.input.send(value: nil)

			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UISplitViewControllerDelegate.splitViewController(_:collapseSecondary:onto:))) {
				return ((dd as? UISplitViewControllerDelegate)?.splitViewController?(splitViewController, collapseSecondary: secondaryViewController, onto: primaryViewController) ?? false) || !shouldShowSecondary
			}
			return !shouldShowSecondary
		}
		
		func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			displayModeButton?.input.send(value: splitViewController.displayModeButtonItem)

			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UISplitViewControllerDelegate.splitViewController(_:separateSecondaryFrom:))) {
				return (dd as? UISplitViewControllerDelegate)?.splitViewController?(splitViewController, separateSecondaryFrom: primaryViewController)
			}
			return nil
		}
	}

	class Delegate: DynamicDelegate, UISplitViewControllerDelegate {
		func splitViewController(_ svc: UISplitViewController, willChangeTo displayMode: UISplitViewController.DisplayMode) {
			multiHandler(svc, displayMode)
		}
		
		func targetDisplayModeForAction(in svc: UISplitViewController) -> UISplitViewController.DisplayMode {
			return singleHandler(svc)
		}
		
		func splitViewControllerPreferredInterfaceOrientationForPresentation(_ splitViewController: UISplitViewController) -> UIInterfaceOrientation {
			return singleHandler(splitViewController)
		}
		
		func splitViewControllerSupportedInterfaceOrientations(_ splitViewController: UISplitViewController) -> UIInterfaceOrientationMask {
			return singleHandler(splitViewController)
		}
		
		func primaryViewController(forCollapsing splitViewController: UISplitViewController) -> UIViewController? {
			return singleHandler(splitViewController)
		}
		
		func primaryViewController(forExpanding splitViewController: UISplitViewController) -> UIViewController? {
			return singleHandler(splitViewController)
		}
		
		func splitViewController(_ splitViewController: UISplitViewController, show vc: UIViewController, sender: Any?) -> Bool {
			return singleHandler(splitViewController, vc, sender)
		}
		
		func splitViewController(_ splitViewController: UISplitViewController, showDetail vc: UIViewController, sender: Any?) -> Bool {
			return singleHandler(splitViewController, vc, sender)
		}

		func splitViewController(_ splitViewController: UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool {
			return singleHandler(splitViewController, secondaryViewController, ontoPrimaryViewController)
		}
		
		func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			return singleHandler(splitViewController, primaryViewController)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SplitViewControllerBinding {
	typealias SplitViewControllerName<V> = BindingName<V, SplitViewController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SplitViewController.Binding) -> SplitViewControllerName<V> {
		return SplitViewControllerName<V>(source: source, downcast: Binding.splitViewControllerBinding)
	}
}
extension BindingName where Binding: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SplitViewControllerName<$2> { return .name(SplitViewController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var backgroundView: SplitViewControllerName<Constant<View>> { return .name(SplitViewController.Binding.backgroundView) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumPrimaryColumnWidth: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.maximumPrimaryColumnWidth) }
	static var minimumPrimaryColumnWidth: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.minimumPrimaryColumnWidth) }
	static var preferredDisplayMode: SplitViewControllerName<Dynamic<UISplitViewController.DisplayMode>> { return .name(SplitViewController.Binding.preferredDisplayMode) }
	static var preferredPrimaryColumnWidthFraction: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.preferredPrimaryColumnWidthFraction) }
	static var presentsWithGesture: SplitViewControllerName<Dynamic<Bool>> { return .name(SplitViewController.Binding.presentsWithGesture) }
	static var primaryViewController: SplitViewControllerName<Dynamic<ViewControllerConvertible>> { return .name(SplitViewController.Binding.primaryViewController) }
	static var secondaryViewController: SplitViewControllerName<Dynamic<ViewControllerConvertible>> { return .name(SplitViewController.Binding.secondaryViewController) }
	static var shouldShowSecondary: SplitViewControllerName<Dynamic<Bool>> { return .name(SplitViewController.Binding.shouldShowSecondary) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var dismissedSecondary: SplitViewControllerName<SignalInput<Void>> { return .name(SplitViewController.Binding.dismissedSecondary) }
	static var displayModeButton: SplitViewControllerName<SignalInput<BarButtonItemConvertible?>> { return .name(SplitViewController.Binding.displayModeButton) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var collapseSecondary: SplitViewControllerName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool> { return .name(SplitViewController.Binding.collapseSecondary) }
	static var preferredInterfaceOrientation: SplitViewControllerName<(UISplitViewController) -> UIInterfaceOrientation> { return .name(SplitViewController.Binding.preferredInterfaceOrientation) }
	static var primaryViewControllerForCollapsing: SplitViewControllerName<(UISplitViewController) -> UIViewController?> { return .name(SplitViewController.Binding.primaryViewControllerForCollapsing) }
	static var primaryViewControllerForExpanding: SplitViewControllerName<(UISplitViewController) -> UIViewController?> { return .name(SplitViewController.Binding.primaryViewControllerForExpanding) }
	static var separateSecondary: SplitViewControllerName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?> { return .name(SplitViewController.Binding.separateSecondary) }
	static var showPrimaryViewController: SplitViewControllerName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> { return .name(SplitViewController.Binding.showPrimaryViewController) }
	static var showSecondaryViewController: SplitViewControllerName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> { return .name(SplitViewController.Binding.showSecondaryViewController) }
	static var supportedInterfaceOrientations: SplitViewControllerName<(UISplitViewController) -> UIInterfaceOrientationMask> { return .name(SplitViewController.Binding.supportedInterfaceOrientations) }
	static var targetDisplayModeForAction: SplitViewControllerName<(UISplitViewController) -> UISplitViewController.DisplayMode> { return .name(SplitViewController.Binding.targetDisplayModeForAction) }
	static var willChangeDisplayMode: SplitViewControllerName<(UISplitViewController, UISplitViewController.DisplayMode) -> Void> { return .name(SplitViewController.Binding.willChangeDisplayMode) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SplitViewControllerConvertible: ViewControllerConvertible {
	func uiSplitViewController() -> SplitViewController.Instance
}
extension SplitViewControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiSplitViewController() }
}
extension UISplitViewController: SplitViewControllerConvertible, HasDelegate {
	func uiSplitViewController() -> SplitViewController.Instance { return self }
}
extension SplitViewController {
	func uiSplitViewController() -> SplitViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SplitViewControllerBinding: ViewControllerBinding {
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> Self
}
extension SplitViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return splitViewControllerBinding(.inheritedBinding(binding))
	}
}
extension SplitViewController.Binding {
	typealias Preparer = SplitViewController.Preparer
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> SplitViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class SwipeGestureRecognizer: Binder, SwipeGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension SwipeGestureRecognizer {
	enum Binding: SwipeGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case direction(Dynamic<UISwipeGestureRecognizer.Direction>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension SwipeGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = SwipeGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UISwipeGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension SwipeGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .direction(let x): return x.apply(instance) { i, v in i.direction = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SwipeGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SwipeGestureRecognizerBinding {
	typealias SwipeGestureRecognizerName<V> = BindingName<V, SwipeGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SwipeGestureRecognizer.Binding) -> SwipeGestureRecognizerName<V> {
		return SwipeGestureRecognizerName<V>(source: source, downcast: Binding.swipeGestureRecognizerBinding)
	}
}
extension BindingName where Binding: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SwipeGestureRecognizerName<$2> { return .name(SwipeGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var direction: SwipeGestureRecognizerName<Dynamic<UISwipeGestureRecognizer.Direction>> { return .name(SwipeGestureRecognizer.Binding.direction) }
	static var numberOfTouchesRequired: SwipeGestureRecognizerName<Dynamic<Int>> { return .name(SwipeGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SwipeGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance
}
extension SwipeGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiSwipeGestureRecognizer() }
}
extension UISwipeGestureRecognizer: SwipeGestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return self }
}
extension SwipeGestureRecognizer {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SwipeGestureRecognizerBinding: GestureRecognizerBinding {
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> Self
}
extension SwipeGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return swipeGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension SwipeGestureRecognizer.Binding {
	typealias Preparer = SwipeGestureRecognizer.Preparer
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> SwipeGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Switch: Binder, SwitchConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Switch {
	enum Binding: SwitchBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isOn(Dynamic<SetOrAnimate<Bool>>)
		case offImage(Dynamic<UIImage?>)
		case onImage(Dynamic<UIImage?>)
		case onTintColor(Dynamic<UIColor>)
		case thumbTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Switch {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Switch.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = UISwitch
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Switch.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .isOn(let x): return x.apply(instance) { i, v in i.setOn(v.value, animated: v.isAnimated) }
		case .offImage(let x): return x.apply(instance) { i, v in i.offImage = v }
		case .onImage(let x): return x.apply(instance) { i, v in i.onImage = v }
		case .onTintColor(let x): return x.apply(instance) { i, v in i.onTintColor = v }
		case .thumbTintColor(let x): return x.apply(instance) { i, v in i.thumbTintColor = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Switch.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SwitchBinding {
	typealias SwitchName<V> = BindingName<V, Switch.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Switch.Binding) -> SwitchName<V> {
		return SwitchName<V>(source: source, downcast: Binding.switchBinding)
	}
}
extension BindingName where Binding: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SwitchName<$2> { return .name(Switch.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isOn: SwitchName<Dynamic<SetOrAnimate<Bool>>> { return .name(Switch.Binding.isOn) }
	static var offImage: SwitchName<Dynamic<UIImage?>> { return .name(Switch.Binding.offImage) }
	static var onImage: SwitchName<Dynamic<UIImage?>> { return .name(Switch.Binding.onImage) }
	static var onTintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.onTintColor) }
	static var thumbTintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.thumbTintColor) }
	static var tintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SwitchConvertible: ControlConvertible {
	func uiSwitch() -> Switch.Instance
}
extension SwitchConvertible {
	func uiControl() -> Control.Instance { return uiSwitch() }
}
extension UISwitch: SwitchConvertible {
	func uiSwitch() -> Switch.Instance { return self }
}
extension Switch {
	func uiSwitch() -> Switch.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SwitchBinding: ControlBinding {
	static func switchBinding(_ binding: Switch.Binding) -> Self
}
extension SwitchBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return switchBinding(.inheritedBinding(binding))
	}
}
extension Switch.Binding {
	typealias Preparer = Switch.Preparer
	static func switchBinding(_ binding: Switch.Binding) -> Switch.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TabBarController<ItemIdentifier: Hashable>: Binder, TabBarControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TabBarController {
	enum Binding: TabBarControllerBinding {
		typealias ItemIdentifierType = ItemIdentifier
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tabBar(Constant<TabBar<ItemIdentifier>>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case customizableItems(Dynamic<Set<ItemIdentifier>>)
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationControllerForTransition((UITabBarController, UIViewController, ItemIdentifier, UIViewController, ItemIdentifier) -> UIViewControllerAnimatedTransitioning?)
		case didEndCustomizing((UITabBarController, [UIViewController], [ItemIdentifier], Bool) -> Void)
		case didSelect((UITabBarController, UIViewController, ItemIdentifier) -> Void)
		case interactionControllerForAnimation((UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case preferredInterfaceOrientationForPresentation((UITabBarController) -> UIInterfaceOrientation)
		case shouldSelect((UITabBarController, UIViewController, ItemIdentifier) -> Bool)
		case supportedInterfaceOrientations((UITabBarController) -> UIInterfaceOrientationMask)
		case tabConstructor((ItemIdentifier) -> ViewControllerConvertible)
		case willBeginCustomizing((UITabBarController, [UIViewController], [ItemIdentifier]) -> Void)
		case willEndCustomizing((UITabBarController, [UIViewController], [ItemIdentifier], Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension TabBarController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TabBarController.Binding
		typealias Inherited = ViewController.Preparer
		typealias Instance = UITabBarController
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TabBarController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .animationControllerForTransition(let x): delegate().addSingleHandler5(x, #selector(UITabBarControllerDelegate.tabBarController(_:animationControllerForTransitionFrom:to:)))
		case .didEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:)))
		case .didSelect(let x): delegate().addMultiHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:didSelect:)))
		case .interactionControllerForAnimation(let x): delegate().addSingleHandler2(x, #selector(UITabBarControllerDelegate.tabBarController(_:interactionControllerFor:)))
		case .preferredInterfaceOrientationForPresentation(let x): delegate().addSingleHandler1(x, #selector(UITabBarControllerDelegate.tabBarControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .shouldSelect(let x): delegate().addSingleHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:shouldSelect:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UITabBarControllerDelegate.tabBarControllerSupportedInterfaceOrientations(_:)))
		case .tabConstructor(let x): tabConstructor = x
		case .willBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:)))
		case .willEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.tabConstructor = tabConstructor
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tabBar(let x):
			x.value.apply(to: instance.tabBar)
			return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .customizableItems(let x):
			return x.apply(instance, storage) { i, s, v in
				i.customizableViewControllers = v.compactMap { s.viewController(for: $0) }
			}
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				let items = v.value.compactMap { s.viewController(for: $0) }
				i.setViewControllers(items, animated: v.isAnimated)
			}

		// 2. Signal bindings are performed on the object after construction.
		case .selectItem(let x):
			return x.apply(instance, storage) { i, s, v in
				if let vc = s.viewController(for: v), let index = i.viewControllers?.firstIndex(of: vc) {
					i.selectedIndex = index
				}
			}

		// 3. Action bindings are triggered by the object after construction.
		case .didEndCustomizing: return nil
		case .didSelect: return nil
		case .willBeginCustomizing: return nil
		case .willEndCustomizing: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .animationControllerForTransition: return nil
		case .interactionControllerForAnimation: return nil
		case .preferredInterfaceOrientationForPresentation: return nil
		case .shouldSelect: return nil
		case .supportedInterfaceOrientations: return nil
		case .tabConstructor: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBarController.Preparer {
	class Storage: ViewController.Preparer.Storage, UITabBarControllerDelegate {
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		var allItems: [ItemIdentifier: ViewControllerConvertible] = [:]
		
		override var isInUse: Bool { return true }
		
		func identifier(for viewController: UIViewController) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiViewController() === viewController
			})?.key
		}
		func viewController(for identifier: ItemIdentifier) -> UIViewController? {
			if let existing = allItems[identifier] {
				return existing.uiViewController()
			}
			if let binding = tabConstructor {
				let new = binding(identifier)
				allItems[identifier] = new
				return new.uiViewController()
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarControllerDelegate {
		func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
			guard let identifier = (tabBarController.delegate as? Storage)?.identifier(for: viewController) else { return }
			multiHandler(tabBarController, viewController, identifier)
		}

		func tabBarController(_ tabBarController: UITabBarController, willBeginCustomizing viewControllers: [UIViewController]) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers)
		}

		func tabBarController(_ tabBarController: UITabBarController, didBeginCustomizing viewControllers: [UIViewController]) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers)
		}

		func tabBarController(_ tabBarController: UITabBarController, willEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers, changed)
		}

		func tabBarController(_ tabBarController: UITabBarController, didEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers, changed)
		}
		
		func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
			guard let storage = tabBarController.delegate as? Storage, let identifier = storage.identifier(for: viewController) else { return false }
			return singleHandler(tabBarController, viewController, identifier)
		}
		
		func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask {
			return singleHandler(tabBarController)
		}
		
		func tabBarControllerPreferredInterfaceOrientationForPresentation(_ tabBarController: UITabBarController) -> UIInterfaceOrientation {
			return singleHandler(tabBarController)
		}
		
		func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
			return singleHandler(tabBarController, animationController)
		}
		
		func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			guard let identifierFrom = (tabBarController.delegate as? Storage)?.identifier(for: fromVC) else { return nil }
			guard let identifierTo = (tabBarController.delegate as? Storage)?.identifier(for: toVC) else { return nil }
			return singleHandler(tabBarController, fromVC, identifierFrom, toVC, identifierTo)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarControllerBinding {
	typealias TabBarControllerName<V> = BindingName<V, TabBarController<Binding.ItemIdentifierType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBarController<Binding.ItemIdentifierType>.Binding) -> TabBarControllerName<V> {
		return TabBarControllerName<V>(source: source, downcast: Binding.tabBarControllerBinding)
	}
}
extension BindingName where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarControllerName<$2> { return .name(TabBarController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tabBar: TabBarControllerName<Constant<TabBar<Binding.ItemIdentifierType>>> { return .name(TabBarController.Binding.tabBar) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var customizableItems: TabBarControllerName<Dynamic<Set<Binding.ItemIdentifierType>>> { return .name(TabBarController.Binding.customizableItems) }
	static var items: TabBarControllerName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> { return .name(TabBarController.Binding.items) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectItem: TabBarControllerName<Signal<Binding.ItemIdentifierType>> { return .name(TabBarController.Binding.selectItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationControllerForTransition: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType, UIViewController, Binding.ItemIdentifierType) -> UIViewControllerAnimatedTransitioning?> { return .name(TabBarController.Binding.animationControllerForTransition) }
	static var didEndCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBarController.Binding.didEndCustomizing) }
	static var didSelect: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Void> { return .name(TabBarController.Binding.didSelect) }
	static var interactionControllerForAnimation: TabBarControllerName<(UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> { return .name(TabBarController.Binding.interactionControllerForAnimation) }
	static var preferredInterfaceOrientationForPresentation: TabBarControllerName<(UITabBarController) -> UIInterfaceOrientation> { return .name(TabBarController.Binding.preferredInterfaceOrientationForPresentation) }
	static var shouldSelect: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Bool> { return .name(TabBarController.Binding.shouldSelect) }
	static var supportedInterfaceOrientations: TabBarControllerName<(UITabBarController) -> UIInterfaceOrientationMask> { return .name(TabBarController.Binding.supportedInterfaceOrientations) }
	static var tabConstructor: TabBarControllerName<(Binding.ItemIdentifierType) -> ViewControllerConvertible> { return .name(TabBarController.Binding.tabConstructor) }
	static var willBeginCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBarController.Binding.willBeginCustomizing) }
	static var willEndCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBarController.Binding.willEndCustomizing) }
	
	// Composite binding names
	static func tabSelected(_ void: Void = ()) -> TabBarControllerName<SignalInput<Binding.ItemIdentifierType>> {
		return Binding.compositeName(
			value: { input in { tabBarcontroller, vc, i -> Void in input.send(value: i) } },
			binding: TabBarController.Binding.didSelect,
			downcast: Binding.tabBarControllerBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TabBarControllerConvertible: ViewControllerConvertible {
	func uiTabBarController() -> UITabBarController
}
extension TabBarControllerConvertible {
	func uiViewController() -> ViewController.Instance { return uiTabBarController() }
}
extension UITabBarController: TabBarControllerConvertible, HasDelegate {
	func uiTabBarController() -> UITabBarController { return self }
}
extension TabBarController {
	func uiTabBarController() -> UITabBarController { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TabBarControllerBinding: ViewControllerBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> Self
}
extension TabBarControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return tabBarControllerBinding(TabBarController<ItemIdentifierType>.Binding.inheritedBinding(binding))
	}
}
extension TabBarController.Binding {
	typealias Preparer = TabBarController.Preparer
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> TabBarController<ItemIdentifierType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TabBarItem: Binder, TabBarItemConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TabBarItem {
	enum Binding: TabBarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UITabBarItem.SystemItem?>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case badgeColor(Dynamic<UIColor?>)
		case badgeTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>)
		case badgeValue(Dynamic<String?>)
		case selectedImage(Dynamic<UIImage?>)
		case titlePositionAdjustment(Dynamic<UIOffset>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TabBarItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TabBarItem.Binding
		typealias Inherited = BarItem.Preparer
		typealias Instance = UITabBarItem
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var systemItem: UITabBarItem.SystemItem?
		var title = InitialSubsequent<String>()
		var image = InitialSubsequent<UIImage?>()
		var selectedImage = InitialSubsequent<UIImage?>()
		var tag = InitialSubsequent<Int>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TabBarItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		let x: UITabBarItem
		if let si = systemItem {
			x = type.init(tabBarSystemItem: si, tag: tag.initial ?? 0)
		} else if let si = selectedImage.initial {
			x = type.init(title: title.initial ?? nil, image: image.initial ?? nil, selectedImage: si)
		} else {
			x = type.init(title: title.initial ?? nil, image: image.initial ?? nil, tag: tag.initial ?? 0)
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.image(let x)): image = x.initialSubsequent()
		case .inheritedBinding(.tag(let x)): tag = x.initialSubsequent()
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .selectedImage(let x): selectedImage = x.initialSubsequent()
		case .systemItem(let x): systemItem = x.value
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.tag): return tag.resume()?.apply(instance) { i, v in i.tag = v }
		case .inheritedBinding(.image): return image.resume()?.apply(instance) { i, v in i.image = v }
		case .inheritedBinding(.title): return title.resume()?.apply(instance) { i, v in i.title = v }
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		case .systemItem: return nil
		
		case .badgeValue(let x): return x.apply(instance) { i, v in i.badgeValue = v }
		case .selectedImage: return selectedImage.resume()?.apply(instance) { i, v in i.selectedImage = v }
		case .titlePositionAdjustment(let x): return x.apply(instance) { i, v in i.titlePositionAdjustment = v }
		
		case .badgeColor(let x): return x.apply(instance) { i, v in i.badgeColor = v }
		case .badgeTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBadgeTextAttributes(nil, for: scope) },
				applyNew: { i, scope, v in i.setBadgeTextAttributes(v, for: scope) }
			)
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBarItem.Preparer {
	typealias Storage = BarItem.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarItemBinding {
	typealias TabBarItemName<V> = BindingName<V, TabBarItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBarItem.Binding) -> TabBarItemName<V> {
		return TabBarItemName<V>(source: source, downcast: Binding.tabBarItemBinding)
	}
}
extension BindingName where Binding: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarItemName<$2> { return .name(TabBarItem.Binding.$1) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TabBarItemConvertible: BarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance
}
extension TabBarItemConvertible {
	func uiBarItem() -> BarItem.Instance { return uiTabBarItem() }
}
extension UITabBarItem: TabBarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance { return self }
}
extension TabBarItem {
	func uiTabBarItem() -> TabBarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TabBarItemBinding: BarItemBinding {
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> Self
}
extension TabBarItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return tabBarItemBinding(.inheritedBinding(binding))
	}
}
extension TabBarItem.Binding {
	typealias Preparer = TabBarItem.Preparer
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> TabBarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TabBar<ItemIdentifier: Hashable>: Binder, TabBarConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TabBar {
	enum Binding: TabBarBinding {
		typealias ItemIdentifierType = ItemIdentifier
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor>)
		case isTranslucent(Dynamic<Bool>)
		case itemPositioning(Dynamic<UITabBar.ItemPositioning>)
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case itemSpacing(Dynamic<CGFloat>)
		case itemWidth(Dynamic<CGFloat>)
		case selectionIndicatorImage(Dynamic<UIImage?>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor>)
		case unselectedItemTintColor(Dynamic<UIColor>)

		// 2. Signal bindings are performed on the object after construction.
		case customizingItems(Signal<SetOrAnimate<[ItemIdentifier]?>>)
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier]) -> Void)
		case didEndCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier], Bool) -> Void)
		case didSelectItem((UITabBar, UITabBarItem, ItemIdentifier) -> Void)
		case itemConstructor((ItemIdentifier) -> TabBarItemConvertible)
		case willBeginCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier]) -> Void)
		case willEndCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier], Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension TabBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TabBar.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UITabBar
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TabBar.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		case .didBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:)))
		case .didEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:)))
		case .didSelectItem(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:didSelect:)))
		case .itemConstructor(let x): tabBarItemConstructor = x
		case .willBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:)))
		case .willEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.tabBarItemConstructor = tabBarItemConstructor
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x): return x.apply(instance) { i, v in i.backgroundImage = v }
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .itemPositioning(let x): return x.apply(instance) { i, v in i.itemPositioning = v }
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				let items = v.value.compactMap { s.tabBarItem(for: $0) }
				i.setItems(items, animated: v.isAnimated)
			}
		case .itemSpacing(let x): return x.apply(instance) { i, v in i.itemSpacing = v }
		case .itemWidth(let x): return x.apply(instance) { i, v in i.itemWidth = v }
		case .selectionIndicatorImage(let x): return x.apply(instance) { i, v in i.selectionIndicatorImage = v }
		case .shadowImage(let x): return x.apply(instance) { i, v in i.shadowImage = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }

		case .unselectedItemTintColor(let x): return x.apply(instance) { i, v in i.unselectedItemTintColor = v }

		// 2. Signal bindings are performed on the object after construction.
		case .customizingItems(let x): return x.apply(instance, storage) { i, s, v in
			if let v = v.value {
				let items = v.compactMap { s.tabBarItem(for: $0) }
				i.beginCustomizingItems(items)
			} else {
				i.endCustomizing(animated: v.isAnimated)
			}
		}
		case .selectItem(let x): return x.apply(instance, storage) { i, s, v in i.selectedItem = s.tabBarItem(for: v) }

		// 3. Action bindings are triggered by the object after construction.
		case .didBeginCustomizing: return nil
		case .didEndCustomizing: return nil
		case .didSelectItem: return nil
		case .willBeginCustomizing: return nil
		case .willEndCustomizing: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .itemConstructor: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBar.Preparer {
	class Storage: View.Preparer.Storage, UITabBarDelegate {
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
		var allItems: [ItemIdentifier: TabBarItemConvertible] = [:]
		
		override var isInUse: Bool { return true }
		
		func identifier(for tabBarItem: UITabBarItem) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiTabBarItem() === tabBarItem
			})?.key
		}
		func tabBarItem(for identifier: ItemIdentifier) -> UITabBarItem? {
			if let existing = allItems[identifier] {
				return existing.uiTabBarItem()
			}
			if let binding = tabBarItemConstructor {
				let new = binding(identifier)
				allItems[identifier] = new
				return new.uiTabBarItem()
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarDelegate {
		func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
			guard let identifier = (tabBar.delegate as? Storage)?.identifier(for: item) else { return }
			multiHandler(tabBar, item, identifier)
		}

		func tabBar(_ tabBar: UITabBar, willBeginCustomizing items: [UITabBarItem]) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers)
		}

		func tabBar(_ tabBar: UITabBar, didBeginCustomizing items: [UITabBarItem]) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers)
		}

		func tabBar(_ tabBar: UITabBar, willEndCustomizing items: [UITabBarItem], changed: Bool) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers, changed)
		}

		func tabBar(_ tabBar: UITabBar, didEndCustomizing items: [UITabBarItem], changed: Bool) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers, changed)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarBinding {
	typealias TabBarName<V> = BindingName<V, TabBar<Binding.ItemIdentifierType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBar<Binding.ItemIdentifierType>.Binding) -> TabBarName<V> {
		return TabBarName<V>(source: source, downcast: Binding.tabBarBinding)
	}
}
extension BindingName where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarName<$2> { return .name(TabBar.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.backgroundImage) }
	static var barStyle: TabBarName<Dynamic<UIBarStyle>> { return .name(TabBar.Binding.barStyle) }
	static var barTintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.barTintColor) }
	static var isTranslucent: TabBarName<Dynamic<Bool>> { return .name(TabBar.Binding.isTranslucent) }
	static var itemPositioning: TabBarName<Dynamic<UITabBar.ItemPositioning>> { return .name(TabBar.Binding.itemPositioning) }
	static var items: TabBarName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> { return .name(TabBar.Binding.items) }
	static var itemSpacing: TabBarName<Dynamic<CGFloat>> { return .name(TabBar.Binding.itemSpacing) }
	static var itemWidth: TabBarName<Dynamic<CGFloat>> { return .name(TabBar.Binding.itemWidth) }
	static var selectionIndicatorImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.selectionIndicatorImage) }
	static var shadowImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.shadowImage) }
	static var tintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.tintColor) }
	static var unselectedItemTintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.unselectedItemTintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var customizingItems: TabBarName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>> { return .name(TabBar.Binding.customizingItems) }
	static var selectItem: TabBarName<Signal<Binding.ItemIdentifierType>> { return .name(TabBar.Binding.selectItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBar.Binding.didBeginCustomizing) }
	static var didEndCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBar.Binding.didEndCustomizing) }
	static var didSelectItem: TabBarName<(UITabBar, UITabBarItem, Binding.ItemIdentifierType) -> Void> { return .name(TabBar.Binding.didSelectItem) }
	static var itemConstructor: TabBarName<(Binding.ItemIdentifierType) -> TabBarItemConvertible> { return .name(TabBar.Binding.itemConstructor) }
	static var willBeginCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBar.Binding.willBeginCustomizing) }
	static var willEndCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBar.Binding.willEndCustomizing) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TabBarConvertible: ViewConvertible {
	func uiTabBar() -> UITabBar
}
extension TabBarConvertible {
	func uiView() -> View.Instance { return uiTabBar() }
}
extension UITabBar: TabBarConvertible, HasDelegate {
	func uiTabBar() -> UITabBar { return self }
}
extension TabBar {
	func uiTabBar() -> UITabBar { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TabBarBinding: ViewBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> Self
}
extension TabBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tabBarBinding(TabBar<ItemIdentifierType>.Binding.inheritedBinding(binding))
	}
}
extension TabBar.Binding {
	typealias Preparer = TabBar.Preparer
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> TabBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TableViewCell: Binder, TableViewCellConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}
extension Binder where Preparer.Binding: TableViewCellBinding, Preparer.Parameters == String? {
	init(type: Preparer.Instance.Type = Preparer.Instance.self, reuseIdentifier: String? = nil, _ bindings: Preparer.Binding...) {
		self.init(type: type, parameters: reuseIdentifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableViewCell {
	enum Binding: TableViewCellBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case cellStyle(Constant<UITableViewCell.CellStyle>)
		case contentView(Constant<View>)
		case detailLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
		case textLabel(Constant<Label>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case accessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case accessoryView(Dynamic<ViewConvertible>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case editingAccessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case editingAccessoryView(Dynamic<ViewConvertible>)
		case focusStyle(Dynamic<UITableViewCell.FocusStyle>)
		case indentationLevel(Dynamic<Int>)
		case indentationWidth(Dynamic<CGFloat>)
		case isEditing(Dynamic<SetOrAnimate<Bool>>)
		case isHighlighted(Dynamic<SetOrAnimate<Bool>>)
		case isSelected(Dynamic<SetOrAnimate<Bool>>)
		case multipleSelectionBackgroundView(Dynamic<ViewConvertible?>)
		case selectedBackgroundView(Dynamic<ViewConvertible?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case shouldIndentWhileEditing(Dynamic<Bool>)
		case showsReorderControl(Dynamic<Bool>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TableViewCell {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TableViewCell.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UITableViewCell
		typealias Parameters = String?
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var cellStyle: UITableViewCell.CellStyle = .default
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableViewCell.Preparer {
	func constructInstance(type: Instance.Type, parameters: String?) -> Instance {
		return type.init(style: cellStyle, reuseIdentifier: parameters)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .cellStyle(let x): cellStyle = x.value
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .cellStyle: return nil
		case .contentView(let x):
			x.value.apply(to: instance.contentView)
			return nil
		case .detailLabel(let x):
			if let l = instance.detailTextLabel {
				x.value.apply(to: l)
			}
			return nil
		case .imageView(let x):
			if let l = instance.imageView {
				x.value.apply(to: l)
			}
			return nil
		case .textLabel(let x):
			if let l = instance.textLabel {
				x.value.apply(to: l)
			}
			return nil
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .accessoryType(let x): return x.apply(instance) { i, v in i.accessoryType = v }
		case .accessoryView(let x): return x.apply(instance) { i, v in i.accessoryView = v.uiView() }
		case .backgroundView(let x): return x.apply(instance) { i, v in i.backgroundView = v?.uiView() }
		case .editingAccessoryType(let x): return x.apply(instance) { i, v in i.editingAccessoryType = v }
		case .editingAccessoryView(let x): return x.apply(instance) { i, v in i.editingAccessoryView = v.uiView() }
		case .focusStyle(let x): return x.apply(instance) { i, v in i.focusStyle = v }
		case .indentationLevel(let x): return x.apply(instance) { i, v in i.indentationLevel = v }
		case .indentationWidth(let x): return x.apply(instance) { i, v in i.indentationWidth = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.setHighlighted(v.value, animated: v.isAnimated) }
		case .isSelected(let x): return x.apply(instance) { i, v in i.setSelected(v.value, animated: v.isAnimated) }
		case .multipleSelectionBackgroundView(let x): return x.apply(instance) { i, v in i.multipleSelectionBackgroundView = v?.uiView() }
		case .selectedBackgroundView(let x): return x.apply(instance) { i, v in i.selectedBackgroundView = v?.uiView() }
		case .separatorInset(let x): return x.apply(instance) { i, v in i.separatorInset = v }
		case .shouldIndentWhileEditing(let x): return x.apply(instance) { i, v in i.shouldIndentWhileEditing = v }
		case .showsReorderControl(let x): return x.apply(instance) { i, v in i.showsReorderControl = v }
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableViewCell.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewCellBinding {
	typealias TableViewCellName<V> = BindingName<V, TableViewCell.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableViewCell.Binding) -> TableViewCellName<V> {
		return TableViewCellName<V>(source: source, downcast: Binding.tableViewCellBinding)
	}
}
extension BindingName where Binding: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewCellName<$2> { return .name(TableViewCell.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: TableViewCellName<Constant<UITableViewCell.CellStyle>> { return .name(TableViewCell.Binding.cellStyle) }
	static var contentView: TableViewCellName<Constant<View>> { return .name(TableViewCell.Binding.contentView) }
	static var detailLabel: TableViewCellName<Constant<Label>> { return .name(TableViewCell.Binding.detailLabel) }
	static var imageView: TableViewCellName<Constant<ImageView>> { return .name(TableViewCell.Binding.imageView) }
	static var textLabel: TableViewCellName<Constant<Label>> { return .name(TableViewCell.Binding.textLabel) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var accessoryType: TableViewCellName<Dynamic<UITableViewCell.AccessoryType>> { return .name(TableViewCell.Binding.accessoryType) }
	static var accessoryView: TableViewCellName<Dynamic<ViewConvertible>> { return .name(TableViewCell.Binding.accessoryView) }
	static var backgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.backgroundView) }
	static var editingAccessoryType: TableViewCellName<Dynamic<UITableViewCell.AccessoryType>> { return .name(TableViewCell.Binding.editingAccessoryType) }
	static var editingAccessoryView: TableViewCellName<Dynamic<ViewConvertible>> { return .name(TableViewCell.Binding.editingAccessoryView) }
	static var focusStyle: TableViewCellName<Dynamic<UITableViewCell.FocusStyle>> { return .name(TableViewCell.Binding.focusStyle) }
	static var indentationLevel: TableViewCellName<Dynamic<Int>> { return .name(TableViewCell.Binding.indentationLevel) }
	static var indentationWidth: TableViewCellName<Dynamic<CGFloat>> { return .name(TableViewCell.Binding.indentationWidth) }
	static var isEditing: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isEditing) }
	static var isHighlighted: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isHighlighted) }
	static var isSelected: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isSelected) }
	static var multipleSelectionBackgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.multipleSelectionBackgroundView) }
	static var selectedBackgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.selectedBackgroundView) }
	static var separatorInset: TableViewCellName<Dynamic<UIEdgeInsets>> { return .name(TableViewCell.Binding.separatorInset) }
	static var shouldIndentWhileEditing: TableViewCellName<Dynamic<Bool>> { return .name(TableViewCell.Binding.shouldIndentWhileEditing) }
	static var showsReorderControl: TableViewCellName<Dynamic<Bool>> { return .name(TableViewCell.Binding.showsReorderControl) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableViewCellConvertible: ViewConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance
}
extension TableViewCellConvertible {
	func uiTableViewCell() -> TableViewCell.Instance { return uiTableViewCell(reuseIdentifier: nil) }
	func uiView() -> View.Instance { return uiTableViewCell() }
}
extension UITableViewCell: TableViewCellConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance { return self }
}
extension TableViewCell {
	func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance { return instance(parameters: reuseIdentifier) }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableViewCellBinding: ViewBinding {
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> Self
}
extension TableViewCellBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableViewCellBinding(.inheritedBinding(binding))
	}
}
extension TableViewCell.Binding {
	typealias Preparer = TableViewCell.Preparer
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> TableViewCell.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
private var associatedInputKey = NSObject()
extension UITableViewCell {
	func associatedRowInput<B>(valueType: B.Type) -> 
		SignalInput<B>? {
			return objc_getAssociatedObject(self, &associatedInputKey) as? SignalInput<B>
	}
	
	func setAssociatedRowInput<B>(to input: SignalInput<B>) {
		objc_setAssociatedObject(self, &associatedInputKey, input, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TableView<RowData>: Binder, TableViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableView {
	enum Binding: TableViewBinding {
		typealias RowDataType = RowData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tableViewStyle(Constant<UITableView.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsMultipleSelectionDuringEditing(Dynamic<Bool>)
		case allowsSelection(Dynamic<Bool>)
		case allowsSelectionDuringEditing(Dynamic<Bool>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case cellLayoutMarginsFollowReadableWidth(Dynamic<Bool>)
		case estimatedRowHeight(Dynamic<CGFloat>)
		case estimatedSectionFooterHeight(Dynamic<CGFloat>)
		case estimatedSectionHeaderHeight(Dynamic<CGFloat>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case remembersLastFocusedIndexPath(Dynamic<Bool>)
		case rowHeight(Dynamic<CGFloat>)
		case sectionFooterHeight(Dynamic<CGFloat>)
		case sectionHeaderHeight(Dynamic<CGFloat>)
		case sectionIndexBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexColor(Dynamic<UIColor?>)
		case sectionIndexMinimumDisplayRowCount(Dynamic<Int>)
		case sectionIndexTitles(Dynamic<[String]?>)
		case sectionIndexTrackingBackgroundColor(Dynamic<UIColor?>)
		case separatorColor(Dynamic<UIColor?>)
		case separatorEffect(Dynamic<UIVisualEffect?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case separatorInsetReference(Dynamic<UITableView.SeparatorInsetReference>)
		case separatorStyle(Dynamic<UITableViewCell.SeparatorStyle>)
		case tableData(Dynamic<TableSectionAnimatable<RowData>>)
		case tableFooterView(Dynamic<ViewConvertible?>)
		case tableHeaderView(Dynamic<ViewConvertible?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case deselectRow(Signal<SetOrAnimate<IndexPath>>)
		case scrollToNearestSelectedRow(Signal<SetOrAnimate<UITableView.ScrollPosition>>)
		case scrollToRow(Signal<SetOrAnimate<TableScrollPosition>>)
		case selectRow(Signal<SetOrAnimate<TableScrollPosition?>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case selectionDidChange(SignalInput<[TableRow<RowData>]?>)
		case userDidScrollToRow(SignalInput<TableRow<RowData>>)
		case visibleRowsChanged(SignalInput<[TableRow<RowData>]>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case accessoryButtonTapped((UITableView, TableRow<RowData>) -> Void)
		case canEditRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canFocusRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canMoveRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canPerformAction((_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)
		case cellConstructor((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)
		case cellIdentifier((TableRow<RowData>) -> String?)
		case commit((UITableView, UITableViewCell.EditingStyle, TableRow<RowData>) -> Void)
		case dataMissingCell((IndexPath) -> TableViewCellConvertible)
		case didDeselectRow((UITableView, TableRow<RowData>) -> Void)
		case didEndDisplayingCell((UITableView, UITableViewCell, TableRow<RowData>) -> Void)
		case didEndDisplayingFooter((UITableView, UIView, Int) -> Void)
		case didEndDisplayingHeader((UITableView, UIView, Int) -> Void)
		case didEndEditingRow((UITableView, TableRow<RowData>?) -> Void)
		case didHightlightRow((UITableView, TableRow<RowData>) -> Void)
		case didSelectRow((UITableView, TableRow<RowData>) -> Void)
		case didUnhighlightRow((UITableView, TableRow<RowData>) -> Void)
		case didUpdateFocus((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)
		case editActionsForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)
		case editingStyleForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)
		case estimatedHeightForFooter((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case estimatedHeightForHeader((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case estimatedHeightForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> CGFloat)
		case footerHeight((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case footerView((_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?)
		case headerHeight((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case headerView((_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?)
		case heightForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> CGFloat)
		case indentationLevelForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Int)
		case indexPathForPreferredFocusedView((UITableView) -> IndexPath)
		case moveRow((UITableView, TableRow<RowData>, IndexPath) -> Void)
		case shouldHighlightRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldIndentWhileEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldShowMenuForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldUpdateFocus((UITableView, UITableViewFocusUpdateContext) -> Bool)
		case targetIndexPathForMoveFromRow((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)
		case titleForDeleteConfirmationButtonForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> String?)
		case willBeginEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)
		case willDeselectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
		case willDisplayFooter((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayHeader((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>, _ cell: UITableViewCell) -> Void)
		case willSelectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
	}
}

// MARK: - Binder Part 3: Preparer
extension TableView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TableView.Binding
		typealias Inherited = ScrollView.Preparer
		typealias Instance = UITableView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage(rowsChanged: rowsChanged, cellIdentifier: cellIdentifier) }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var cellIdentifier: (TableRow<RowData>) -> String? = { _ in nil }
		var rowsChanged: MultiOutput<[TableRow<RowData>]>? = nil
		var tableViewStyle: UITableView.Style = .plain
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(frame: CGRect.zero, style: tableViewStyle)
	}
	
	private static func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
		return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(indexPath.section)?.values?.at(indexPath.row))
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tableViewStyle(let x): tableViewStyle = x.value
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case .userDidScrollToRow(let x):
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in
					guard let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
			)
			delegate().addMultiHandler2(
				{ (sv: UIScrollView, d: Bool) -> Void in
					guard !d, let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
			)
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in
					guard let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
			)
		case .visibleRowsChanged(let x):
			rowsChanged = rowsChanged ?? Input().multicast()
			rowsChanged?.signal.bind(to: x)
			delegate().addMultiHandler3(
				{ (tv: UITableView, _: IndexPath, _: UITableViewCell) -> Void in
					_ = (tv.delegate as? Storage)?.notifyVisibleRowsChanged(in: tv)
				},
				#selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:))
			)
			delegate().addMultiHandler3(
				{ (tv: UITableView, _: IndexPath, _: UITableViewCell) -> Void in
					_ = (tv.delegate as? Storage)?.notifyVisibleRowsChanged(in: tv)
				},
				#selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
			)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .accessoryButtonTapped(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:)))
		case .commit(let x): delegate().addMultiHandler3(x, #selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
		case .didDeselectRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didDeselectRowAt:)))
		case .didEndDisplayingFooter(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplayingFooterView:forSection:)))
		case .didEndDisplayingHeader(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplayingHeaderView:forSection:)))
		case .didEndDisplayingCell(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:)))
		case .didEndEditingRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didEndEditingRowAt:)))
		case .didHightlightRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didHighlightRowAt:)))
		case .didSelectRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))
		case .didUnhighlightRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didUnhighlightRowAt:)))
		case .moveRow(let x): delegate().addMultiHandler3(x, #selector(UITableViewDataSource.tableView(_:moveRowAt:to:)))
		case .canEditRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDataSource.tableView(_:canEditRowAt:)))
		case .canFocusRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:canFocusRowAt:)))
		case .canMoveRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDataSource.tableView(_:canMoveRowAt:)))
		case .canPerformAction(let x): delegate().addSingleHandler4(x, #selector(UITableViewDelegate.tableView(_:canPerformAction:forRowAt:withSender:)))
		case .cellIdentifier(let x): cellIdentifier = x
		case .didUpdateFocus(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:)))
		case .editActionsForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:editActionsForRowAt:)))
		case .editingStyleForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:editingStyleForRowAt:)))
		case .estimatedHeightForFooter(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForFooterInSection:)))
		case .estimatedHeightForHeader(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForHeaderInSection:)))
		case .estimatedHeightForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForRowAt:)))
		case .footerHeight(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForFooterInSection:)))
		case .footerView(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:viewForFooterInSection:)))
		case .headerHeight(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForHeaderInSection:)))
		case .headerView(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:viewForHeaderInSection:)))
		case .heightForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForRowAt:)))
		case .indentationLevelForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:indentationLevelForRowAt:)))
		case .indexPathForPreferredFocusedView(let x): delegate().addSingleHandler1(x, #selector(UITableViewDelegate.indexPathForPreferredFocusedView(in:)))
		case .shouldHighlightRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldHighlightRowAt:)))
		case .shouldIndentWhileEditingRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldIndentWhileEditingRowAt:)))
		case .shouldShowMenuForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldShowMenuForRowAt:)))
		case .shouldUpdateFocus(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldUpdateFocusIn:)))
		case .targetIndexPathForMoveFromRow(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:targetIndexPathForMoveFromRowAt:toProposedIndexPath:)))
		case .titleForDeleteConfirmationButtonForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:titleForDeleteConfirmationButtonForRowAt:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)

		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tableViewStyle: return nil
		
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsMultipleSelectionDuringEditing(let x): return x.apply(instance) { i, v in i.allowsMultipleSelectionDuringEditing = v }
		case .allowsSelection(let x): return x.apply(instance) { i, v in i.allowsSelection = v }
		case .allowsSelectionDuringEditing(let x): return x.apply(instance) { i, v in i.allowsSelectionDuringEditing = v }
		case .backgroundView(let x): return x.apply(instance) { i, v in i.backgroundView = v?.uiView() }
		case .cellLayoutMarginsFollowReadableWidth(let x): return x.apply(instance) { i, v in i.cellLayoutMarginsFollowReadableWidth = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .estimatedRowHeight(let x): return x.apply(instance) { i, v in i.estimatedRowHeight = v }
		case .estimatedSectionFooterHeight(let x): return x.apply(instance) { i, v in i.estimatedSectionFooterHeight = v }
		case .estimatedSectionHeaderHeight(let x): return x.apply(instance) { i, v in i.estimatedSectionHeaderHeight = v }
		case .remembersLastFocusedIndexPath(let x): return x.apply(instance) { i, v in i.remembersLastFocusedIndexPath = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .sectionFooterHeight(let x): return x.apply(instance) { i, v in i.sectionFooterHeight = v }
		case .sectionHeaderHeight(let x): return x.apply(instance) { i, v in i.sectionHeaderHeight = v }
		case .sectionIndexBackgroundColor(let x): return x.apply(instance) { i, v in i.sectionIndexBackgroundColor = v }
		case .sectionIndexColor(let x): return x.apply(instance) { i, v in i.sectionIndexColor = v }
		case .sectionIndexMinimumDisplayRowCount(let x): return x.apply(instance) { i, v in i.sectionIndexMinimumDisplayRowCount = v }
		case .sectionIndexTrackingBackgroundColor(let x): return x.apply(instance) { i, v in i.sectionIndexTrackingBackgroundColor = v }
		case .separatorColor(let x): return x.apply(instance) { i, v in i.separatorColor = v }
		case .separatorEffect(let x): return x.apply(instance) { i, v in i.separatorEffect = v }
		case .separatorInset(let x): return x.apply(instance) { i, v in i.separatorInset = v }
		case .separatorInsetReference(let x): return x.apply(instance) { i, v in i.separatorInsetReference = v }
		case .separatorStyle(let x): return x.apply(instance) { i, v in i.separatorStyle = v }
		case .tableFooterView(let x): return x.apply(instance) { i, v	in i.tableFooterView = v?.uiView() }
		case .tableHeaderView(let x): return x.apply(instance) { i, v in i.tableHeaderView = v?.uiView() }
		
		//	2. Signal bindings are performed on the object after construction.
		case .deselectRow(let x): return x.apply(instance) { i, v in i.deselectRow(at: v.value, animated: v.isAnimated) }
		case .scrollToNearestSelectedRow(let x): return x.apply(instance) { i, v in i.scrollToNearestSelectedRow(at: v.value, animated: v.isAnimated) }
		case .scrollToRow(let x):
			// You can't scroll a table view until *after* the number of sections and rows has been read from the data source.
			// This occurs on didAddToWindow but the easiest way to track it is by waiting for the contentSize to be set (which is set for the first time immediately after the row count is read). This makes assumptions about internal logic of UITableView â if this logic changes in future, scrolls set on load might be lost (not a catastrophic problem).
			// Capture the scroll signal to stall it
			let capture = x.capture()
			
			// Create a signal pair that will join the capture to the destination *after* the first `contentSize` change is observed
			let pair = Signal<SetOrAnimate<TableScrollPosition>>.create()
			var kvo: NSKeyValueObservation? = instance.observe(\.contentSize) { (i, change) in
				_ = try? capture.bind(to: pair.input, resend: true)
			}
			
			// Use the output of the pair to apply the effects as normal
			return pair.signal.apply(instance) { i, v in
				// Remove the key value observing after the first value is received.
				if let k = kvo {
					k.invalidate()
					kvo = nil
				}
				
				// Clamp to the number of actual sections and rows
				var indexPath = v.value.indexPath
				if indexPath.section >= i.numberOfSections {
					indexPath.section = i.numberOfSections - 1
				}
				if indexPath.section < 0 {
					return
				}
				if indexPath.row >= i.numberOfRows(inSection: indexPath.section) {
					indexPath.row = i.numberOfRows(inSection: indexPath.section) - 1
				}
				if indexPath.row < 0 {
					return
				}
				
				// Finally, perform the scroll
				i.scrollToRow(at: indexPath, at: v.value.position, animated: v.isAnimated)
			}
		case .selectRow(let x):
			return x.apply(instance) { i, v in
				i.selectRow(at: v.value?.indexPath, animated: v.isAnimated, scrollPosition: v.value?.position ?? .none)
			}
			
		//	3. Action bindings are triggered by the object after construction.
		case .accessoryButtonTapped: return nil
		case .commit: return nil
		case .didDeselectRow: return nil
		case .didEndDisplayingFooter: return nil
		case .didEndDisplayingHeader: return nil
		case .didEndDisplayingCell: return nil
		case .didEndEditingRow: return nil
		case .didHightlightRow: return nil
		case .didSelectRow: return nil
		case .didUnhighlightRow: return nil
		case .moveRow: return nil
		case .selectionDidChange(let x):
			return Signal.notifications(name: UITableView.selectionDidChangeNotification, object: instance).map { n -> ([TableRow<RowData>])? in
				if let tableView = n.object as? UITableView, let selection = tableView.indexPathsForSelectedRows {
					if let sections = (tableView.delegate as? Storage)?.sections.values {
						return selection.compactMap { indexPath in
							return TableRow<RowData>(indexPath: indexPath, data: sections.at(indexPath.section)?.values?.at(indexPath.row))
						}
					} else {
						return selection.map { indexPath in TableRow<RowData>(indexPath: indexPath, data: nil) }
					}
				} else {
					return nil
				}
			}.cancellableBind(to: x)
		case .userDidScrollToRow: return nil
		case .visibleRowsChanged: return nil
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .canEditRow: return nil
		case .canFocusRow: return nil
		case .canMoveRow: return nil
		case .canPerformAction: return nil
		case .cellConstructor(let x):
			storage.cellConstructor = x
			return nil
		case .cellIdentifier: return nil
		case .dataMissingCell(let x):
			storage.dataMissingCell = x
			return nil
		case .didUpdateFocus: return nil
		case .editActionsForRow: return nil
		case .editingStyleForRow: return nil
		case .estimatedHeightForFooter: return nil
		case .estimatedHeightForHeader: return nil
		case .estimatedHeightForRow: return nil
		case .footerHeight: return nil
		case .footerView: return nil
		case .headerHeight: return nil
		case .headerView: return nil
		case .heightForRow: return nil
		case .indentationLevelForRow: return nil
		case .indexPathForPreferredFocusedView: return nil
		case .sectionIndexTitles(let x):
			return x.apply(instance, storage) { i, s, v in
				s.indexTitles = v
				i.reloadSectionIndexTitles()
			}
		case .shouldHighlightRow: return nil
		case .shouldIndentWhileEditingRow: return nil
		case .shouldShowMenuForRow: return nil
		case .shouldUpdateFocus: return nil
		case .tableData(let x): return x.apply(instance, storage) { i, s, v in s.applySectionAnimation(v, to: i) }
		case .targetIndexPathForMoveFromRow: return nil
		case .titleForDeleteConfirmationButtonForRow: return nil
		case .willBeginEditingRow: return nil
		case .willDeselectRow: return nil
		case .willDisplayFooter: return nil
		case .willDisplayHeader: return nil
		case .willDisplayRow: return nil
		case .willSelectRow: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableView.Preparer {
	class Storage: ScrollView.Preparer.Storage, UITableViewDelegate, UITableViewDataSource {
		override var isInUse: Bool { return true }
		
		var sections = TableSectionState<RowData>()
		var indexTitles: [String]? = nil
		var scrollJunction: (SignalCapture<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>, SignalInput<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>)? = nil
		var cellIdentifier: (TableRow<RowData>) -> String?
		var cellConstructor: ((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)?
		var dataMissingCell: (IndexPath) -> TableViewCellConvertible = { _ in return TableViewCell() }
		let rowsChanged: MultiOutput<[TableRow<RowData>]>?
		
		init(rowsChanged: MultiOutput<[TableRow<RowData>]>?, cellIdentifier: @escaping (TableRow<RowData>) -> String?) {
			self.rowsChanged = rowsChanged
			self.cellIdentifier = cellIdentifier
			super.init()
		}
		
		func numberOfSections(in tableView: UITableView) -> Int {
			return sections.globalCount
		}
		
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return sections.values?.at(section)?.globalCount ?? 0
		}
		
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			let data = sections.values?.at(indexPath.section).flatMap { section in section.values?.at(indexPath.row - section.localOffset) }
			let identifier = cellIdentifier(TableRow(indexPath: indexPath, data: data))
			
			let cellView: UITableViewCell
			let cellInput: SignalInput<RowData>?
			if let i = identifier, let reusedView = tableView.dequeueReusableCell(withIdentifier: i) {
				cellView = reusedView
				cellInput = reusedView.associatedRowInput(valueType: RowData.self)
			} else if let cc = cellConstructor {
				let dataTuple = Input<RowData>().multicast()
				let constructed = cc(identifier, dataTuple.signal).uiTableViewCell(reuseIdentifier: identifier)
				cellView = constructed
				cellInput = dataTuple.input
				constructed.setAssociatedRowInput(to: dataTuple.input)
			} else {
				return dataMissingCell(indexPath).uiTableViewCell(reuseIdentifier: nil)
			}
			
			if let d = data {
				_ = cellInput?.send(value: d)
			}
			
			return cellView
		}
		
		func tableView(_ tableView: UITableView, titleForHeaderInSection: Int) -> String? {
			return sections.values?.at(titleForHeaderInSection)?.leaf?.header
		}
		
		func tableView(_ tableView: UITableView, titleForFooterInSection: Int) -> String? {
			return sections.values?.at(titleForFooterInSection)?.leaf?.footer
		}
		
		func sectionIndexTitles(for tableView: UITableView) -> [String]? {
			return indexTitles
		}
		
		func notifyVisibleRowsChanged(in tableView: UITableView) {
			guard let rowsChanged = rowsChanged else { return }
			DispatchQueue.main.async { [rowsChanged] in
				if let indexPaths = tableView.indexPathsForVisibleRows, indexPaths.count > 0 {
					rowsChanged.input.send(value: indexPaths.map { indexPath in TableRow<RowData>(indexPath: indexPath, data: self.sections.values?.at(indexPath.section)?.values?.at(indexPath.row)) })
				} else {
					rowsChanged.input.send(value: [])
				}
			}
		}
		
		func applySectionAnimation(_ sectionAnimatable: TableSectionAnimatable<RowData>, to i: UITableView) {
			sectionAnimatable.value.apply(to: &sections)
			
			let animation = sectionAnimatable.animation ?? .none
			switch sectionAnimatable.value.kind {
			case .delete:
				i.deleteSections(sectionAnimatable.value.indexSet.offset(by: sections.localOffset), with: animation)
			case .move(let destination):
				i.performBatchUpdates({
					for (count, index) in sectionAnimatable.value.indexSet.offset(by: sections.localOffset).enumerated() {
						i.moveSection(index, toSection: destination + count)
					}
				}, completion: nil)
			case .insert:
				i.insertSections(sectionAnimatable.value.indexSet.offset(by: sections.localOffset), with: animation)
			case .scroll:
				i.reloadSections(sectionAnimatable.value.indexSet.offset(by: sections.localOffset), with: animation)
			case .update:
				i.performBatchUpdates({
					for (sectionIndex, change) in zip(sectionAnimatable.value.indexSet.offset(by: sections.localOffset), sectionAnimatable.value.values) {
						if change.metadata?.leaf != nil {
							i.reloadSections([sectionIndex], with: animation)
						} else {
							let indexPaths = change.indexSet.map { rowIndex in IndexPath(row: rowIndex, section: sectionIndex) }
							switch change.kind {
							case .delete: i.deleteRows(at: indexPaths, with: animation)
							case .move(let destination):
								for (count, index) in indexPaths.enumerated() {
									i.moveRow(at: index, to: IndexPath(row: destination + count, section: sectionIndex))
								}
							case .insert: i.insertRows(at: indexPaths, with: animation)
							case .scroll:
								i.reloadRows(at: indexPaths, with: animation)
							case .update:
								guard let section = sections.values?.at(sectionIndex - sections.localOffset) else { continue }
								for indexPath in indexPaths {
									guard let cell = i.cellForRow(at: indexPath), let value = section.values?.at(indexPath.row - sections.localOffset) else { continue }
									cell.associatedRowInput(valueType: RowData.self)?.send(value: value)
								}
								notifyVisibleRowsChanged(in: i)
							case .reload:
								i.reloadSections([sectionIndex], with: animation)
							}
						}
					}
				}, completion: nil)
			case .reload:
				i.reloadData()
			}

		}
	}

	class Delegate: ScrollView.Preparer.Delegate, UITableViewDataSource, UITableViewDelegate {
		private func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
			return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(indexPath.section)?.values?.at(indexPath.row))
		}
		
		private func metadata(section: Int, in tableView: UITableView) -> TableSectionMetadata? {
			return (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(section)?.leaf
		}
		
		func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			// This is a required method of UITableViewDataSource but is implemented by the storage
			return 0
		}
		
		func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			// This is a required method of UITableViewDelegate but is implemented by the storage
			return UITableViewCell()
		}
		
		func tableView(_ tableView: UITableView, accessoryButtonTappedForRowWith indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, canFocusRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?) -> Bool {
			return singleHandler(tableView, action, tableRowData(at: indexPath, in: tableView), sender)
		}
		
		func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, didEndDisplayingHeaderView view: UIView, forSection section: Int) {
			multiHandler(tableView, view, section)
		}
		
		func tableView(_ tableView: UITableView, didEndDisplayingFooterView view: UIView, forSection section: Int) {
			multiHandler(tableView, view, section)
		}
		
		func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, cell, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
			multiHandler(tableView, indexPath.map { tableRowData(at: $0, in: tableView) })
		}
		
		func tableView(_ tableView: UITableView, didHighlightRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, didUnhighlightRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, didUpdateFocusIn context: UITableViewFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) {
			return singleHandler(tableView, context, coordinator)
		}
		
		func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCell.EditingStyle {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
			return (singleHandler(tableView, section, metadata(section: section, in: tableView)?.footer) as ViewConvertible?)?.uiView()
		}
		
		func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
			return (singleHandler(tableView, section, metadata(section: section, in: tableView)?.header) as ViewConvertible?)?.uiView()
		}
		
		func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, indentationLevelForRowAt indexPath: IndexPath) -> Int {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func indexPathForPreferredFocusedView(in tableView: UITableView) -> IndexPath? {
			return singleHandler(tableView)
		}
		
		func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: sourceIndexPath, in: tableView), destinationIndexPath)
		}
		
		func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, shouldIndentWhileEditingRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, shouldUpdateFocusIn context: UITableViewFocusUpdateContext) -> Bool {
			return singleHandler(tableView, context)
		}
		
		func tableView(_ tableView: UITableView, targetIndexPathForMoveFromRowAt sourceIndexPath: IndexPath, toProposedIndexPath proposedDestinationIndexPath: IndexPath) -> IndexPath {
			return singleHandler(tableView, sourceIndexPath, proposedDestinationIndexPath)
		}
		
		func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, willDeselectRowAt indexPath: IndexPath) -> IndexPath? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {
			multiHandler(tableView, section, view)
		}
		
		func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {
			multiHandler(tableView, section, view)
		}
		
		func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, indexPath, cell)
		}
		
		func tableView(_ tableView: UITableView, willSelectRowAt indexPath: IndexPath) -> IndexPath? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, editingStyle, tableRowData(at: indexPath, in: tableView))
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewBinding {
	typealias TableViewName<V> = BindingName<V, TableView<Binding.RowDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableView<Binding.RowDataType>.Binding) -> TableViewName<V> {
		return TableViewName<V>(source: source, downcast: Binding.tableViewBinding)
	}
}
extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewName<$2> { return .name(TableView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: TableViewName<Constant<UITableView.Style>> { return .name(TableView.Binding.tableViewStyle) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsMultipleSelection) }
	static var allowsMultipleSelectionDuringEditing: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsMultipleSelectionDuringEditing) }
	static var allowsSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsSelection) }
	static var allowsSelectionDuringEditing: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsSelectionDuringEditing) }
	static var backgroundView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.backgroundView) }
	static var cellLayoutMarginsFollowReadableWidth: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.cellLayoutMarginsFollowReadableWidth) }
	static var estimatedRowHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedRowHeight) }
	static var estimatedSectionFooterHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedSectionFooterHeight) }
	static var estimatedSectionHeaderHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedSectionHeaderHeight) }
	static var isEditing: TableViewName<Signal<SetOrAnimate<Bool>>> { return .name(TableView.Binding.isEditing) }
	static var remembersLastFocusedIndexPath: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.remembersLastFocusedIndexPath) }
	static var rowHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.rowHeight) }
	static var sectionFooterHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.sectionFooterHeight) }
	static var sectionHeaderHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.sectionHeaderHeight) }
	static var sectionIndexBackgroundColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexBackgroundColor) }
	static var sectionIndexColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexColor) }
	static var sectionIndexMinimumDisplayRowCount: TableViewName<Dynamic<Int>> { return .name(TableView.Binding.sectionIndexMinimumDisplayRowCount) }
	static var sectionIndexTitles: TableViewName<Dynamic<[String]?>> { return .name(TableView.Binding.sectionIndexTitles) }
	static var sectionIndexTrackingBackgroundColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexTrackingBackgroundColor) }
	static var separatorColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.separatorColor) }
	static var separatorEffect: TableViewName<Dynamic<UIVisualEffect?>> { return .name(TableView.Binding.separatorEffect) }
	static var separatorInset: TableViewName<Dynamic<UIEdgeInsets>> { return .name(TableView.Binding.separatorInset) }
	static var separatorInsetReference: TableViewName<Dynamic<UITableView.SeparatorInsetReference>> { return .name(TableView.Binding.separatorInsetReference) }
	static var separatorStyle: TableViewName<Dynamic<UITableViewCell.SeparatorStyle>> { return .name(TableView.Binding.separatorStyle) }
	static var tableData: TableViewName<Dynamic<TableSectionAnimatable<Binding.RowDataType>>> { return .name(TableView.Binding.tableData) }
	static var tableFooterView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.tableFooterView) }
	static var tableHeaderView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.tableHeaderView) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: TableViewName<Signal<SetOrAnimate<IndexPath>>> { return .name(TableView.Binding.deselectRow) }
	static var scrollToNearestSelectedRow: TableViewName<Signal<SetOrAnimate<UITableView.ScrollPosition>>> { return .name(TableView.Binding.scrollToNearestSelectedRow) }
	static var scrollToRow: TableViewName<Signal<SetOrAnimate<TableScrollPosition>>> { return .name(TableView.Binding.scrollToRow) }
	static var selectRow: TableViewName<Signal<SetOrAnimate<TableScrollPosition?>>> { return .name(TableView.Binding.selectRow) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var selectionDidChange: TableViewName<SignalInput<[TableRow<Binding.RowDataType>]?>> { return .name(TableView.Binding.selectionDidChange) }
	static var userDidScrollToRow: TableViewName<SignalInput<TableRow<Binding.RowDataType>>> { return .name(TableView.Binding.userDidScrollToRow) }
	static var visibleRowsChanged: TableViewName<SignalInput<[TableRow<Binding.RowDataType>]>> { return .name(TableView.Binding.visibleRowsChanged) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var accessoryButtonTapped: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.accessoryButtonTapped) }
	static var canEditRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canEditRow) }
	static var canFocusRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canFocusRow) }
	static var canMoveRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canMoveRow) }
	static var canPerformAction: TableViewName<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> { return .name(TableView.Binding.canPerformAction) }
	static var cellConstructor: TableViewName<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> { return .name(TableView.Binding.cellConstructor) }
	static var cellIdentifier: TableViewName<(TableRow<Binding.RowDataType>) -> String?> { return .name(TableView.Binding.cellIdentifier) }
	static var commit: TableViewName<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.commit) }
	static var dataMissingCell: TableViewName<(IndexPath) -> TableViewCellConvertible> { return .name(TableView.Binding.dataMissingCell) }
	static var didDeselectRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didDeselectRow) }
	static var didEndDisplayingCell: TableViewName<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didEndDisplayingCell) }
	static var didEndDisplayingFooter: TableViewName<(UITableView, UIView, Int) -> Void> { return .name(TableView.Binding.didEndDisplayingFooter) }
	static var didEndDisplayingHeader: TableViewName<(UITableView, UIView, Int) -> Void> { return .name(TableView.Binding.didEndDisplayingHeader) }
	static var didEndEditingRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>?) -> Void> { return .name(TableView.Binding.didEndEditingRow) }
	static var didHightlightRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didHightlightRow) }
	static var didSelectRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didSelectRow) }
	static var didUnhighlightRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didUnhighlightRow) }
	static var didUpdateFocus: TableViewName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> { return .name(TableView.Binding.didUpdateFocus) }
	static var editActionsForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> { return .name(TableView.Binding.editActionsForRow) }
	static var editingStyleForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle> { return .name(TableView.Binding.editingStyleForRow) }
	static var estimatedHeightForFooter: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForFooter) }
	static var estimatedHeightForHeader: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForHeader) }
	static var estimatedHeightForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForRow) }
	static var footerHeight: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.footerHeight) }
	static var footerView: TableViewName<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> { return .name(TableView.Binding.footerView) }
	static var headerHeight: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.headerHeight) }
	static var headerView: TableViewName<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> { return .name(TableView.Binding.headerView) }
	static var heightForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> { return .name(TableView.Binding.heightForRow) }
	static var indentationLevelForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int> { return .name(TableView.Binding.indentationLevelForRow) }
	static var indexPathForPreferredFocusedView: TableViewName<(UITableView) -> IndexPath> { return .name(TableView.Binding.indexPathForPreferredFocusedView) }
	static var moveRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void> { return .name(TableView.Binding.moveRow) }
	static var shouldHighlightRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldHighlightRow) }
	static var shouldIndentWhileEditingRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldIndentWhileEditingRow) }
	static var shouldShowMenuForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldShowMenuForRow) }
	static var shouldUpdateFocus: TableViewName<(UITableView, UITableViewFocusUpdateContext) -> Bool> { return .name(TableView.Binding.shouldUpdateFocus) }
	static var targetIndexPathForMoveFromRow: TableViewName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> { return .name(TableView.Binding.targetIndexPathForMoveFromRow) }
	static var titleForDeleteConfirmationButtonForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?> { return .name(TableView.Binding.titleForDeleteConfirmationButtonForRow) }
	static var willBeginEditingRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.willBeginEditingRow) }
	static var willDeselectRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> { return .name(TableView.Binding.willDeselectRow) }
	static var willDisplayFooter: TableViewName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> { return .name(TableView.Binding.willDisplayFooter) }
	static var willDisplayHeader: TableViewName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> { return .name(TableView.Binding.willDisplayHeader) }
	static var willDisplayRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> { return .name(TableView.Binding.willDisplayRow) }
	static var willSelectRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> { return .name(TableView.Binding.willSelectRow) }
	
	// Composite binding names
	static func rowSelected<Value>(_ keyPath: KeyPath<TableRow<Binding.RowDataType>, Value>) -> TableViewName<SignalInput<Value>> {
		return Binding.compositeName(
			value: { input in { tableView, tableRow -> Void in input.send(value: tableRow[keyPath: keyPath]) } },
			binding: TableView.Binding.didSelectRow,
			downcast: Binding.tableViewBinding
		)
	}
	static func rowSelected(_ void: Void = ()) -> TableViewName<SignalInput<TableRow<Binding.RowDataType>>> {
		return Binding.compositeName(
			value: { input in { tableView, tableRow -> Void in input.send(value: tableRow) } },
			binding: TableView.Binding.didSelectRow,
			downcast: Binding.tableViewBinding
		)
	}
	static func commit<Value>(_ keyPath: KeyPath<TableRowCommit<Binding.RowDataType>, Value>) -> TableViewName<SignalInput<Value>> {
		return Binding.compositeName(
			value: { input in { tableView, editingStyle, tableRow -> Void in input.send(value: TableRowCommit(style: editingStyle, tableRow: tableRow)[keyPath: keyPath]) } },
			binding: TableView.Binding.commit,
			downcast: Binding.tableViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableViewConvertible: ScrollViewConvertible {
	func uiTableView() -> UITableView
}
extension TableViewConvertible {
	func uiScrollView() -> ScrollView.Instance { return uiTableView() }
}
extension UITableView: TableViewConvertible {
	func uiTableView() -> UITableView { return self }
}
extension TableView {
	func uiTableView() -> UITableView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableViewBinding: ScrollViewBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> Self
}
extension TableViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}
extension TableView.Binding {
	typealias Preparer = TableView.Preparer
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> TableView<RowDataType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct TableSectionMetadata {
	let header: String?
	let footer: String?
	init(header: String? = nil, footer: String? = nil) {
		(self.header, self.footer) = (header, footer)
	}
}

typealias TableRowMutation<Element> = SubrangeMutation<Element, TableSectionMetadata>
typealias TableRowAnimatable<Element> = Animatable<TableRowMutation<Element>, UITableView.RowAnimation>
typealias TableSectionMutation<Element> = SubrangeMutation<TableRowMutation<Element>, ()>
typealias TableSectionAnimatable<Element> = Animatable<TableSectionMutation<Element>, UITableView.RowAnimation>

typealias TableRowState<Element> = SubrangeState<Element, TableSectionMetadata>
typealias TableSectionState<Element> = SubrangeState<TableRowState<Element>, ()>

extension IndexedMutation where Metadata == Subrange<Void> {
	func apply<RowData>(to sections: inout TableSectionState<RowData>) where Element == TableRowMutation<RowData> {
		if case .update = kind {
			for (mutationIndex, rowIndex) in indexSet.enumerated() {
				values[mutationIndex].mapMetadata { _ in () }.apply(to: &sections.values![rowIndex].values!)
				values[mutationIndex].updateMetadata(&sections.values![rowIndex])
			}
		} else {
			self.mapValues { rowMutation -> TableRowState<RowData> in
				var rowState = TableRowState<RowData>()
				rowMutation.apply(toSubrange: &rowState)
				return rowState
			}.apply(toSubrange: &sections)
		}
		self.updateMetadata(&sections)
	}
}

struct TableScrollPosition {
	let indexPath: IndexPath
	let position: UITableView.ScrollPosition
	init(indexPath: IndexPath, position: UITableView.ScrollPosition = .none) {
		self.indexPath = indexPath
		self.position = position
	}
	
	static func none(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .none)
	}
	
	static func top(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .top)
	}
	
	static func middle(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .middle)
	}
	
	static func bottom(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .bottom)
	}
}

struct TableRowCommit<RowData> {
	let style: UITableViewCell.EditingStyle
	let tableRow: TableRow<RowData>
	
	init(style: UITableViewCell.EditingStyle, tableRow: TableRow<RowData>) {
		self.style = style
		self.tableRow = tableRow
	}
}

struct TableRow<RowData> {
	let indexPath: IndexPath
	let data: RowData?
	
	init(indexPath: IndexPath, data: RowData?) {
		self.indexPath = indexPath
		self.data = data
	}
}

extension Sequence {
	func tableData() -> TableSectionAnimatable<Element> {
		return .set(.reload([.reload(Array(self))]))
	}
}

extension Signal {
	func tableData<RowData>(_ choice: AnimationChoice = .subsequent) -> Signal<TableSectionAnimatable<RowData>> where TableRowMutation<RowData> == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -> TableSectionAnimatable<RowData> in
			if alreadyReceived || choice == .always {
				return .animate(.updated(rowMutation, at: 0), animation: .automatic)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(.reload([rowMutation]))
			}
		}
	}
}

extension Adapter where State == VarState<IndexPath?> {
	func updateFirstRow<RowData>() -> SignalInput<[TableRow<RowData>]> {
		return Input().map { $0.first?.indexPath }.bind(to: update())
	}
}

extension SignalInterface where OutputValue == IndexPath? {
	func restoreFirstRow() -> Signal<SetOrAnimate<TableScrollPosition>> {
		return compactMap { $0.map { .top($0) } }.animate(.never)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TapGestureRecognizer: Binder, TapGestureRecognizerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TapGestureRecognizer {
	enum Binding: TapGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TapGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TapGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = UITapGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TapGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
			//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .numberOfTapsRequired(let x): return x.apply(instance) { i, v in i.numberOfTapsRequired = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
			// 2. Signal bindings are performed on the object after construction.
			
			// 3. Action bindings are triggered by the object after construction.
			
			// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TapGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TapGestureRecognizerBinding {
	typealias TapGestureRecognizerName<V> = BindingName<V, TapGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TapGestureRecognizer.Binding) -> TapGestureRecognizerName<V> {
		return TapGestureRecognizerName<V>(source: source, downcast: Binding.tapGestureRecognizerBinding)
	}
}
extension BindingName where Binding: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TapGestureRecognizerName<$2> { return .name(TapGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var numberOfTapsRequired: TapGestureRecognizerName<Dynamic<Int>> { return .name(TapGestureRecognizer.Binding.numberOfTapsRequired) }
	static var numberOfTouchesRequired: TapGestureRecognizerName<Dynamic<Int>> { return .name(TapGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TapGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance
}
extension TapGestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiTapGestureRecognizer() }
}
extension UITapGestureRecognizer: TapGestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return self }
}
extension TapGestureRecognizer {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TapGestureRecognizerBinding: GestureRecognizerBinding {
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> Self
}
extension TapGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return tapGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension TapGestureRecognizer.Binding {
	typealias Preparer = TapGestureRecognizer.Preparer
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> TapGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TextField: Binder, TextFieldConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TextField {
	enum Binding: TextFieldBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case attributedPlaceholder(Dynamic<NSAttributedString?>)
		case attributedText(Dynamic<NSAttributedString?>)
		case background(Dynamic<UIImage?>)
		case borderStyle(Dynamic<UITextField.BorderStyle>)
		case clearButtonMode(Dynamic<UITextField.ViewMode>)
		case clearsOnBeginEditing(Dynamic<Bool>)
		case clearsOnInsertion(Dynamic<Bool>)
		case defaultTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case disabledBackground(Dynamic<UIImage?>)
		case font(Dynamic<UIFont?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		case inputView(Dynamic<ViewConvertible?>)
		case leftView(Dynamic<ViewConvertible?>)
		case leftViewMode(Dynamic<UITextField.ViewMode>)
		case minimumFontSize(Dynamic<CGFloat>)
		case placeholder(Dynamic<String?>)
		case rightView(Dynamic<ViewConvertible?>)
		case rightViewMode(Dynamic<UITextField.ViewMode>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor?>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case resignFirstResponder(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((_ textField: UITextField) -> Void)
		case didChange((_ textField: UITextField) -> Void)
		case didEndEditing((_ textField: UITextField) -> Void)
		case didEndEditingWithReason((_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void)
		case shouldBeginEditing((_ textField: UITextField) -> Bool)
		case shouldChangeCharacters((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)
		case shouldClear((_ textField: UITextField) -> Bool)
		case shouldEndEditing((_ textField: UITextField) -> Bool)
		case shouldReturn((_ textField: UITextField) -> Bool)
	}
}
	
// MARK: - Binder Part 3: Preparer
extension TextField {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TextField.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = UITextField
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TextField.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didEndEditingWithReason(let x): delegate().addMultiHandler2(x, #selector(UITextFieldDelegate.textFieldDidEndEditing(_:reason:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldEndEditing(_:)))
		case .shouldChangeCharacters(let x): delegate().addSingleHandler3(x, #selector(UITextFieldDelegate.textField(_:shouldChangeCharactersIn:replacementString:)))
		case .shouldClear(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldClear(_:)))
		case .shouldReturn(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldReturn(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsFontSizeToFitWidth(let x): return x.apply(instance) { i, v in i.adjustsFontSizeToFitWidth = v }
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .attributedPlaceholder(let x): return x.apply(instance) { i, v in i.attributedPlaceholder = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .background(let x): return x.apply(instance) { i, v in i.background = v }
		case .borderStyle(let x): return x.apply(instance) { i, v in i.borderStyle = v }
		case .clearButtonMode(let x): return x.apply(instance) { i, v in i.clearButtonMode = v }
		case .clearsOnBeginEditing(let x): return x.apply(instance) { i, v in i.clearsOnBeginEditing = v }
		case .clearsOnInsertion(let x): return x.apply(instance) { i, v in i.clearsOnInsertion = v }
		case .defaultTextAttributes(let x): return x.apply(instance) { i, v in i.defaultTextAttributes = v }
		case .disabledBackground(let x): return x.apply(instance) { i, v in i.disabledBackground = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v?.uiView() }
		case .inputView(let x): return x.apply(instance) { i, v in i.inputView = v?.uiView() }
		case .leftView(let x): return x.apply(instance) { i, v in i.leftView = v?.uiView() }
		case .leftViewMode(let x): return x.apply(instance) { i, v in i.leftViewMode = v }
		case .minimumFontSize(let x): return x.apply(instance) { i, v in i.minimumFontSize = v }
		case .placeholder(let x): return x.apply(instance) { i, v in i.placeholder = v }
		case .rightView(let x): return x.apply(instance) { i, v in i.rightView = v?.uiView() }
		case .rightViewMode(let x): return x.apply(instance) { i, v in i.rightViewMode = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
		
		//	2. Signal bindings are performed on the object after construction.
		case .resignFirstResponder(let x): return x.apply(instance) { i, v in i.resignFirstResponder() }
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .didBeginEditing(let x): return Signal.notifications(name: UITextField.textDidBeginEditingNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .didChange(let x): return Signal.notifications(name: UITextField.textDidChangeNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .didEndEditing(let x): return Signal.notifications(name: UITextField.textDidEndEditingNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .shouldBeginEditing: return nil
		case .shouldChangeCharacters: return nil
		case .shouldClear: return nil
		case .shouldEndEditing: return nil
		case .shouldReturn: return nil

		case .didEndEditingWithReason: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextField.Preparer {
	class Storage: Control.Preparer.Storage, UITextFieldDelegate {}
	
	class Delegate: DynamicDelegate, UITextFieldDelegate {
		func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
			return singleHandler(textField, range, string)
		}
		
		func textFieldShouldClear(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		func textFieldShouldReturn(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {
			multiHandler(textField, reason)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextFieldBinding {
	typealias TextFieldName<V> = BindingName<V, TextField.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextField.Binding) -> TextFieldName<V> {
		return TextFieldName<V>(source: source, downcast: Binding.textFieldBinding)
	}
}
extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextFieldName<$2> { return .name(TextField.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: TextFieldName<Constant<TextInputTraits>> { return .name(TextField.Binding.textInputTraits) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.adjustsFontSizeToFitWidth) }
	static var allowsEditingTextAttributes: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsEditingTextAttributes) }
	static var attributedPlaceholder: TextFieldName<Dynamic<NSAttributedString?>> { return .name(TextField.Binding.attributedPlaceholder) }
	static var attributedText: TextFieldName<Dynamic<NSAttributedString?>> { return .name(TextField.Binding.attributedText) }
	static var background: TextFieldName<Dynamic<UIImage?>> { return .name(TextField.Binding.background) }
	static var borderStyle: TextFieldName<Dynamic<UITextField.BorderStyle>> { return .name(TextField.Binding.borderStyle) }
	static var clearButtonMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.clearButtonMode) }
	static var clearsOnBeginEditing: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.clearsOnBeginEditing) }
	static var clearsOnInsertion: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.clearsOnInsertion) }
	static var defaultTextAttributes: TextFieldName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextField.Binding.defaultTextAttributes) }
	static var disabledBackground: TextFieldName<Dynamic<UIImage?>> { return .name(TextField.Binding.disabledBackground) }
	static var font: TextFieldName<Dynamic<UIFont?>> { return .name(TextField.Binding.font) }
	static var inputAccessoryView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.inputAccessoryView) }
	static var inputView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.inputView) }
	static var leftView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.leftView) }
	static var leftViewMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.leftViewMode) }
	static var minimumFontSize: TextFieldName<Dynamic<CGFloat>> { return .name(TextField.Binding.minimumFontSize) }
	static var placeholder: TextFieldName<Dynamic<String?>> { return .name(TextField.Binding.placeholder) }
	static var rightView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.rightView) }
	static var rightViewMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.rightViewMode) }
	static var text: TextFieldName<Dynamic<String>> { return .name(TextField.Binding.text) }
	static var textAlignment: TextFieldName<Dynamic<NSTextAlignment>> { return .name(TextField.Binding.textAlignment) }
	static var textColor: TextFieldName<Dynamic<UIColor?>> { return .name(TextField.Binding.textColor) }
	static var typingAttributes: TextFieldName<Dynamic<[NSAttributedString.Key: Any]?>> { return .name(TextField.Binding.typingAttributes) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var resignFirstResponder: TextFieldName<Signal<Void>> { return .name(TextField.Binding.resignFirstResponder) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didBeginEditing) }
	static var didChange: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didChange) }
	static var didEndEditing: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didEndEditing) }
	static var didEndEditingWithReason: TextFieldName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void> { return .name(TextField.Binding.didEndEditingWithReason) }
	static var shouldBeginEditing: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldBeginEditing) }
	static var shouldChangeCharacters: TextFieldName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool> { return .name(TextField.Binding.shouldChangeCharacters) }
	static var shouldClear: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldClear) }
	static var shouldEndEditing: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldEndEditing) }
	static var shouldReturn: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldReturn) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> TextFieldName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { textField in textField.text.map { _ = input.send(value: $0) } } },
			binding: TextField.Binding.didChange,
			downcast: Binding.textFieldBinding
		)
	}
	static func attributedTextChanged(_ void: Void = ()) -> TextFieldName<SignalInput<NSAttributedString>> {
		return Binding.compositeName(
			value: { input in { textField in textField.attributedText.map { _ = input.send(value: $0) } } },
			binding: TextField.Binding.didChange,
			downcast: Binding.textFieldBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TextFieldConvertible: ControlConvertible {
	func uiTextField() -> TextField.Instance
}
extension TextFieldConvertible {
	func uiControl() -> Control.Instance { return uiTextField() }
}
extension UITextField: TextFieldConvertible, HasDelegate {
	func uiTextField() -> TextField.Instance { return self }
}
extension TextField {
	func uiTextField() -> TextField.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
}
extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}
extension TextField.Binding {
	typealias Preparer = TextField.Preparer
	static func textFieldBinding(_ binding: TextField.Binding) -> TextField.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
func textFieldResignOnReturn(condition: @escaping (UITextField) -> Bool = { _ in return true }) -> (UITextField) -> Bool {
	return { tf in
		if condition(tf) {
			tf.resignFirstResponder()
			return false
		}
		return true
	}
}

#endif

#if os(iOS)

/// A type that hold an array of UITextInputTraits in a binding-like manner so they can be constructed using BindingName syntax.
/// This type is not implemented as a binder because it does not construct an instance or binder storage. It is a helper-type used by other binders that conform to the UITextInputTraits protocol.
struct TextInputTraits {
	let bindings: [Binding]
	init(bindings: [Binding]) {
		self.bindings = bindings
	}
	init(_ bindings: Binding...) {
		self.init(bindings: bindings)
	}
	
	enum Binding {
		case autocapitalizationType(Dynamic<UITextAutocapitalizationType>)
		case autocorrectionType(Dynamic<UITextAutocorrectionType>)
		case enablesReturnKeyAutomatically(Dynamic<Bool>)
		case isSecureTextEntry(Dynamic<Bool>)
		case keyboardAppearance(Dynamic<UIKeyboardAppearance>)
		case keyboardType(Dynamic<UIKeyboardType>)
		case returnKeyType(Dynamic<UIReturnKeyType>)
		case smartDashesType(Dynamic<UITextSmartDashesType>)
		case smartInsertDeleteType(Dynamic<UITextSmartInsertDeleteType>)
		case smartQuotesType(Dynamic<UITextSmartQuotesType>)
		case spellCheckingType(Dynamic<UITextSpellCheckingType>)
		case textContentType(Dynamic<UITextContentType>)
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	func apply(to instance: UISearchBar) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	func apply(to instance: UITextField) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	func apply(to instance: UITextView) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
}

extension BindingName where Source == Binding, Binding == TextInputTraits.Binding {
	// NOTE: for some reason, any attempt at a TextInputTraitsName typealias led to a compiler crash so the explicit BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding> must be used instead.
	private static func name<V>(_ source: @escaping (V) -> TextInputTraits.Binding) -> BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding> {
		return BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding>(source: source, downcast: { b in b})
	}
}
extension BindingName where Source == Binding, Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2> { return .name(TextInputTraits.Binding.$1) }
	static var autocapitalizationType: BindingName<Dynamic<UITextAutocapitalizationType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.autocapitalizationType) }
	static var autocorrectionType: BindingName<Dynamic<UITextAutocorrectionType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.autocorrectionType) }
	static var enablesReturnKeyAutomatically: BindingName<Dynamic<Bool>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.enablesReturnKeyAutomatically) }
	static var isSecureTextEntry: BindingName<Dynamic<Bool>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.isSecureTextEntry) }
	static var keyboardAppearance: BindingName<Dynamic<UIKeyboardAppearance>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.keyboardAppearance) }
	static var keyboardType: BindingName<Dynamic<UIKeyboardType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.keyboardType) }
	static var returnKeyType: BindingName<Dynamic<UIReturnKeyType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.returnKeyType) }
	static var smartDashesType: BindingName<Dynamic<UITextSmartDashesType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartDashesType) }
	static var smartInsertDeleteType: BindingName<Dynamic<UITextSmartInsertDeleteType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartInsertDeleteType) }
	static var smartQuotesType: BindingName<Dynamic<UITextSmartQuotesType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartQuotesType) }
	static var spellCheckingType: BindingName<Dynamic<UITextSpellCheckingType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.spellCheckingType) }
	static var textContentType: BindingName<Dynamic<UITextContentType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.textContentType) }
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class TextView: Binder, TextViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TextView {
	enum Binding: TextViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case attributedText(Dynamic<NSAttributedString>)
		case clearsOnInsertion(Dynamic<Bool>)
		case dataDetectorTypes(Dynamic<UIDataDetectorTypes>)
		case font(Dynamic<UIFont?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		case inputView(Dynamic<ViewConvertible?>)
		case isEditable(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case linkTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case selectedRange(Dynamic<NSRange>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor?>)
		case textContainerInset(Dynamic<UIEdgeInsets>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRangeToVisible(Signal<NSRange>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((UITextView) -> Void)
		case didChange((UITextView) -> Void)
		case didChangeSelection((UITextView) -> Void)
		case didEndEditing((UITextView) -> Void)
		case shouldBeginEditing((UITextView) -> Bool)
		case shouldChangeText((UITextView, NSRange, String) -> Bool)
		case shouldEndEditing((UITextView) -> Bool)
		case shouldInteractWithAttachment((UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)
		case shouldInteractWithURL((UITextView, URL, NSRange, UITextItemInteraction) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension TextView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TextView.Binding
		typealias Inherited = ScrollView.Preparer
		typealias Instance = UITextView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TextView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .didBeginEditing(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidBeginEditing(_:)))
		case .didChange(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidChange(_:)))
		case .didChangeSelection(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidChangeSelection(_:)))
		case .didEndEditing(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidEndEditing(_:)))
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UITextViewDelegate.textViewShouldBeginEditing(_:)))
		case .shouldChangeText(let x): delegate().addSingleHandler3(x, #selector(UITextViewDelegate.textView(_:shouldChangeTextIn:replacementText:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UITextViewDelegate.textViewShouldEndEditing(_:)))
		
		case .shouldInteractWithAttachment(let x): delegate().addSingleHandler4(x, #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)?))
		case .shouldInteractWithURL(let x): delegate().addSingleHandler4(x, #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)?))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .clearsOnInsertion(let x): return x.apply(instance) { i, v in i.clearsOnInsertion = v }
		case .dataDetectorTypes(let x): return x.apply(instance) { i, v in i.dataDetectorTypes = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v?.uiView() }
		case .inputView(let x): return x.apply(instance) { i, v in i.inputView = v?.uiView() }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .linkTextAttributes(let x): return x.apply(instance) { i, v in i.linkTextAttributes = v }
		case .selectedRange(let x): return x.apply(instance) { i, v in i.selectedRange = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .textContainerInset(let x): return x.apply(instance) { i, v in i.textContainerInset = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .scrollRangeToVisible(let x): return x.apply(instance) { i, v in i.scrollRangeToVisible(v) }
			
		//	3. Action bindings are triggered by the object after construction.
		case .didBeginEditing: return nil
		case .didChange: return nil
		case .didChangeSelection: return nil
		case .didEndEditing: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing: return nil
		case .shouldChangeText: return nil
		case .shouldEndEditing: return nil
		
		case .shouldInteractWithAttachment: return nil
		case .shouldInteractWithURL: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextView.Preparer {
	class Storage: ScrollView.Preparer.Storage, UITextViewDelegate {}
	
	class Delegate: ScrollView.Preparer.Delegate, UITextViewDelegate {
		func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
			return singleHandler(textView)
		}
		
		func textViewShouldEndEditing(_ textView: UITextView) -> Bool {
			return singleHandler(textView)
		}
		
		func textViewDidBeginEditing(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		func textViewDidEndEditing(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return singleHandler(textView, range, text)
		}
		
		func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return singleHandler(textView, textAttachment, characterRange, interaction)
		}
		
		func textView(_ textView: UITextView, shouldInteractWith url: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return singleHandler(textView, url, characterRange, interaction)
		}
		
		func textViewDidChange(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		func textViewDidChangeSelection(_ textView: UITextView) {
			multiHandler(textView)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextViewBinding {
	typealias TextViewName<V> = BindingName<V, TextView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextView.Binding) -> TextViewName<V> {
		return TextViewName<V>(source: source, downcast: Binding.textViewBinding)
	}
}
extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextViewName<$2> { return .name(TextView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: TextViewName<Constant<TextInputTraits>> { return .name(TextView.Binding.textInputTraits) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsEditingTextAttributes: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsEditingTextAttributes) }
	static var attributedText: TextViewName<Dynamic<NSAttributedString>> { return .name(TextView.Binding.attributedText) }
	static var clearsOnInsertion: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.clearsOnInsertion) }
	static var dataDetectorTypes: TextViewName<Dynamic<UIDataDetectorTypes>> { return .name(TextView.Binding.dataDetectorTypes) }
	static var font: TextViewName<Dynamic<UIFont?>> { return .name(TextView.Binding.font) }
	static var inputAccessoryView: TextViewName<Dynamic<ViewConvertible?>> { return .name(TextView.Binding.inputAccessoryView) }
	static var inputView: TextViewName<Dynamic<ViewConvertible?>> { return .name(TextView.Binding.inputView) }
	static var isEditable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isEditable) }
	static var isSelectable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isSelectable) }
	static var linkTextAttributes: TextViewName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextView.Binding.linkTextAttributes) }
	static var selectedRange: TextViewName<Dynamic<NSRange>> { return .name(TextView.Binding.selectedRange) }
	static var text: TextViewName<Dynamic<String>> { return .name(TextView.Binding.text) }
	static var textAlignment: TextViewName<Dynamic<NSTextAlignment>> { return .name(TextView.Binding.textAlignment) }
	static var textColor: TextViewName<Dynamic<UIColor?>> { return .name(TextView.Binding.textColor) }
	static var textContainerInset: TextViewName<Dynamic<UIEdgeInsets>> { return .name(TextView.Binding.textContainerInset) }
	static var typingAttributes: TextViewName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextView.Binding.typingAttributes) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollRangeToVisible: TextViewName<Signal<NSRange>> { return .name(TextView.Binding.scrollRangeToVisible) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didBeginEditing) }
	static var didChange: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didChange) }
	static var didChangeSelection: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didChangeSelection) }
	static var didEndEditing: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didEndEditing) }
	static var shouldBeginEditing: TextViewName<(UITextView) -> Bool> { return .name(TextView.Binding.shouldBeginEditing) }
	static var shouldChangeText: TextViewName<(UITextView, NSRange, String) -> Bool> { return .name(TextView.Binding.shouldChangeText) }
	static var shouldEndEditing: TextViewName<(UITextView) -> Bool> { return .name(TextView.Binding.shouldEndEditing) }
	static var shouldInteractWithAttachment: TextViewName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool> { return .name(TextView.Binding.shouldInteractWithAttachment) }
	static var shouldInteractWithURL: TextViewName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool> { return .name(TextView.Binding.shouldInteractWithURL) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> TextViewName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { textView in _ = input.send(value: textView.text) } },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
	static func attributedTextChanged(_ void: Void = ()) -> TextViewName<SignalInput<NSAttributedString>> {
		return Binding.compositeName(
			value: { input in { textView in _ = input.send(value: textView.attributedText) } },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TextViewConvertible: ScrollViewConvertible {
	func uiTextView() -> UITextView
}
extension TextViewConvertible {
	func uiScrollView() -> ScrollView.Instance { return uiTextView() }
}
extension UITextView: TextViewConvertible {
	func uiTextView() -> UITextView { return self }
}
extension TextView {
	func uiTextView() -> UITextView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TextViewBinding: ScrollViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
}
extension TextViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}
extension TextView.Binding {
	typealias Preparer = TextView.Preparer
	static func textViewBinding(_ binding: TextView.Binding) -> TextView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Toolbar: Binder, ToolbarConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Toolbar {
	enum Binding: ToolbarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case items(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case shadowImage(Dynamic<ScopedValues<UIBarPosition, UIImage?>>)
		case tintColor(Dynamic<UIColor?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case position((UIBarPositioning) -> UIBarPosition)
	}
}

// MARK: - Binder Part 3: Preparer
extension Toolbar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Toolbar.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UIToolbar
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Toolbar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .position(let x): delegate().addSingleHandler1(x, #selector(UIToolbarDelegate.position(for:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, forToolbarPosition: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, forToolbarPosition: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .items(let x): return x.apply(instance) { i, v in i.setItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .shadowImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setShadowImage(nil, forToolbarPosition: scope) },
				applyNew: { i, scope, v in i.setShadowImage(v, forToolbarPosition: scope) }
			)
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
			
			// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Toolbar.Preparer {
	class Storage: View.Preparer.Storage, UIToolbarDelegate {}
	
	class Delegate: DynamicDelegate, UIToolbarDelegate {
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarBinding {
	typealias ToolbarName<V> = BindingName<V, Toolbar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Toolbar.Binding) -> ToolbarName<V> {
		return ToolbarName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
extension BindingName where Binding: ToolbarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarName<$2> { return .name(Toolbar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: ToolbarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(Toolbar.Binding.backgroundImage) }
	static var barStyle: ToolbarName<Dynamic<UIBarStyle>> { return .name(Toolbar.Binding.barStyle) }
	static var barTintColor: ToolbarName<Dynamic<UIColor?>> { return .name(Toolbar.Binding.barTintColor) }
	static var isTranslucent: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.isTranslucent) }
	static var items: ToolbarName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(Toolbar.Binding.items) }
	static var shadowImage: ToolbarName<Dynamic<ScopedValues<UIBarPosition, UIImage?>>> { return .name(Toolbar.Binding.shadowImage) }
	static var tintColor: ToolbarName<Dynamic<UIColor?>> { return .name(Toolbar.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var position: ToolbarName<(UIBarPositioning) -> UIBarPosition> { return .name(Toolbar.Binding.position) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ToolbarConvertible: ViewConvertible {
	func uiToolbar() -> Toolbar.Instance
}
extension ToolbarConvertible {
	func uiView() -> View.Instance { return uiToolbar() }
}
extension UIToolbar: ToolbarConvertible, HasDelegate {
	func uiToolbar() -> Toolbar.Instance { return self }
}
extension Toolbar {
	func uiToolbar() -> Toolbar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ToolbarBinding: ViewBinding {
	static func scrollViewBinding(_ binding: Toolbar.Binding) -> Self
}
extension ToolbarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
extension Toolbar.Binding {
	typealias Preparer = Toolbar.Preparer
	static func scrollViewBinding(_ binding: Toolbar.Binding) -> Toolbar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class ViewController: Binder, ViewControllerConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ViewController {
	enum Binding: ViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationItem(Constant<NavigationItem>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case additionalSafeAreaInsets(Dynamic<UIEdgeInsets>)
		case children(Dynamic<[ViewControllerConvertible]>)
		case definesPresentationContext(Dynamic<Bool>)
		case edgesForExtendedLayout(Dynamic<UIRectEdge>)
		case extendedLayoutIncludesOpaqueBars(Dynamic<Bool>)
		case hidesBottomBarWhenPushed(Dynamic<Bool>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case isModalInPopover(Dynamic<Bool>)
		case modalPresentationCapturesStatusBarAppearance(Dynamic<Bool>)
		case modalPresentationStyle(Dynamic<UIModalPresentationStyle>)
		case modalTransitionStyle(Dynamic<UIModalTransitionStyle>)
		case preferredContentSize(Dynamic<CGSize>)
		case providesPresentationContextTransitionStyle(Dynamic<Bool>)
		case restorationClass(Dynamic<UIViewControllerRestoration.Type?>)
		case restorationIdentifier(Dynamic<String?>)
		case tabBarItem(Dynamic<TabBarItemConvertible>)
		case title(Dynamic<String>)
		case toolbarItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case transitioningDelegate(Dynamic<UIViewControllerTransitioningDelegate>)
		case view(Dynamic<ViewConvertible>)
		
		// 2. Signal bindings are performed on the object after construction.
		case present(Signal<Animatable<ModalPresentation?, ()>>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case childrenLayout(([UIView]) -> Layout)
	}
}

// MARK: - Binder Part 3: Preparer
extension ViewController {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ViewController.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIViewController
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var childrenLayout: (([UIView]) -> Layout)?
		var view: InitialSubsequent<ViewConvertible>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ViewController.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .childrenLayout(let x): childrenLayout = x
		case .view(let x): view = x.initialSubsequent()
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)

		// Need to set the embedded storage immediately (instead of waiting for the combine function) in case any of the swizzled methods get called (they rely on being able to access the embedded storage).
		instance.setAssociatedBinderStorage(storage)
		
		// The loadView function needs to be ready in case one of the bindings triggers a view load.
		if let v = view?.initial?.uiView() {
			instance.view = v
		}
		
		// The childrenLayout should be ready for when the children property starts
		storage.childrenLayout = childrenLayout
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationItem(let x):
			x.value.apply(to: instance.navigationItem)
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .additionalSafeAreaInsets(let x): return x.apply(instance) { i, v in i.additionalSafeAreaInsets = v }
		case .children(let x):
			return x.apply(instance, storage) { i, s, v in
				let existing = i.children
				let next = v.map { $0.uiViewController() }
				
				for e in existing {
					if !next.contains(e) {
						e.willMove(toParent: nil)
					}
				}
				for n in next {
					if !existing.contains(n) {
						i.addChild(n)
					}
				}
				(storage.childrenLayout?(next.map { $0.view })).map(i.view.applyLayout)
				for n in next {
					if !existing.contains(n) {
						n.didMove(toParent: i)
					}
				}
				for e in existing {
					if !next.contains(e) {
						e.removeFromParent()
					}
				}
			}
		case .definesPresentationContext(let x): return x.apply(instance) { i, v in i.definesPresentationContext = v }
		case .edgesForExtendedLayout(let x): return x.apply(instance) { i, v in i.edgesForExtendedLayout = v }
		case .extendedLayoutIncludesOpaqueBars(let x): return x.apply(instance) { i, v in i.extendedLayoutIncludesOpaqueBars = v }
		case .hidesBottomBarWhenPushed(let x): return x.apply(instance) { i, v in i.hidesBottomBarWhenPushed = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .isModalInPopover(let x): return x.apply(instance) { i, v in i.isModalInPopover = v }
		case .modalPresentationCapturesStatusBarAppearance(let x): return x.apply(instance) { i, v in i.modalPresentationCapturesStatusBarAppearance = v }
		case .modalPresentationStyle(let x): return x.apply(instance) { i, v in i.modalPresentationStyle = v }
		case .modalTransitionStyle(let x): return x.apply(instance) { i, v in i.modalTransitionStyle = v }
		case .preferredContentSize(let x): return x.apply(instance) { i, v in i.preferredContentSize = v }
		case .providesPresentationContextTransitionStyle(let x): return x.apply(instance) { i, v in i.providesPresentationContextTransitionStyle = v }
		case .restorationClass(let x): return x.apply(instance) { i, v in i.restorationClass = v }
		case .restorationIdentifier(let x): return x.apply(instance) { i, v in i.restorationIdentifier = v }
		case .tabBarItem(let x): return x.apply(instance) { i, v in i.tabBarItem = v.uiTabBarItem() }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .toolbarItems(let x): return x.apply(instance) { i, v in i.setToolbarItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .transitioningDelegate(let x): return x.apply(instance) { i, v in i.transitioningDelegate = v }
		case .view:
			return view?.apply(instance, storage) { i, s, v in
				s.view = v
				if i.isViewLoaded {
					i.view = v.uiView()
				}
			}
			
		// 2. Signal bindings are performed on the object after construction.
		case .present(let x):
			return x.apply(instance, storage) { i, s, v in
				s.queuedModalPresentations.append(v)
				s.processModalPresentations(viewController: i)
			}
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .childrenLayout: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		// We previously set the embedded storage so that any delegate methods triggered during setup would be able to resolve the storage. Now that we're done setting up, we need to *clear* the storage so the embed function doesn't complain that the storage is already set.
		instance.setAssociatedBinderStorage(nil)
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ViewController.Preparer {
	private static var presenterKey = NSObject()
	
	class Storage: AssociatedBinderStorage, UIPopoverPresentationControllerDelegate {
		var view: ViewConvertible?
		var childrenLayout: (([UIView]) -> Layout)?
		
		var presentationAnimationInProgress: Bool = false
		var currentModalPresentation: ModalPresentation? = nil
		var queuedModalPresentations: [Animatable<ModalPresentation?, ()>] = []
		
		override var isInUse: Bool {
			return true
		}
		
		private func presentationDismissed(viewController: UIViewController) {
			currentModalPresentation?.completion?.send(value: ())
			currentModalPresentation = nil
			processModalPresentations(viewController: viewController)
		}
		
		private func presentationAnimationCompleted(viewController: UIViewController, dismissed: Bool) {
			self.queuedModalPresentations.removeFirst()
			self.presentationAnimationInProgress = false
			if dismissed {
				presentationDismissed(viewController: viewController)
			}
		}
		
		func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) {
			presentationDismissed(viewController: popoverPresentationController.presentingViewController)
		}
		
		private func present(viewController: UIViewController, modalPresentation: ModalPresentation, animated: Bool) {
			presentationAnimationInProgress = true
			currentModalPresentation = modalPresentation
			let presentation = modalPresentation.viewController.uiViewController()
			if let popover = presentation.popoverPresentationController, let configure = modalPresentation.popoverPositioning {
				configure(viewController, popover)
				popover.delegate = self
			} else if let presenter = presentation.presentationController {
				objc_setAssociatedObject(presenter, &presenterKey, OnDelete {
					guard presentation === self.currentModalPresentation?.viewController.uiViewController() else { return }
					self.presentationDismissed(viewController: viewController)
				}, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
			}
			viewController.present(presentation, animated: animated) {
				self.presentationAnimationCompleted(viewController: viewController, dismissed: false)
			}
		}
		
		private func dismiss(viewController: UIViewController, animated: Bool) {
			presentationAnimationInProgress = true
			guard let vc = viewController.presentedViewController else {
				self.presentationAnimationCompleted(viewController: viewController, dismissed: true)
				return
			}
			guard !(vc === currentModalPresentation?.viewController.uiViewController()) || vc.isBeingDismissed else {
				assertionFailure("Presentations interleaved with other APIs is not supported.")
				let completionHandlers = queuedModalPresentations.compactMap {
					$0.value?.completion
				}
				queuedModalPresentations.removeAll()
				presentationAnimationInProgress = false
				currentModalPresentation?.completion?.send(value: ())
				completionHandlers.forEach { $0.send(value: ()) }
				return
			}
			vc.dismiss(animated: animated, completion: { () -> Void in
				self.presentationAnimationCompleted(viewController: viewController, dismissed: true)
			})
		}
		
		func processModalPresentations(viewController: UIViewController) {
			guard !presentationAnimationInProgress, let first = queuedModalPresentations.first else { return }
			if let modalPresentation = first.value {
				guard viewController.view.window != nil else { return }
				present(viewController: viewController, modalPresentation: modalPresentation, animated: first.isAnimated)
			} else {
				dismiss(viewController: viewController, animated: first.isAnimated)
			}
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewControllerBinding {
	typealias ViewControllerName<V> = BindingName<V, ViewController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ViewController.Binding) -> ViewControllerName<V> {
		return ViewControllerName<V>(source: source, downcast: Binding.viewControllerBinding)
	}
}
extension BindingName where Binding: ViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewControllerName<$2> { return .name(ViewController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationItem: ViewControllerName<Constant<NavigationItem>> { return .name(ViewController.Binding.navigationItem) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var additionalSafeAreaInsets: ViewControllerName<Dynamic<UIEdgeInsets>> { return .name(ViewController.Binding.additionalSafeAreaInsets) }
	static var children: ViewControllerName<Dynamic<[ViewControllerConvertible]>> { return .name(ViewController.Binding.children) }
	static var definesPresentationContext: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.definesPresentationContext) }
	static var edgesForExtendedLayout: ViewControllerName<Dynamic<UIRectEdge>> { return .name(ViewController.Binding.edgesForExtendedLayout) }
	static var extendedLayoutIncludesOpaqueBars: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.extendedLayoutIncludesOpaqueBars) }
	static var hidesBottomBarWhenPushed: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.hidesBottomBarWhenPushed) }
	static var isEditing: ViewControllerName<Signal<SetOrAnimate<Bool>>> { return .name(ViewController.Binding.isEditing) }
	static var isModalInPopover: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.isModalInPopover) }
	static var modalPresentationCapturesStatusBarAppearance: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.modalPresentationCapturesStatusBarAppearance) }
	static var modalPresentationStyle: ViewControllerName<Dynamic<UIModalPresentationStyle>> { return .name(ViewController.Binding.modalPresentationStyle) }
	static var modalTransitionStyle: ViewControllerName<Dynamic<UIModalTransitionStyle>> { return .name(ViewController.Binding.modalTransitionStyle) }
	static var preferredContentSize: ViewControllerName<Dynamic<CGSize>> { return .name(ViewController.Binding.preferredContentSize) }
	static var providesPresentationContextTransitionStyle: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.providesPresentationContextTransitionStyle) }
	static var restorationClass: ViewControllerName<Dynamic<UIViewControllerRestoration.Type?>> { return .name(ViewController.Binding.restorationClass) }
	static var restorationIdentifier: ViewControllerName<Dynamic<String?>> { return .name(ViewController.Binding.restorationIdentifier) }
	static var tabBarItem: ViewControllerName<Dynamic<TabBarItemConvertible>> { return .name(ViewController.Binding.tabBarItem) }
	static var title: ViewControllerName<Dynamic<String>> { return .name(ViewController.Binding.title) }
	static var toolbarItems: ViewControllerName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(ViewController.Binding.toolbarItems) }
	static var transitioningDelegate: ViewControllerName<Dynamic<UIViewControllerTransitioningDelegate>> { return .name(ViewController.Binding.transitioningDelegate) }
	static var view: ViewControllerName<Dynamic<ViewConvertible>> { return .name(ViewController.Binding.view) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var present: ViewControllerName<Signal<Animatable<ModalPresentation?, ()>>> { return .name(ViewController.Binding.present) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var childrenLayout: ViewControllerName<([UIView]) -> Layout> { return .name(ViewController.Binding.childrenLayout) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ViewControllerConvertible {
	func uiViewController() -> ViewController.Instance
}
extension UIViewController: ViewControllerConvertible, DefaultConstructable {
	func uiViewController() -> ViewController.Instance { return self }
}
extension ViewController {
	func uiViewController() -> ViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ViewControllerBinding: BinderBaseBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self
}
extension ViewControllerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return viewControllerBinding(.inheritedBinding(binding))
	}
}
extension ViewController.Binding {
	typealias Preparer = ViewController.Preparer
	static func viewControllerBinding(_ binding: ViewController.Binding) -> ViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct ModalPresentation {
	let viewController: ViewControllerConvertible
	let popoverPositioning: ((_ presenter: UIViewController, _ popover: UIPopoverPresentationController) -> Void)?
	let completion: SignalInput<Void>?
	
	init(_ viewController: ViewControllerConvertible, popoverPositioning: ((_ presenter: UIViewController, _ popover: UIPopoverPresentationController) -> Void)? = nil, completion: SignalInput<Void>? = nil) {
		self.viewController = viewController
		self.popoverPositioning = popoverPositioning
		self.completion = completion
	}
}

extension SignalInterface {
	func modalPresentation<T>(_ construct: @escaping (T) -> ViewControllerConvertible) -> Signal<ModalPresentation?> where OutputValue == Optional<T> {
		return transform { result in
			switch result {
			case .success(.some(let t)): return .value(ModalPresentation(construct(t)))
			case .success: return .value(nil)
			case .failure(let e): return .end(e)
			}
		}
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class View: Binder, ViewConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension View {
	enum Binding: ViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case layer(Constant<Layer>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case alpha(Dynamic<(CGFloat)>)
		case backgroundColor(Dynamic<(UIColor?)>)
		case clearsContextBeforeDrawing(Dynamic<(Bool)>)
		case clipsToBounds(Dynamic<(Bool)>)
		case contentMode(Dynamic<(UIView.ContentMode)>)
		case gestureRecognizers(Dynamic<[GestureRecognizerConvertible]>)
		case horizontalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case horizontalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case isExclusiveTouch(Dynamic<(Bool)>)
		case isHidden(Dynamic<(Bool)>)
		case isMultipleTouchEnabled(Dynamic<(Bool)>)
		case isOpaque(Dynamic<(Bool)>)
		case isUserInteractionEnabled(Dynamic<(Bool)>)
		case layout(Dynamic<Layout>)
		case layoutMargins(Dynamic<(UIEdgeInsets)>)
		case mask(Dynamic<(ViewConvertible?)>)
		case motionEffects(Dynamic<([UIMotionEffect])>)
		case preservesSuperviewLayoutMargins(Dynamic<(Bool)>)
		case restorationIdentifier(Dynamic<String?>)
		case semanticContentAttribute(Dynamic<(UISemanticContentAttribute)>)
		case tag(Dynamic<Int>)
		case tintAdjustmentMode(Dynamic<(UIView.TintAdjustmentMode)>)
		case tintColor(Dynamic<(UIColor)>)
		case verticalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case verticalContentHuggingPriority(Dynamic<UILayoutPriority>)

		// 2. Signal bindings are performed on the object after construction.
		case becomeFirstResponder(Signal<Void>)
		case endEditing(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension View {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = View.Binding
		typealias Inherited = BinderBase
		typealias Instance = UIView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension View.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .layer(let x):
			x.value.apply(to: instance.layer)
			return nil
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .alpha(let x): return x.apply(instance) { i, v in i.alpha = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .clearsContextBeforeDrawing(let x): return x.apply(instance) { i, v in i.clearsContextBeforeDrawing = v }
		case .clipsToBounds(let x): return x.apply(instance) { i, v in i.clipsToBounds = v }
		case .contentMode(let x): return x.apply(instance) { i, v in i.contentMode = v }
		case .gestureRecognizers(let x): return x.apply(instance) { i, v in i.gestureRecognizers = v.map { $0.uiGestureRecognizer() } }
		case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.horizontal) }
		case .horizontalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.horizontal) }
		case .isExclusiveTouch(let x): return x.apply(instance) { i, v in i.isExclusiveTouch = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .isMultipleTouchEnabled(let x): return x.apply(instance) { i, v in i.isMultipleTouchEnabled = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .isUserInteractionEnabled(let x): return x.apply(instance) { i, v in i.isUserInteractionEnabled = v }
		case .layout(let x): return x.apply(instance) { i, v in instance.applyLayout(v) }
		case .layoutMargins(let x): return x.apply(instance) { i, v in i.layoutMargins = v }
		case .mask(let x): return x.apply(instance) { i, v in i.mask = v?.uiView() }
		case .motionEffects(let x): return x.apply(instance) { i, v in i.motionEffects = v }
		case .preservesSuperviewLayoutMargins(let x): return x.apply(instance) { i, v in i.preservesSuperviewLayoutMargins = v }
		case .restorationIdentifier(let x): return x.apply(instance) { i, v in i.restorationIdentifier = v }
		case .semanticContentAttribute(let x): return x.apply(instance) { i, v in i.semanticContentAttribute = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .tintAdjustmentMode(let x): return x.apply(instance) { i, v in i.tintAdjustmentMode = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .verticalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.vertical) }
		case .verticalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.vertical) }

		// 2. Signal bindings are performed on the object after construction.
		case .becomeFirstResponder(let x): return x.apply(instance) { i, v in i.becomeFirstResponder() }
		case .endEditing(let x): return x.apply(instance) { i, v in i.endEditing(v) }
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension View.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewBinding {
	typealias ViewName<V> = BindingName<V, View.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> View.Binding) -> ViewName<V> {
		return ViewName<V>(source: source, downcast: Binding.viewBinding)
	}
}
extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewName<$2> { return .name(View.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var layer: ViewName<Constant<Layer>> { return .name(View.Binding.layer) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alpha: ViewName<Dynamic<(CGFloat)>> { return .name(View.Binding.alpha) }
	static var backgroundColor: ViewName<Dynamic<(UIColor?)>> { return .name(View.Binding.backgroundColor) }
	static var clearsContextBeforeDrawing: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.clearsContextBeforeDrawing) }
	static var clipsToBounds: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.clipsToBounds) }
	static var contentMode: ViewName<Dynamic<(UIView.ContentMode)>> { return .name(View.Binding.contentMode) }
	static var gestureRecognizers: ViewName<Dynamic<[GestureRecognizerConvertible]>> { return .name(View.Binding.gestureRecognizers) }
	static var horizontalContentCompressionResistancePriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.horizontalContentCompressionResistancePriority) }
	static var horizontalContentHuggingPriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.horizontalContentHuggingPriority) }
	static var isExclusiveTouch: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isExclusiveTouch) }
	static var isHidden: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isHidden) }
	static var isMultipleTouchEnabled: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isMultipleTouchEnabled) }
	static var isOpaque: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isOpaque) }
	static var isUserInteractionEnabled: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isUserInteractionEnabled) }
	static var layout: ViewName<Dynamic<Layout>> { return .name(View.Binding.layout) }
	static var layoutMargins: ViewName<Dynamic<(UIEdgeInsets)>> { return .name(View.Binding.layoutMargins) }
	static var mask: ViewName<Dynamic<(ViewConvertible?)>> { return .name(View.Binding.mask) }
	static var motionEffects: ViewName<Dynamic<([UIMotionEffect])>> { return .name(View.Binding.motionEffects) }
	static var preservesSuperviewLayoutMargins: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.preservesSuperviewLayoutMargins) }
	static var restorationIdentifier: ViewName<Dynamic<String?>> { return .name(View.Binding.restorationIdentifier) }
	static var semanticContentAttribute: ViewName<Dynamic<(UISemanticContentAttribute)>> { return .name(View.Binding.semanticContentAttribute) }
	static var tag: ViewName<Dynamic<Int>> { return .name(View.Binding.tag) }
	static var tintAdjustmentMode: ViewName<Dynamic<(UIView.TintAdjustmentMode)>> { return .name(View.Binding.tintAdjustmentMode) }
	static var tintColor: ViewName<Dynamic<(UIColor)>> { return .name(View.Binding.tintColor) }
	static var verticalContentCompressionResistancePriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.verticalContentCompressionResistancePriority) }
	static var verticalContentHuggingPriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.verticalContentHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: ViewName<Signal<Void>> { return .name(View.Binding.becomeFirstResponder) }
	static var endEditing: ViewName<Signal<Bool>> { return .name(View.Binding.endEditing) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension UIView: DefaultConstructable {}
extension View {
	func uiView() -> Layout.View { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ViewBinding: BinderBaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
}
extension ViewBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return viewBinding(.inheritedBinding(binding))
	}
}
extension View.Binding {
	typealias Preparer = View.Preparer
	static func viewBinding(_ binding: View.Binding) -> View.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
class Window: Binder, WindowConvertible {
	var state: BinderState<Preparer>
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Window {
	enum Binding: WindowBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case frame(Dynamic<CGRect>)
		case rootViewController(Dynamic<ViewControllerConvertible>)
		case screen(Dynamic<UIScreen>)
		case windowLevel(Dynamic<UIWindow.Level>)
		
		// 2. Signal bindings are performed on the object after construction.
		case makeKey(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeVisible(SignalInput<Void>)
		case didBecomeHidden(SignalInput<Void>)
		case didBecomeKey(SignalInput<Void>)
		case didResignKey(SignalInput<Void>)
		case keyboardWillShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillChangeFrame(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidChangeFrame(SignalInput<[AnyHashable: Any]?>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Window {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Window.Binding
		typealias Inherited = View.Preparer
		typealias Instance = UIWindow
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -> Storage { return Storage() }
		func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var isHidden: InitialSubsequent<Bool>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Window.Preparer {
	mutating func prepareBinding(_ binding: Window.Binding) {
		switch binding {
		case .inheritedBinding(.isHidden(let x)): isHidden = x.initialSubsequent()
		case .inheritedBinding(let s): inherited.prepareBinding(s)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.isHidden): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .frame(let x): return x.apply(instance) { i, v in i.frame = v }
		case .rootViewController(let x):
			return x.apply(instance) { i, v in
				let rootViewController = v.uiViewController()
				i.rootViewController = rootViewController
				if rootViewController.restorationIdentifier == nil {
					rootViewController.restorationIdentifier = "cwlviews.root"
				}
			}
		case .screen(let x): return x.apply(instance) { i, v in i.screen = v }
		case .windowLevel(let x): return x.apply(instance) { i, v in i.windowLevel = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .makeKey(let x): return x.apply(instance) { i, v in i.makeKey() }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBecomeHidden(let x): return Signal.notifications(name: UIWindow.didBecomeHiddenNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didBecomeKey(let x): return Signal.notifications(name: UIWindow.didBecomeKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didBecomeVisible(let x): return Signal.notifications(name: UIWindow.didBecomeVisibleNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didResignKey(let x): return Signal.notifications(name: UIWindow.didResignKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .keyboardDidChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardDidChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardDidHide(let x): return Signal.notifications(name: UIResponder.keyboardDidHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardDidShow(let x): return Signal.notifications(name: UIResponder.keyboardDidShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardWillChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillHide(let x): return Signal.notifications(name: UIResponder.keyboardWillHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillShow(let x): return Signal.notifications(name: UIResponder.keyboardWillShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: View.Preparer.Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		
		// `isHidden` needs to be applied after everything else
		lifetimes += (isHidden?.resume()).flatMap {
			inherited.applyBinding(.isHidden(.dynamic($0)), instance: instance, storage: storage)
		}
		
		lifetimes += inherited.inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Window.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WindowBinding {
	typealias WindowName<V> = BindingName<V, Window.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Window.Binding) -> WindowName<V> {
		return WindowName<V>(source: source, downcast: Binding.windowBinding)
	}
}
extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WindowName<$2> { return .name(Window.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var frame: WindowName<Dynamic<CGRect>> { return .name(Window.Binding.frame) }
	static var rootViewController: WindowName<Dynamic<ViewControllerConvertible>> { return .name(Window.Binding.rootViewController) }
	static var screen: WindowName<Dynamic<UIScreen>> { return .name(Window.Binding.screen) }
	static var windowLevel: WindowName<Dynamic<UIWindow.Level>> { return .name(Window.Binding.windowLevel) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var makeKey: WindowName<Signal<Void>> { return .name(Window.Binding.makeKey) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeVisible: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeVisible) }
	static var didBecomeHidden: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeHidden) }
	static var didBecomeKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeKey) }
	static var didResignKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didResignKey) }
	static var keyboardWillShow: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillShow) }
	static var keyboardDidShow: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidShow) }
	static var keyboardWillHide: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillHide) }
	static var keyboardDidHide: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidHide) }
	static var keyboardWillChangeFrame: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillChangeFrame) }
	static var keyboardDidChangeFrame: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidChangeFrame) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol WindowConvertible: ViewConvertible {
	func uiWindow() -> Window.Instance
}
extension WindowConvertible {
	func uiView() -> View.Instance { return uiWindow() }
}
extension UIWindow: WindowConvertible {
	func uiWindow() -> Window.Instance { return self }
}
extension Window {
	func uiWindow() -> Window.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol WindowBinding: ViewBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
}
extension WindowBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
extension Window.Binding {
	typealias Preparer = Window.Preparer
	static func windowBinding(_ binding: Window.Binding) -> Window.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif
