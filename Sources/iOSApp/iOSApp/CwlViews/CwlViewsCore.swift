//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-04-20 01:26:10 +0000 from the following files:
//   CwlAdapter+Signals.swift
//   CwlAdapter.swift
//   CwlAdapterState.swift
//   CwlCodableContainer.swift
//   CwlMasterDetail.swift
//   CwlModelState.swift
//   CwlStackAdapter.swift
//   CwlTempVar.swift
//   CwlToggleVar.swift
//   CwlVar.swift
//   CwlAssociatedBinderStorage.swift
//   CwlBinder.swift
//   CwlBinderApplyable.swift
//   CwlBinderBase.swift
//   CwlBinderDelegate.swift
//   CwlBinderEmbedderConstructor.swift
//   CwlBinderPreparer.swift
//   CwlBinding.swift
//   CwlBindingName.swift
//   CwlConstant.swift
//   CwlDynamic.swift
//   CwlInitialSubsequent.swift
//   CwlScopedValues.swift
//   CwlSignalCallback.swift
//   CwlTargetAction.swift
//   CwlIndexedMutation.swift
//   CwlSetMutation.swift
//   CwlStackMutation.swift
//   CwlSubrangeMutation.swift
//   CwlTreeMutation.swift
//   CwlAnimatable.swift
//   CwlCoder.swift
//   CwlImageDrawn.swift
//   CwlKeyValueObservationLifetime.swift
//   CwlLayout.swift
//   CwlPreferredFonts.swift

import Foundation

extension Adapter: Lifetime {
	func cancel() {
		if State.self is CodableContainer.Type, let value = combinedSignal.peek()?.state, var sc = value as? CodableContainer {
			sc.cancel()
		}
		input.cancel()
	}
}

extension Adapter: Codable where State: Codable {
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(State.self)
		self.init(adapterState: p)
	}
	
	func encode(to encoder: Encoder) throws {
		if let s = combinedSignal.peek()?.state {
			var c = encoder.singleValueContainer()
			try c.encode(s)
		}
	}
}

extension Adapter: CodableContainer where State: PersistentAdapterState {
	var childCodableContainers: [CodableContainer] {
		if let state = combinedSignal.peek()?.state {
			return (state as? CodableContainer)?.childCodableContainers ?? []
		} else {
			return []
		}
	}
	
	var codableValueChanged: Signal<Void> {
		if State.self is CodableContainer.Type {
			return combinedSignal.flatMapLatest { (content: State.Output) -> Signal<Void> in
				let cc = content.state as! CodableContainer
				return cc.codableValueChanged.startWith(())
			}.dropActivation()
		}
		return combinedSignal.map { _ in () }.dropActivation()
	}
}

struct Adapter<State: AdapterState>: SignalInterface, SignalInputInterface {
	typealias OutputValue = State.Notification
	typealias InputValue = State.Message
	private enum Keys: CodingKey { case `var` }
	
	let executionContext: Exec

	let multiInput: SignalMultiInput<State.Message>
	var input: SignalInput<State.Message> { return multiInput }
	
	let combinedSignal: SignalMulti<State.Output>
	var signal: Signal<State.Notification> {
		return combinedSignal.compactMapActivation(select: .last, context: executionContext, activation: { $0.state.resume() }, remainder: { $0.notification })
	}
	
	init(adapterState: State? = nil) {
		let (i, s) = Signal<State.Message>.multiChannel().tuple
		multiInput = i
		
		if let state = adapterState {
			let (ec, async) = state.instanceContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(initialState: (state, nil), context: executionContext) { (content: State.Output, message: State.Message) throws -> State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		} else {
			let initializer = { (message: State.Message) throws -> State.Output? in
				try State.initialize(message: message, feedback: i)
			}
			let (ec, async) = State.defaultContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(context: executionContext, initializer: initializer) { (content: State.Output, message: State.Message) throws -> State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		}
	}
}

protocol AdapterState {
	associatedtype Message
	associatedtype Notification
	
	typealias Output = (state: Self, notification: Notification?)
	
	static var defaultContext: (Exec, Bool) { get }

	static func initialize(message: Message, feedback: SignalMultiInput<Message>) throws -> Output?

	var instanceContext: (Exec, Bool) { get }

	func reduce(message: Message, feedback: SignalMultiInput<Message>) throws -> Output
	func resume() -> Notification?
}

extension AdapterState {
	static var defaultContext: (Exec, Bool) {
		return (.direct, false)
	}
	
	var instanceContext: (Exec, Bool) {
		return Self.defaultContext
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) throws -> Output? {
		return nil
	}
	
	func resume() -> Notification? {
		return nil
	}
}

protocol NonPersistentAdapterState: AdapterState, Codable {
	init()
}

extension NonPersistentAdapterState {
	init(from decoder: Decoder) throws {
		self.init()
	}
	
	func encode(to encoder: Encoder) throws {
	}
}

extension Adapter {
	init<Value>() where TempValue<Value> == State {
		self.init(adapterState: TempValue<Value>())
	}
}

protocol PersistentAdapterState: AdapterState, Codable {
	associatedtype PersistentValue: Codable
	init(value: PersistentValue)
	var value: PersistentValue { get }
}

extension Adapter where State: PersistentAdapterState {
	var state: Signal<State> {
		return combinedSignal.compactMap { content in content.state }
	}
}

extension PersistentAdapterState {
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(PersistentValue.self)
		self.init(value: p)
	}
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.singleValueContainer()
		try c.encode(value)
	}
}

extension Adapter where State: PersistentAdapterState {
	func logJson(prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -> Lifetime {
		return codableValueChanged
			.startWith(())
			.subscribe { _ in
				let enc = JSONEncoder()
				enc.outputFormatting = formatting
				if let data = try? enc.encode(self), let string = String(data: data, encoding: .utf8) {
					print("\(prefix)\(string)")
				}
		}
	}
}

protocol CodableContainer: Lifetime, Codable {
	var codableValueChanged: Signal<Void> { get }
	var childCodableContainers: [CodableContainer] { get }
}

extension CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return Mirror(reflecting: self).children.compactMap { $0.value as? CodableContainer }
	}
	
	var codableValueChanged: Signal<Void> {
		let sequence = childCodableContainers.map { return $0.codableValueChanged }
		if sequence.isEmpty {
			return Signal<Void>.preclosed()
		} else if sequence.count == 1 {
			return sequence.first!
		} else {
			return Signal<Void>.merge(sequence: sequence)
		}
	}
	
	mutating func cancel() {
		for var v in childCodableContainers {
			v.cancel()
		}
	}
}

extension Array: Lifetime where Element: CodableContainer {
	mutating func cancel() {
		for var v in self {
			v.cancel()
		}
	}
}

extension Optional: Lifetime where Wrapped: CodableContainer {
	mutating func cancel() {
		self?.cancel()
	}
}

extension Array: CodableContainer where Element: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return flatMap { $0.childCodableContainers }
	}
}

extension Optional: CodableContainer where Wrapped: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return self?.childCodableContainers ?? []
	}
}

/// An "Either" type for use in scenarios where "Equatable" and "Codable" are required but there's only ever a single "Master" instance so equality is implied. This is common in Navigation Controller stacks and Split Views.
enum MasterDetail<Master: CodableContainer, Detail: CodableContainer>: CodableContainer {
	case master(Master)
	case detail(Detail)
	
	var childCodableContainers: [CodableContainer] {
		switch self {
		case .master(let tvm): return [tvm]
		case .detail(let dvm): return [dvm]
		}
	}
	
	enum Keys: CodingKey { case master, detail }
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.container(keyedBy: Keys.self)
		switch self {
		case .master(let tvm): try c.encode(tvm, forKey: .master)
		case .detail(let dvm): try c.encode(dvm, forKey: .detail)
		}
	}
	
	init(from decoder: Decoder) throws {
		let c = try decoder.container(keyedBy: Keys.self)
		if let tvm = try c.decodeIfPresent(Master.self, forKey: .master) {
			self = .master(tvm)
		} else {
			self = .detail(try c.decode(Detail.self, forKey: .detail))
		}
	}
}

struct ModelState<Wrapped, M, N>: AdapterState {
	typealias Message = M
	typealias Notification = N
	let instanceContext: (Exec, Bool) 
	
	let reducer: (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput<Message>) throws -> Notification?
	let resumer: (_ model: Wrapped) -> Notification?
	let wrapped: Wrapped
	
	init(previous: ModelState<Wrapped, M, N>, nextWrapped: Wrapped) {
		self.instanceContext = previous.instanceContext
		self.reducer = previous.reducer
		self.resumer = previous.resumer
		self.wrapped = nextWrapped
	}
	
	init(async: Bool = false, initial: Wrapped, resumer: @escaping (_ model: Wrapped) -> Notification? = { _ in nil }, reducer: @escaping (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput<Message>) throws -> Notification?) {
		self.instanceContext = (Exec.syncQueue(), async)
		self.reducer = reducer
		self.resumer = resumer
		self.wrapped = initial
	}

	func reduce(message: Message, feedback: SignalMultiInput<Message>) throws -> (state: ModelState<Wrapped, Message, Notification>, notification: N?) {
		var nextWrapped = wrapped
		let n = try reducer(&nextWrapped, message, feedback)
		return (ModelState<Wrapped, M, N>(previous: self, nextWrapped: nextWrapped), n)
	}
	
	func resume() -> Notification? {
		return resumer(wrapped)
	}
}


extension Adapter {
	func sync<Wrapped, R, M, N>(_ processor: (Wrapped) throws -> R) throws -> R where ModelState<Wrapped, M, N> == State {
		// Don't `peek` inside the `invokeSync` since that would require re-entering the `executionContext`.
		let wrapped = try combinedSignal.capture().get().state.wrapped
		return try executionContext.invokeSync { return try processor(wrapped) }
	}
	
	func slice<Wrapped, Processed, M, N>(resume: N? = nil, _ processor: @escaping (Wrapped, N) throws -> Signal<Processed>.Next) -> Signal<Processed> where ModelState<Wrapped, M, N> == State {
		let s: Signal<State.Output>
		if let r = resume {
			s = combinedSignal.compactMapLatestActivation(context: executionContext) {
				($0.state, r)
			}
		} else {
			s = combinedSignal
		}
		return s.transform(context: executionContext) { result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}
	
	func slice<Value, Wrapped, Processed, M, N>(initial: Value, resume: N? = nil, _ processor: @escaping (inout Value, Wrapped, N) throws -> Signal<Processed>.Next) -> Signal<Processed> where ModelState<Wrapped, M, N> == State {
		let s: Signal<State.Output>
		if let r = resume {
			s = combinedSignal.compactMapLatestActivation(context: executionContext) { ($0.state, r) }
		} else {
			s = combinedSignal
		}
		return s.transform(initialState: initial, context: executionContext) { value, result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(&value, wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}

	func logJson<Wrapped, M, N, Value>(keyPath: KeyPath<Wrapped, Value>, prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -> Lifetime where State == ModelState<Wrapped, M, N>, Value: Encodable {
		return combinedSignal.subscribeValues(context: executionContext) { (state, _) in
			let enc = JSONEncoder()
			enc.outputFormatting = formatting
			if let data = try? enc.encode(state.wrapped[keyPath: keyPath]), let string = String(data: data, encoding: .utf8) {
				print("\(prefix)\(string)")
			}
		}
	}
}

import Foundation

typealias StackAdapter<PathElement: Codable> = Adapter<StackAdapterState<PathElement>>

/// This "Adapter" is a `ModelSignalValue` that manages a stack of navigation items as might be used by a UINavigationController. The adapter converts `push`, `popToCount` and `reload` messages into updates to the array of `PathElement`. The adapter includes convenient input signals, animated output signals and includes automatic implementation of coding and notification protocols.
struct StackAdapterState<PathElement: Codable>: PersistentAdapterState {
	typealias Message = StackMutation<PathElement>
	typealias Notification = StackMutation<PathElement>
	
	let value: [PathElement]
	init(value: [PathElement]) {
		self.value = value
	}
	
	func reduce(message: Message, feedback: SignalMultiInput<Message>) -> Output {
		switch message {
		case .push(let e):
			let next = StackAdapterState<PathElement>(value: value.appending(e))
			return Output(state: next, notification: message)
		case .pop:
			let next = StackAdapterState<PathElement>(value: Array(value.dropLast()))
			return Output(state: next, notification: message)
		case .popToCount(let i):
			guard i >= 1 else { return Output(state: self, notification: nil) }
			let next = StackAdapterState<PathElement>(value: Array(value.prefix(i)))
			return Output(state: next, notification: message)
		case .reload(let newStack):
			let next = StackAdapterState<PathElement>(value: newStack)
			return Output(state: next, notification: message)
		}
	}
	
	func resume() -> Notification? {
		return Message.reload(value)
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return StackAdapterState<PathElement>(value: []).reduce(message: message, feedback: feedback)
	}
}

extension StackAdapterState: Codable where PathElement: Codable {}

extension StackAdapterState: Lifetime where PathElement: Lifetime {
	mutating func cancel() {
		for var l in value {
			l.cancel()
		}
		self = StackAdapterState(value: value.map { element in
			var e = element
			e.cancel()
			return e
		})
	}
}

extension StackAdapterState: CodableContainer where PathElement: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	var codableValueChanged: Signal<Void> {
		return value.codableValueChanged
	}
}

extension Adapter {
	init<PathElement: Codable>( _ value: [PathElement]) where StackAdapterState<PathElement> == State {
		self.init(adapterState: StackAdapterState<PathElement>(value: value))
	}
}

extension Adapter {
	func push<PathElement>() -> SignalInput<PathElement> where State.Message == StackMutation<PathElement> {
		return Signal<PathElement>.channel().map { State.Message.push($0) }.bind(to: input)
	}
	
	func popToCount<PathElement>() -> SignalInput<Int> where State.Message == StackMutation<PathElement> {
		return Signal<Int>.channel().map { State.Message.popToCount($0) }.bind(to: input)
	}
}

struct TempValue<Value>: NonPersistentAdapterState {
	typealias Message = Value
	typealias Notification = Value
	
	let temporaryValue: Value?
	init() {
		temporaryValue = nil
	}
	
	fileprivate init(temporaryValue: Value) {
		self.temporaryValue = temporaryValue
	}
	
	func reduce(message: Value, feedback: SignalMultiInput<Message>) -> Output {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
	
	func resume() -> Notification? {
		return temporaryValue
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
}

typealias TempVar<Value> = Adapter<TempValue<Value>>

struct ToggleValue: PersistentAdapterState {
	typealias Message = Void
	typealias Notification = Bool
	
	let value: Bool
	init(value: Bool) {
		self.value = value
	}
	
	func reduce(message: Void, feedback: SignalMultiInput<Message>) -> Output {
		return Output(state: ToggleValue(value: !value), notification: !value)
	}
	
	func resume() -> Notification? { return value }
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return nil
	}
}

typealias ToggleVar = Adapter<ToggleValue>

extension Adapter where State == ToggleValue {
	init(_ value: Bool) {
		self.init(adapterState: ToggleValue(value: value))
	}
}

typealias Var<Value: Codable> = Adapter<VarState<Value>>

struct VarState<Value: Codable>: PersistentAdapterState {
	enum Message {
		case set(Value)
		case update(Value)
		case notify(Value)
	}
	typealias Notification = Value
	
	let value: Value
	init(value: Value) {
		self.value = value
	}
	
	func reduce(message: Message, feedback: SignalMultiInput<Message>) -> Output {
		switch message {
		case .set(let v): return Output(state: VarState<Value>(value: v), notification: v)
		case .update(let v): return Output(state: VarState<Value>(value: v), notification: nil)
		case .notify(let v): return Output(state: self, notification: v)
		}
	}
	
	func resume() -> Notification? {
		return value
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		switch message {
		case .set(let v): return Output(state: VarState<Value>(value: v), notification: v)
		case .update(let v): return Output(state: VarState<Value>(value: v), notification: nil)
		case .notify: return nil
		}
	}
}

extension VarState: Codable where Value: Codable {}

extension VarState: Lifetime where Value: Lifetime {
	mutating func cancel() {
		var v = value
		v.cancel()
		self = VarState(value: v)
	}
}

extension VarState: CodableContainer where Value: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	var codableValueChanged: Signal<Void> {
		return value.codableValueChanged
	}
}

extension Adapter {
	init<Value>(_ value: Value) where VarState<Value> == State {
		self.init(adapterState: VarState<Value>(value: value))
	}
}

extension Adapter {
	func set<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input().map { VarState<Value>.Message.set($0) }.bind(to: self)
	}
	
	func update<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input().map { VarState<Value>.Message.update($0) }.bind(to: self)
	}
	
	func notify<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input<Value>().map { VarState<Value>.Message.notify($0) }.bind(to: self)
	}
	
	func allChanges<Value>() -> Signal<Value> where State == VarState<Value> {
		return combinedSignal.compactMap { combined in combined.notification ?? combined.state.value }
	}
	
	func stateChanges<Value>() -> Signal<Value> where State == VarState<Value> {
		return combinedSignal.compactMap { combined in combined.state.value }
	}
}

extension SignalInterface {
	func bind<InputInterface>(to interface: InputInterface) where InputInterface: SignalInputInterface, InputInterface.InputValue == VarState<OutputValue>.Message {
		return map { VarState<OutputValue>.Message.set($0) }.bind(to: interface)
	}
}

extension SignalChannel {
	func bind<Target>(to interface: Target) -> InputInterface where Target: SignalInputInterface, Target.InputValue == VarState<Interface.OutputValue>.Message {
		return final { $0.map { VarState<Interface.OutputValue>.Message.set($0) }.bind(to: interface) }.input
	}
}

extension BindingName {
	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><A>(name: BindingName<Value, Source, Binding>, value: Adapter<VarState<A>>) -> Binding where SignalInput<A> == Value {
		return name.binding(with: value.set())
	}
}

/// Implementation for `BinderStorage` that wraps Cocoa objects.
class AssociatedBinderStorage: NSObject {
	typealias Instance = NSObject
	private var lifetimes: [Lifetime]? = nil
	
	/// The embed function will avoid embedding and let the AssociatedBinderStorage release if this function returns false.
	/// Override and alter logic if a subclass may require the storage to persist when lifetimes is empty and the dynamic delegate is unused.
	var isInUse: Bool {
		guard let ls = lifetimes else { fatalError("Embed must be called before isInUse") }
		return ls.isEmpty == false || dynamicDelegate != nil
	}
	
	/// Implementation of the `BinderStorage` method to embed supplied lifetimes in an instance. This may be performed once-only for a given instance and storage (the storage should have the same lifetime as the instance and should not be disconnected once connected).
	///
	/// - Parameters:
	///   - lifetimes: lifetimes that will be stored in this storage
	///   - instance: an NSObject where this storage will embed itself
	func embed(lifetimes: [Lifetime], in instance: NSObjectProtocol) {
		assert(self.lifetimes == nil, "Bindings should be set once only")
		self.lifetimes = lifetimes
		guard isInUse else { return }
		
		assert(instance.associatedBinderStorage(subclass: AssociatedBinderStorage.self) == nil, "Bindings should be set once only")
		instance.setAssociatedBinderStorage(self)
	}
	
	/// Explicitly invoke `cancel` on each of the bindings.
	///
	/// WARNING: if `cancel` is invoked outside the main thread, it will be *asynchronously* invoked on the main thread.
	/// Normally, a `cancel` effect is expected to have synchronous effect but it since `cancel` on Binder objects is usually used for breaking reference counted loops, it is considered that the synchronous effect of cancel is less important than avoiding deadlocks â and deadlocks would be easy to accidentally trigger if this were synchronously invoked. If you need synchronous effect, ensure that cancel is invoked on the main thread.
	func cancel() {
		guard Thread.isMainThread else { DispatchQueue.main.async(execute: self.cancel); return }
		
		// `cancel` is mutating so we must use a `for var` (we can't use `forEach`)
		for var l in lifetimes ?? [] {
			l.cancel()
		}
		
		dynamicDelegate?.implementedSelectors = [:]
		dynamicDelegate = nil
	}
	
	deinit {
		cancel()
	}
	
	/// The `dynamicDelegate` is a work-around for the fact that some Cocoa objects change their behavior if you have a delegate that implements a given delegate method. Since Binders will likely implement *all* of their delegate methods, the dynamicDelegate can be used to selectively respond to particular selectors at runtime.
	var dynamicDelegate: DynamicDelegate?
	
	/// An override of the NSObject method so that the dynamicDelegate can work. When the dynamicDelegate states that it can respond to a given selector, that selector is directed to the dynamicDelegate instead. This function will only be involved if Objective-C message sends are sent to the BinderStorage â a rare occurrence outside of deliberate delegate invocations.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: the dynamicDelegate, if it implements the selector
	override func forwardingTarget(for selector: Selector) -> Any? {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return dd
		}
		return nil
	}
	
	/// An override of the NSObject method so that the dynamicDelegate can work.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: true if the dynamicDelegate implements the selector, otherwise returns the super implementation
	override func responds(to selector: Selector) -> Bool {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return true
		}
		return super.responds(to: selector)
	}
}

/// Used in conjunction with `AssociatedBinderStorage`, subclasses of `DynamicDelegate` can implement all delegate methods at compile time but have the `AssociatedBinderStorage` report true to `responds(to:)` only in the cases where the delegate method is selected for enabling.
class DynamicDelegate: NSObject, DefaultConstructable {
	var implementedSelectors = Dictionary<Selector, Any>()
	var associatedHandler: Any?
	
	required override init() {
		super.init()
	}
	
	func handlesSelector(_ selector: Selector) -> Bool {
		return implementedSelectors[selector] != nil
	}
	
	func multiHandler<T>(_ t: T) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T) -> Void]).forEach { f in f(t) }
	}
	
	func multiHandler<T, U>(_ t: T, _ u: U) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U) -> Void]).forEach { f in f(t, u) }
	}
	
	func multiHandler<T, U, V>(_ t: T, _ u: U, _ v: V) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V) -> Void]).forEach { f in f(t, u, v) }
	}
	
	func multiHandler<T, U, V, W>(_ t: T, _ u: U, _ v: V, _ w: W) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W) -> Void]).forEach { f in f(t, u, v, w) }
	}
	
	func multiHandler<T, U, V, W, X>(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W, X) -> Void]).forEach { f in f(t, u, v, w, x) }
	}
	
	func singleHandler<T, R>(_ t: T) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T) -> R))(t)
	}
	
	func singleHandler<T, U, R>(_ t: T, _ u: U) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U) -> R))(t, u)
	}
	
	func singleHandler<T, U, V, R>(_ t: T, _ u: U, _ v: V) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V) -> R))(t, u, v)
	}
	
	func singleHandler<T, U, V, W, R>(_ t: T, _ u: U, _ v: V, _ w: W) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W) -> R))(t, u, v, w)
	}
	
	func singleHandler<T, U, V, W, X, R>(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W, X) -> R))(t, u, v, w, x)
	}
	
	func addSingleHandler1<T, R>(_ value: @escaping (T) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler2<T, U, R>(_ value: @escaping (T, U) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler3<T, U, V, R>(_ value: @escaping (T, U, V) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler4<T, U, V, W, R>(_ value: @escaping (T, U, V, W) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler5<T, U, V, W, X, R>(_ value: @escaping (T, U, V, W, X) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addMultiHandler1<T>(_ value: @escaping (T) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T) -> Void]
		}
	}
	
	func addMultiHandler2<T, U>(_ value: @escaping (T, U) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U) -> Void]
		}
	}
	
	func addMultiHandler3<T, U, V>(_ value: @escaping (T, U, V) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V) -> Void]
		}
	}
	
	func addMultiHandler4<T, U, V, W>(_ value: @escaping (T, U, V, W) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W) -> Void]
		}
	}
	
	func addMultiHandler5<T, U, V, W, X>(_ value: @escaping (T, U, V, W, X) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W, X) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W, X) -> Void]
		}
	}
}

private var associatedBinderStorageKey = NSObject()
extension NSObjectProtocol {
	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter for: an NSObject
	/// - Returns: the embedded AssociatedBinderStorage (if any)
	func associatedBinderStorage<S: AssociatedBinderStorage>(subclass: S.Type) -> S? {
		return objc_getAssociatedObject(self, &associatedBinderStorageKey) as? S
	}

	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter newValue: an AssociatedBinderStorage or nil (if clearinging storage)
	func setAssociatedBinderStorage(_ newValue: AssociatedBinderStorage?) {
		objc_setAssociatedObject(self, &associatedBinderStorageKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

enum BinderState<Preparer: BinderPreparer> {
	case pending(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding])
	case constructed(Preparer.Output)
	case consumed
}

protocol Binder: class {
	associatedtype Preparer: BinderPreparer
	
	var state: BinderState<Preparer> { get set }
	init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) 
}

extension Binder {
 	typealias Instance = Preparer.Instance
	typealias Parameters = Preparer.Parameters
	typealias Output = Preparer.Output
	
	/// Invokes `consume` on the underlying state. If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// - Returns: the array of `Binding` from the state parameters.
	func consume() -> (type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		guard case .pending(let type, let parameters, let bindings) = state else {
			fatalError("Attempted to consume bindings from already constructed or consumed binder.")
		}
		state = .consumed
		return (type: type, parameters: parameters, bindings: bindings)
	}
}

extension Binder where Preparer.Parameters == Void {
	/// A constructor used when dynamically assembling arrays of bindings
	///
	/// - Parameters:
	///   - bindings: array of bindings
	init(type: Preparer.Instance.Type = Preparer.Instance.self, bindings: [Preparer.Binding]) {
		self.init(type: type, parameters: (), bindings: bindings)
	}

	/// A constructor for a binder.
	///
	/// - Parameters:
	///   - bindings: list of bindings
	init(type: Preparer.Instance.Type = Preparer.Instance.self, _ bindings: Preparer.Binding...) {
		self.init(type: type, parameters: (), bindings: bindings)
	}
}

private extension Binder where Preparer: BinderApplyable {
	var constructed: Preparer.Output? {
		guard case .constructed(let output) = state else { return nil }
		return output
	}
}

extension Binder where Preparer: BinderApplyable {
	func apply(to instance: Preparer.Instance) {
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		_ = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
	}
}

extension Binder where Preparer: BinderConstructor, Preparer.Instance == Preparer.Output {
	func instance() -> Preparer.Instance {
		if let output = constructed { return output }
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}

	func instance(parameters: Parameters) -> Preparer.Instance {
		if let output = constructed { return output }
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}
}

extension Binder where Preparer: BinderApplyable, Preparer.Storage == Preparer.Output {
	func wrap(instance: Preparer.Instance) -> Preparer.Output {
		if let output = constructed { return output }
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .consumed
		return output
	}
}

extension Binder where Preparer: BinderConstructor, Preparer.Storage == Preparer.Output {
	func construct() -> Preparer.Output {
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
	
	func construct(parameters: Parameters) -> Preparer.Output {
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
}

/// Preparers usually default construct the `Storage` except in specific cases where the storage needs a reference to the instance.
protocol BinderApplyable: BinderPreparer {
	/// Constructs the `Storage`
	///
	/// - Returns: the storage
	func constructStorage(instance: Instance) -> Storage
	
	/// - Returns: the output, after tying the lifetimes of the instance and storage together
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -> Output
}

extension BinderApplyable {
	static func bind(_ bindings: [Binding], to source: (_ preparer: Self) -> Instance) -> (Self, Instance, Storage, [Lifetime]) {
		var preparer = Self()
		for b in bindings {
			preparer.prepareBinding(b)
		}
		
		var lifetimes = [Lifetime]()
		let instance = source(preparer)
		let storage = preparer.constructStorage(instance: instance)
		
		preparer.prepareInstance(instance, storage: storage)
		
		for b in bindings {
			lifetimes += preparer.applyBinding(b, instance: instance, storage: storage)
		}
		
		lifetimes += preparer.finalizeInstance(instance, storage: storage)
		
		return (preparer, instance, storage, lifetimes)
	}
}


struct BinderBase: BinderPreparer {
	typealias Instance = Any
	typealias Storage = Any

	enum Binding: BinderBaseBinding {
		case lifetimes(Dynamic<[Lifetime]>)
		case adHocPrepare((Any) -> Void)
		case adHocFinalize((Any) -> Lifetime?)
	}

	var inherited: BinderBase { get { return self } set { } }
	var adHocPrepareClosures: [(Any) -> Void]?
	var adHocFinalizeClosures: [(Any) -> Lifetime?]?

	init() {}
	
	func inheritedBinding(from: BinderBase.Binding) -> BinderBase.Binding? { return nil }
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .adHocPrepare(let x): adHocPrepareClosures = adHocPrepareClosures?.appending(x) ?? [x]
		case .adHocFinalize(let x): adHocFinalizeClosures = adHocFinalizeClosures?.appending(x) ?? [x]
		default: break
		}
	}
	func prepareInstance(_ instance: Instance, storage: Storage) {
		adHocPrepareClosures.map { array in array.forEach { c in c(instance) } }
	}
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .lifetimes(let x):
			switch x {
			case .constant(let lifetimes):
				return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
			case .dynamic(let signal):
				var previous: [Lifetime]?
				return signal.subscribe(context: .main) { next in
					if var previous = previous {
						for i in previous.indices {
							previous[i].cancel()
						}
					}
					if case .success(let next) = next {
						previous = next
					}
				}
			}
		case .adHocPrepare: return nil
		case .adHocFinalize: return nil
		}
	}
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		return adHocFinalizeClosures.map { array in AggregateLifetime(lifetimes: array.compactMap { c in c(instance) }) }
	}
	func combine(lifetimes: [Lifetime], instance: Any, storage: Any) -> Any { return () }
}

protocol BinderBaseBinding: Binding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self
}
extension BinderBase.Binding {
	typealias Preparer = BinderBase
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> BinderBase.Binding { return binding }
}

extension BindingName where Binding: BinderBaseBinding {
	typealias BinderBaseName<V> = BindingName<V, BinderBase.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BinderBase.Binding) -> BinderBaseName<V> {
		return BinderBaseName<V>(source: source, downcast: Binding.binderBaseBinding)
	}
}
extension BindingName where Binding: BinderBaseBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BinderBaseName<$2> { return .name(BinderBase.Binding.$1) }
	static var lifetimes: BinderBaseName<Dynamic<[Lifetime]>> { return .name(BinderBase.Binding.lifetimes) }

	static var adHocPrepare: BinderBaseName<(Binding.Preparer.Instance) -> Void> {
		return Binding.compositeName(
			value: { f in { (any: Any) -> Void in f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocPrepare,
			downcast: Binding.binderBaseBinding
		)
	}

	static var adHocFinalize: BinderBaseName<(Binding.Preparer.Instance) -> Lifetime?> {
		return Binding.compositeName(
			value: { f in { (any: Any) -> Lifetime? in return f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocFinalize,
			downcast: Binding.binderBaseBinding
		)
	}
}

protocol BinderDelegateEmbedder: BinderEmbedder where Instance: HasDelegate {
	associatedtype Delegate: DynamicDelegate
	init(delegateClass: Delegate.Type)
	var delegateClass: Delegate.Type { get }
	var dynamicDelegate: Delegate? { get set }
	var delegateIsRequired: Bool { get }
	func prepareDelegate(instance: Instance, storage: Storage)
}

typealias BinderDelegateEmbedderConstructor = BinderDelegateEmbedder & BinderConstructor

protocol HasDelegate: class {
	associatedtype DelegateProtocol
	var delegate: DelegateProtocol? { get set }
}

extension BinderDelegateEmbedder {
	init() {
		self.init(delegateClass: Delegate.self)
	}
	
	var delegateIsRequired: Bool { return dynamicDelegate != nil }
	
	mutating func delegate() -> Delegate {
		if let d = dynamicDelegate {
			return d
		} else {
			let d = delegateClass.init()
			dynamicDelegate = d
			return d
		}
	}
}

extension BinderDelegateEmbedder where Delegate: DynamicDelegate {
	func prepareDelegate(instance: Instance, storage: Storage) {
		if delegateIsRequired {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			if dynamicDelegate != nil {
				storage.dynamicDelegate = dynamicDelegate
			}
			instance.delegate = (storage as! Instance.DelegateProtocol)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
	}
}

protocol BinderDelegateDerived: BinderEmbedderConstructor where Inherited: BinderDelegateEmbedderConstructor {
	init(delegateClass: Inherited.Delegate.Type)
}

extension BinderDelegateDerived {
	typealias Delegate = Inherited.Delegate
	init() {
		self.init(delegateClass: Inherited.Delegate.self)
	}
	var dynamicDelegate: Inherited.Delegate? {
		get { return inherited.dynamicDelegate }
		set { inherited.dynamicDelegate = newValue }
	}
}

/// Preparers usually construct the `Instance` from a subclass type except in specific cases where additional non-binding parameters are required for instance construction.
protocol BinderConstructor: BinderApplyable {
	/// Constructs the `Instance`
	///
	/// - Parameter subclass: subclass of the instance type to use for construction
	/// - Returns: the instance
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance
}

extension BinderConstructor where Instance: DefaultConstructable {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init()
	}
}

/// All NSObject instances can use AssociatedBinderStorage which embeds lifetimes in the Objective-C associated object storage.
protocol BinderEmbedder: BinderApplyable where Instance: NSObjectProtocol, Storage: AssociatedBinderStorage, Output == Instance {}
extension BinderEmbedder {
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -> Output {
		storage.embed(lifetimes: lifetimes, in: instance)
		return instance
	}
}

/// A `BinderEmbedderConstructor` is the standard configuration for a constructable NSObject.
typealias BinderEmbedderConstructor = BinderEmbedder & BinderConstructor

protocol DefaultConstructable {
	init()
}

/// A preparer interprets a set of bindings and applies them to an instance.
protocol BinderPreparer: DefaultConstructable {
	associatedtype Instance
	associatedtype Output = Instance
	associatedtype Parameters = Void
	associatedtype Binding
	associatedtype Storage
	associatedtype Inherited: BinderPreparer

	var inherited: Inherited { get set }
	
	func inheritedBinding(from: Binding) -> Inherited.Binding?
	
	/// A first scan of the bindings. Information about bindings present may be recorded during this time.
	///
	/// NOTE: you don't need to process all bindings at your own level but you should pass inherited bindings through
	/// to the inherited preparer (unless you're handling it at your own level)
	///
	/// - Parameter binding: the binding to apply
	mutating func prepareBinding(_ binding: Binding)
	
	/// Bindings which need to be applied before others can be applied at this special early stage
	///
	/// NOTE: the first step should be to call `inheritedPrepareInstance`. `BinderDelegate` should call `prepareDelegate`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	func prepareInstance(_ instance: Instance, storage: Storage)
	
	/// Apply typical bindings.
	///
	/// NOTE: you should process all bindings and pass inherited bindings through to the inherited preparer
	///
	/// - Parameters:
	///   - binding: the binding to apply
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`.
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime?
	
	/// Bindings which need to be applied after others can be applied at this last stage.
	///
	/// NOTE: the last step should be to call `inheritedFinalizedInstance`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime?
}

extension BinderPreparer {
	mutating func inheritedPrepareBinding(_ binding: Binding) {
		guard let ls = inheritedBinding(from: binding) else { return }
		inherited.prepareBinding(ls)
	}

	mutating func prepareBinding(_ binding: Binding) {
		inheritedPrepareBinding(binding)
	}
	
	func inheritedPrepareInstance(_ instance: Instance, storage: Storage) {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return }
		inherited.prepareInstance(i, storage: s)
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
	}
	
	func inheritedApplyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		guard let ls = inheritedBinding(from: binding), let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.applyBinding(ls, instance: i, storage: s)
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		return inheritedApplyBinding(binding, instance: instance, storage: storage)
	}
	
	func inheritedFinalizedInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.finalizeInstance(i, storage: s)
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

import Foundation

protocol Binding {
	associatedtype Preparer: BinderPreparer
}

extension Binding {
	static func compositeName<Value, Param, Intermediate>(value: @escaping (Value) -> Param, binding: @escaping (Param) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<Value, Intermediate, Self> {
		return BindingName<Value, Intermediate, Self>(
			source: { v in binding(value(v)) },
			downcast: downcast
		)
	}
	
	static func keyPathActionName<Instance, Value, Intermediate>(_ keyPath: KeyPath<Instance, Value>, _ binding: @escaping (TargetAction) -> Intermediate, _ downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Value>, Intermediate, Self> {
		return compositeName(
			value: { input in
				TargetAction.singleTarget(
					Input<Any?>().map { v in (v as! Instance)[keyPath: keyPath] }.bind(to: input)
				)
			},
			binding: binding,
			downcast: downcast
		)
	}
	
	static func mappedInputName<Value, Mapped, Intermediate>(map: @escaping (Value) -> Mapped, binding: @escaping (SignalInput<Value>) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Mapped>, Intermediate, Self> {
		return compositeName(
			value: { Input<Value>().map(map).bind(to: $0) },
			binding: binding,
			downcast: downcast
		)
	}
	
	static func mappedWrappedInputName<Value, Mapped, Param, Intermediate>(map: @escaping (Value) -> Mapped, wrap: @escaping (SignalInput<Value>) -> Param, binding: @escaping (Param) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Mapped>, Intermediate, Self> {
		return compositeName(
			value: { wrap(Input<Value>().map(map).bind(to: $0)) },
			binding: binding,
			downcast: downcast
		)
	}
}

infix operator --: AssignmentPrecedence
infix operator <--: AssignmentPrecedence
infix operator -->: AssignmentPrecedence

struct BindingName<Value, Source, Binding> {
	var source: (Value) -> Source
	var downcast: (Source) -> Binding
	init(source: @escaping (Value) -> Source, downcast: @escaping (Source) -> Binding) {
		self.source = source
		self.downcast = downcast
	}
	func binding(with value: Value) -> Binding {
		return downcast(source(value))
	}
}

extension BindingName {
	/// Build a signal binding (invocations on the instance after construction) from a name and a signal
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Source, Binding>, value: Interface) -> Binding where Signal<Interface.OutputValue> == Value {
		return name.binding(with: value.signal)
	}

	/// Build a value binding (property changes on the instance) from a name and a signal (values over time)
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Source, Binding>, value: Interface) -> Binding where Dynamic<Interface.OutputValue> == Value {
		return name.binding(with: Dynamic<Interface.OutputValue>.dynamic(value.signal))
	}

	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<Value, Source, Binding>, value: InputInterface) -> Binding where SignalInput<InputInterface.InputValue> == Value {
		return name.binding(with: value.input)
	}

	/// Build a static binding (construction-only property) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Constant<A> == Value {
		return name.binding(with: Value.constant(value))
	}
	
	/// Build a value binding (property changes on the instance) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Dynamic<A> == Value {
		return name.binding(with: Dynamic<A>.constant(value))
	}

	/// Build a delegate binding (synchronous callback) from a name and function with no parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<R>(name: BindingName<Value, Source, Binding>, value: @escaping () -> R) -> Binding where Value == () -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with one parameter
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A) -> R) -> Binding where Value == (A) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with two parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B) -> R) -> Binding where Value == (A, B) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with three parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C) -> R) -> Binding where Value == (A, B, C) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with four parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C, D) -> R) -> Binding where Value == (A, B, C, D) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with five parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, E, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C, D, E) -> R) -> Binding where Value == (A, B, C, D, E) -> R {
		return name.binding(with: value)
	}
}

extension BindingName where Value == TargetAction {
	/// Build an `TargetAction` binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<TargetAction, Source, Binding>, value: InputInterface) -> Binding where InputInterface.InputValue == Any? {
		return name.binding(with: .singleTarget(value.input))
	}
	
	/// Build a first-responder `TargetAction` binding (callbacks triggered by the instance) from a name and a selector.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func -->(name: BindingName<TargetAction, Source, Binding>, value: Selector) -> Binding {
		return name.binding(with: TargetAction.firstResponder(value))
	}
}

/// A simple wrapper around a value used to identify "static" bindings (bindings which are applied only at construction time)
struct Constant<Value> {
	typealias ValueType = Value
	let value: Value
	init(_ value: Value) {
		self.value = value
	}
	static func constant(_ value: Value) -> Constant<Value> {
		return Constant<Value>(value)
	}
}


/// An either type for a value or a signal emitting values of that type. Used for "value" bindings (bindings which set a property on the underlying instance)
enum Dynamic<Value> {
	typealias ValueType = Value
	case constant(Value)
	case dynamic(Signal<Value>)
	
	/// Gets the initial (i.e. used in the constructor) value from the `Dynamic`
	func initialSubsequent() -> InitialSubsequent<Value> {
		switch self {
		case .constant(let v):
			return InitialSubsequent<Value>(initial: v)
		case .dynamic(let signal):
			let sc = signal.capture()
			return InitialSubsequent<Value>(initial: sc.values.last, subsequent: sc)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply<I: AnyObject, B: AnyObject>(_ instance: I, _ storage: B, _ onError: Value? = nil, handler: @escaping (I, B, Value) -> Void) -> Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, storage, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, storage, onError, handler: handler)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, Value) -> Void) -> Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, handler: handler)
		}
	}
}

extension Signal {
	func apply<I: AnyObject, B: AnyObject>(_ instance: I, _ storage: B, _ onError: OutputValue? = nil, handler: @escaping (I, B, OutputValue) -> Void) -> Lifetime? {
		return signal.subscribe(context: .main) { [unowned instance, unowned storage] r in
			switch (r, onError) {
			case (.success(let v), _): handler(instance, storage, v)
			case (.failure, .some(let v)): handler(instance, storage, v)
			case (.failure, .none): break
			}
		}
	}

	func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, OutputValue) -> Void) -> Lifetime? {
		return signal.subscribeValues(context: .main) { [unowned instance] v in handler(instance, v) }
	}
}

struct InitialSubsequent<Value> {
	let initial: Value?
	let subsequent: SignalCapture<Value>?
	
	init<Interface: SignalInterface>(signal: Interface) where Interface.OutputValue == Value {
		let capture = signal.capture()
		let values = capture.values
		self.init(initial: values.last, subsequent: capture)
	}
	
	init(initial: Value? = nil, subsequent: SignalCapture<Value>? = nil) {
		self.initial = initial
		self.subsequent = subsequent
	}
	
	func resume() -> Signal<Value>? {
		return subsequent?.resume()
	}
	
	func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, Value) -> Void) -> Lifetime? {
		return resume().flatMap { $0.apply(instance, handler: handler) }
	}
	
	func apply<I: AnyObject, Storage: AnyObject>(_ instance: I, _ storage: Storage, handler: @escaping (I, Storage, Value) -> Void) -> Lifetime? {
		return resume().flatMap { $0.apply(instance, storage, handler: handler) }
	}
}

import Foundation

struct ScopedValues<Scope, Value>: ExpressibleByArrayLiteral {
	typealias ArrayLiteralElement = ScopedValues<Scope, Value>

	let pairs: [(scope: Scope, value: Value)]
	
	init(arrayLiteral elements: ScopedValues<Scope, Value>...) {
		self.pairs = elements.flatMap { $0.pairs }
	}
	
	init(pairs: [(Scope, Value)]) {
		self.pairs = pairs
	}
	
	init(scope: Scope, value: Value) {
		self.pairs = [(scope, value)]
	}
	
	static func value(_ value: Value, for scope: Scope) -> ScopedValues<Scope, Value> {
		return ScopedValues(scope: scope, value: value)
	}
}

extension Dynamic {
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply<I: AnyObject, Scope, V>(instance: I, removeOld: @escaping (I, Scope, V) -> Void, applyNew: @escaping (I, Scope, V) -> Void) -> Lifetime? where ScopedValues<Scope, V> == Value {
		var previous: ScopedValues<Scope, V>? = nil
		return apply(instance) { i, v in
			for (scope, value) in previous?.pairs ?? [] {
				removeOld(instance, scope, value)
			}
			previous = v
			for (scope, value) in v.pairs {
				applyNew(instance, scope, value)
			}
		}
	}
}

struct Callback<Value, CallbackValue> {
	let value: Value
	let callback: SignalInput<CallbackValue>
	
	init(_ value: Value, _ callback: SignalInput<CallbackValue>) {
		self.value = value
		self.callback = callback
	}
}

extension SignalInterface {
	func callbackBind<CallbackInputInterface: SignalInputInterface>(to callback: CallbackInputInterface) -> Signal<Callback<OutputValue, CallbackInputInterface.InputValue>> {
		return map { value in Callback(value, callback.input) }
	}

	func ignoreCallback<CallbackValue>() -> Signal<Callback<OutputValue, CallbackValue>> {
		let (i, _) = Signal<CallbackValue>.create()
		return map { value in Callback(value, i) }
	}
}

/// This type encapsulates the idea that target-action pairs in Cocoa may target a specific object (by setting the target to non-nil) or may let the responder chain search for a responder that handles a specific selector.
enum TargetAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<Any?>)
}

protocol TargetActionSender: class {
	var action: Selector? { get set }
	var target: AnyObject? { get set }
}

extension TargetAction {
	func apply<Source: TargetActionSender>(to instance: Source, constructTarget: () -> SignalActionTarget, selector: Selector = SignalActionTarget.selector) -> Lifetime? {
		switch self {
		case .firstResponder(let s):
			instance.target = nil
			instance.action = s
			return nil
		case .singleTarget(let s):
			let target = constructTarget()
			instance.target = target
			instance.action = SignalActionTarget.selector
			return target.signal.cancellableBind(to: s)
		}
	}
}

/// This enum is intended to be embedded in an ArrayMutation<Element>. The ArrayMutation<Element> combines an IndexSet with this enum. This enum specifies what actions should be taken at the locations specified by the IndexSet.
///
/// 
enum IndexedMutationKind {
	/// The values at the locations specified by the IndexSet should be deleted.
	/// NOTE: the IndexSet specifies the indexes *before* deletion (and must therefore be applied in reverse).
	case delete

	/// The associated Array<Element> contains values that should be inserted such that they have the indexes specified in IndexSet. The Array<Element> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case insert

	/// Elements are deleted from one end and inserted onto the other. If `Int` is positive, values are deleted from the `startIndex` end and inserted at the `endIndex` end, if `Int` is negative, value are deleted from the `endIndex` end and inserted at the `startIndex`end.
	/// The magnitude of `Int` specifies the number of deleted rows and the sign specified the end.
	/// The Array<Element> contains values that should be inserted at the other end of the collection.
	/// The IndexSet contains the indexes of any revealed (scrolled into view) rows
	case scroll(Int)

	/// The associated Array<Element> contains updated values at locations specified by the IndexSet. Semantically, the item should be modelled as updated but not replaced. The Array<Element> and IndexSet must have identical counts.
	// In many cases, update and replace are the same. The only differences relate to scenarios where the items are considered to have "identity". An update *retains* the previous identity whereas a replace *discards* any previous identity.
	case update
	
	/// The values at the locations specified by the IndexSet should be removed from their locations and spliced back in at the location specified by the associated Int index. For scrolled subranges, items may not be moved from outside or to outside the visible range (items moved from outside the visible range must be inserted and items moved outside the visible range must be deleted)
	/// NOTE: the IndexSet specifies the indexes *before* removal (and must therefore be applied in reverse) and the Int index specifies an index *after* removal.
	case move(Int)

	/// Equivalent to a Deletion of all previous indexes and an Insertion of the new values. The associated Array<Element> contains the new state of the array. All previous values should be discarded and the entire array replaced with this new version. The Array<Element> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case reload
}

/// An `ArrayMutation` communicates changes to an array in one context so that another array, mirroring its contents in another context, can mimic the same changes.
/// Subscribing to a stream of `ArrayMutation`s is sufficient to communication the complete state and animatable transitions of an array between to parts of a program.
/// In most cases, the source and destination will need to keep their own complete copy of the array to correctly calculate the effect of the mutation.
struct IndexedMutation<Element, Metadata>: ExpressibleByArrayLiteral {
	/// Determines the meaning of this `ArrayMutation`
	let kind: IndexedMutationKind

	/// The metadats type is typically `Void` for plain array mutations since application of an indexed mutation to an array leaves no storage for metadata.
	/// Subrange and tree mutations use the metadata for subrange details and "leaf" data but require specialized storage structures to receive that data. The semantics of the metadata is specific to the respective `apply` functions.
	/// NOTE: Any non-nil metadata is typically set buy the mutation but a metadata value of `nil` doesn't clear the metadata, it usually just has no effect. The exception is `.reload` operations which function like re-creating the storage and explicitly set the value in all cases.
	let metadata: Metadata?
	
	/// The meaning of the indexSet is dependent on the `kind` â it may contain indexes in the array that will be deleted by this mutation or it may contain indexes that new entries will occupy after application of this mutation.
	let indexSet: IndexSet
	
	/// New values that will be inserted at locations determined by the `kind` and the `indexSet`.
	let values: Array<Element>
	
	/// Construct from components.
	init(kind: IndexedMutationKind, metadata: Metadata?, indexSet: IndexSet, values: Array<Element>) {
		self.kind = kind
		self.metadata = metadata
		self.indexSet = indexSet
		self.values = values
	}
}

extension IndexedMutation {
	/// Construct an empty array mutation that represents a no-op.
	init() {
		self.init(kind: .update, metadata: nil, indexSet: IndexSet(), values: [])
	}
	
	/// A .reload mutation can be constructed from an array literal (since it is equivalent to an array assignment).
	init(arrayLiteral elements: Element...) {
		self.init(kind: .reload, metadata: nil, indexSet: IndexSet(integersIn: elements.indices), values: elements)
	}

	/// Construct a mutation that discards any previous history and simply starts with a completely new array.
	init(metadata: Metadata? = nil, reload values: Array<Element>) {
		self.init(kind: .reload, metadata: metadata, indexSet: IndexSet(integersIn: values.indices), values: values)
	}

	/// Construct a mutation that represents a metadata-only change.
	init(metadata: Metadata) {
		self.init(kind: .update, metadata: metadata, indexSet: IndexSet(), values: [])
	}

	/// Construct a mutation that represents the deletion of the values at a set of indices.
	init(metadata: Metadata? = nil, deletedIndexSet: IndexSet) {
		self.init(kind: .delete, metadata: metadata, indexSet: deletedIndexSet, values: [])
	}
	
	/// Construct a mutation that represents advancing the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollForwardRevealing indexSet: IndexSet, values: Array<Element>) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents retreating the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollBackwardRevealing indexSet: IndexSet, values: Array<Element>) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(-indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, insertedIndexSet: IndexSet, values: Array<Element>) {
		precondition(insertedIndexSet.count == values.count)
		self.init(kind: .insert, metadata: metadata, indexSet: insertedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, updatedIndexSet: IndexSet, values: Array<Element>) {
		precondition(updatedIndexSet.count == values.count)
		self.init(kind: .update, metadata: metadata, indexSet: updatedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, movedIndexSet: IndexSet, targetIndex: Int) {
		self.init(kind: .move(targetIndex), metadata: metadata, indexSet: movedIndexSet, values: [])
	}
	

	/// Convenience constructor for deleting a single element
	static func deleted(at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(deletedIndexSet: IndexSet(integer: index))
	}
	
	/// Convenience constructor for inserting a single element
	static func inserted(_ value: Element, at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(insertedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func updated(_ value: Element, at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(updatedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func moved(from oldIndex: Int, to newIndex: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(movedIndexSet: IndexSet(integer: oldIndex), targetIndex: newIndex)
	}
	
	/// Convenience constructor for reloading
	static func reload(metadata: Metadata? = nil, _ values: [Element]) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(reload: values)
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapValues<Other>(_ transform: (Element) -> Other) -> IndexedMutation<Other, Metadata> {
		return IndexedMutation<Other, Metadata>(kind: kind, metadata: metadata, indexSet: indexSet, values: values.map(transform))
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapMetadata<Alternate>(_ transform: (Metadata) -> Alternate) -> IndexedMutation<Element, Alternate> {
		return IndexedMutation<Element, Alternate>(kind: kind, metadata: metadata.map(transform), indexSet: indexSet, values: values)
	}
	
	/// Given a previous row count, returns the new row count after this mutation
	///
	/// - Parameter rowCount: old number of rows
	func delta(_ rowCount: inout Int) {
		switch kind {
		case .reload: rowCount = values.count
		case .delete: rowCount -= indexSet.count
		case .scroll(let offset): rowCount += values.count - (offset > 0 ? offset : -offset)
		case .insert: rowCount += values.count
		case .move: return
		case .update: return
		}
	}
	
	/// A no-op on rows is explicitly defined as an `.update` with an empty `values` array. Note that metadata may still be non-nil.
	var hasNoEffectOnValues: Bool {
		if case .update = kind, values.count == 0 {
			return true
		}
		return false
	}
	
	func insertionsAndRemovals(length: Int, insert: (Int, Element) -> Void, remove: (Int) -> Void) {
		switch kind {
		case .delete:
			indexSet.reversed().forEach { remove($0) }
		case .scroll(let offset):
			if offset > 0 {
				(0..<offset).forEach { remove($0) }
				values.enumerated().forEach { insert(length - offset + $0.offset, $0.element) }
			} else {
				((length + offset)..<length).forEach { remove($0) }
				values.enumerated().forEach { insert($0.offset, $0.element) }
			}
		case .move(let index):
			indexSet.forEach { remove($0) }
			values.enumerated().forEach { insert(index + $0.offset, $0.element) }
		case .insert:
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .update:
			indexSet.forEach { remove($0) }
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .reload:
			(0..<length).reversed().forEach { remove($0) }
			values.enumerated().forEach { insert($0.offset, $0.element) }
		}
	}
}

typealias ArrayMutation<Element> = IndexedMutation<Element, Void>

extension IndexedMutation where Metadata == Void {
	/// Apply the mutation described by this value to the provided array
	func apply<C: RangeReplaceableCollection & MutableCollection>(to a: inout C) where C.Index == Int, C.Iterator.Element == Element {
		switch kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
		case .scroll(let offset):
			a.removeSubrange(offset > 0 ? a.startIndex..<offset : (a.endIndex + offset)..<a.endIndex)
			a.insert(contentsOf: values, at: offset > 0 ? a.endIndex : a.startIndex)
		case .move(let index):
			let moving = indexSet.map { a[$0] }
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
			a.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				a.insert(v, at: i)
			}
		case .update:
			var progress = 0
			indexSet.rangeView.forEach { r in
				a.replaceSubrange(r, with: values[progress..<(progress + r.count)])
				progress += r.count
			}
		case .reload:
			a.replaceSubrange(a.startIndex..<a.endIndex, with: values)
		}
	}
}

import Foundation

enum SetMutationKind {
	case delete
	case insert
	case update
	case reload
}

struct SetMutation<Element> {
	let kind: SetMutationKind
	let values: Array<Element>
	
	init(kind: SetMutationKind, values: Array<Element>) {
		self.kind = kind
		self.values = values
	}
	
	static func delete(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .delete, values: values)
	}
	
	static func insert(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .insert, values: values)
	}
	
	static func update(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .update, values: values)
	}
	
	static func reload(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .reload, values: values)
	}
	
	func apply(to array: inout Array<Element>, equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> [ArrayMutation<Element>] {
		switch kind {
		case .delete:
			var sorted = values.sorted(by: compare)
			var oldIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if !equate(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					oldIndices.insert(arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			precondition(sortedIndex == sorted.count, "Unable to find deleted items.")
			oldIndices.reversed().forEach { array.remove(at: $0) }
			return [ArrayMutation<Element>(deletedIndexSet: oldIndices)]
		case .insert:
			var sorted = values.sorted(by: compare)
			var newIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if compare(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					newIndices.insert(arrayIndex)
					array.insert(sorted[sortedIndex], at: arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			while sortedIndex < sorted.count {
				newIndices.insert(arrayIndex)
				array.insert(sorted[sortedIndex], at: arrayIndex)
				sortedIndex += 1
				arrayIndex += 1
			}
			return [ArrayMutation<Element>(insertedIndexSet: newIndices, values: sorted)]
		case .update:
			// It would be nice if this was better than n squared complexity and aggregated the updates, rather than issueing updates for individual rows.
			var result = Array<ArrayMutation<Element>>()
			for v in values {
				let oldIndex = array.firstIndex { u in equate(v, u) }!
				array.remove(at: oldIndex)
				let newIndex = array.firstIndex { u in compare(v, u) } ?? array.count
				array.insert(v, at: newIndex)
				if newIndex == oldIndex {
					result.append(.updated(v, at: oldIndex))
				} else {
					// This ordering (moved, then updated) is required to make UITableView animations work correctly.
					result.append(.moved(from: oldIndex, to: newIndex))
					result.append(.updated(v, at: newIndex))
				}
			}
			return result
		case .reload:
			array = values.sorted(by: compare)
			return [ArrayMutation<Element>(reload: array)]
		}
	}
}

extension SignalInterface {
	func sortedArrayMutation<Element>(equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> Signal<ArrayMutation<Element>> where SetMutation<Element> == OutputValue {
		return transform(initialState: Array<Element>()) { (array: inout Array<Element>, result: Signal<SetMutation<Element>>.Result) in
			switch result {
			case .success(let m): return .values(sequence: m.apply(to: &array, equate: equate, compare: compare))
			case .failure(let e): return .end(e)
			}
		}
	}
}

enum StackMutation<Value>: ExpressibleByArrayLiteral {
	init(arrayLiteral elements: Value...) {
		self = .reload(elements)
	}
	
	typealias ArrayLiteralElement = Value
	
	case push(Value)
	case pop
	case popToCount(Int)
	case reload([Value])
	
	func apply(to stack: inout Array<Value>) {
		switch self {
		case .push(let v): stack.append(v)
		case .pop: stack.removeLast()
		case .popToCount(let c): stack.removeLast(stack.count - c)
		case .reload(let newStack): stack = newStack
		}
	}
}

extension SignalInterface {
	func stackMap<A, B>(_ transform: @escaping (A) -> B) -> Signal<StackMutation<B>> where OutputValue == StackMutation<A> {
		return map { m in
			switch m {
				case .push(let a): return StackMutation<B>.push(transform(a))
				case .pop: return StackMutation<B>.pop
				case .popToCount(let i): return StackMutation<B>.popToCount(i)
				case .reload(let array): return StackMutation<B>.reload(array.map { transform($0) })
			}
		}
	}
}

/// When used as the `Metadata` parameter to an `IndexedMutation`, then the indexed mutation can represent a locally visible subrange within a larger global array.
/// NOTE: when `nil` the following behaviors are implied for each IndexedMutation kind:
///	- reload: the localOffset is 0 and the globalCount is the reload count
///   - delete: the globalCount is reduced by the deletion count 
///   - insert: the globalCount is increased by the insertion count 
///   - scroll: the localOffset is changed by the scroll count
///   - update: neither localOffset nor globalCount are changed
///   - move: neither localOffset nor globalCount are changed
struct Subrange<Leaf> {
	/// This is offset for the visible range. When not provided, the `localOffset` is automatically updated by `.scroll` and reset to `0` on `.reload`.
	/// NOTE: `localOffset` doesn't affect the `IndexedMutation` itself (since the mutation operates entirely in local coordinates) but for animation purposes (which typically needs to occur in global coordinates), the `localOffset` is considered to apply *before* the animation (e.g. the scroll position shifts first, then the values in the new locations are updated).
	let localOffset: Int?
	
	/// This is the length of the greater array after the mutation is applied. When not provided, the `globalCount` is automatically updated by `.insert`, `.delete` and reset to the local count on `.reload`.
	let globalCount: Int?
	
	/// Additional metadata for this tier
	let leaf: Leaf?
	
	init(localOffset: Int?, globalCount: Int?, leaf: Leaf?) {
		self.localOffset = localOffset
		self.globalCount = globalCount
		self.leaf = leaf
	}
}

/// A data type that can be used to cache the destination end of a `Subrange<Leaf>` change stream.
struct SubrangeState<Element, Leaf> {
	var values: Deque<Element>?
	var localOffset: Int = 0
	var globalCount: Int = 0
	var leaf: Leaf?

	init(values: Deque<Element>? = nil, localOffset: Int = 0, globalCount: Int? = nil, leaf: Leaf? = nil) {
		self.values = values
		self.localOffset = localOffset
		self.globalCount = globalCount ?? values?.count ?? 0
		self.leaf = leaf
	}
}

typealias SubrangeMutation<Element, Additional> = IndexedMutation<Element, Subrange<Additional>>

extension IndexedMutation {
	func updateMetadata<Value, Leaf>(_ state: inout SubrangeState<Value, Leaf>) where Subrange<Leaf> == Metadata {
		switch kind {
		case .reload:
			state.localOffset = metadata?.localOffset ?? 0
			state.globalCount = metadata?.globalCount ?? values.count
			state.leaf = metadata?.leaf ?? nil
		case .delete:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount - indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .insert:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount + indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .scroll(let offset):
			state.localOffset = metadata?.localOffset ?? (state.localOffset + offset)
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .update: fallthrough
		case .move:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		}
	}
	
	func apply<Submetadata>(toSubrange state: inout SubrangeState<Element, Submetadata>) where Subrange<Submetadata> == Metadata {
		if !hasNoEffectOnValues {
			var rows = state.values ?? []
			mapMetadata { _ in () }.apply(to: &rows)
			state.values = rows
		}
		
		updateMetadata(&state)
	}
}

extension IndexSet {
	/// Maintaining an `SubrangeOffset` with a local offset may require offsetting an `IndexSet`
	func offset(by: Int) -> IndexSet {
		if by == 0 {
			return self
		}
		var result = IndexSet()
		for range in self.rangeView {
			result.insert(integersIn: (range.startIndex + by)..<(range.endIndex + by))
		}
		return result
	}
}

struct TreeMutation<Leaf>: ExpressibleByArrayLiteral {
	let mutations: IndexedMutation<TreeMutation<Leaf>, Leaf>
	
	init(mutations: IndexedMutation<TreeMutation<Leaf>, Leaf>) {
		self.mutations = mutations
	}
	
	init(arrayLiteral elements: TreeMutation<Leaf>...) {
		self.mutations = .reload(elements)
	}
	
	static func leaf(_ value: Leaf, children: [TreeMutation<Leaf>]? = nil) -> TreeMutation<Leaf> {
		return TreeMutation<Leaf>(mutations: children.map { IndexedMutation(metadata: value, reload: $0) } ?? IndexedMutation(metadata: value))
	}
	
	static func leaf<Value>(_ value: Value, children: [TreeMutation<Leaf>]? = nil) -> TreeMutation<Leaf> where Subrange<Value> == Leaf {
		let subrange = Subrange(localOffset: children.map { _ in 0 }, globalCount: children.map { $0.count }, leaf: value)
		return TreeMutation<Leaf>(mutations: children.map { IndexedMutation(metadata: subrange, reload: $0) } ?? IndexedMutation(metadata: subrange))
	}
}

class TreeState<Metadata> {
	weak var parent: TreeState<Metadata>?
	var metadata: Metadata? = nil
	var rows: Array<TreeState<Metadata>>? = nil
	
	init(parent: TreeState<Metadata>?) {}
	
	convenience init(parent: TreeState<Metadata>?, treeMutation: TreeMutation<Metadata>) {
		self.init(parent: parent)
		treeMutation.mutations.apply(toTree: self)
	}
}

typealias TreeSubrangeMutation<Leaf> = TreeMutation<Subrange<Leaf>>

extension IndexedMutation where Element == TreeMutation<Metadata> {
	func apply(toTree treeState: TreeState<Metadata>) {
		if let metadata = metadata {
			treeState.metadata = metadata
		}
		
		if !hasNoEffectOnValues {
			var rows: Array<TreeState<Metadata>> = []
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTree: rows[rowIndex])
				}
			} else {
				mapValues { mutation in TreeState<Metadata>.init(parent: treeState, treeMutation: mutation) }.mapMetadata { _ in () }.apply(to: &rows)
			}
			treeState.rows = rows
		}
	}
}

typealias TreeRangeMutation<Leaf> = TreeMutation<Subrange<Leaf>>

class TreeSubrangeState<Leaf> {
	weak var parent: TreeSubrangeState<Leaf>?
	var state = SubrangeState<TreeSubrangeState<Leaf>, Leaf>()

	init(parent: TreeSubrangeState<Leaf>?) {}
	
	convenience init(parent: TreeSubrangeState<Leaf>?, treeSubrangeMutation: TreeSubrangeMutation<Leaf>) {
		self.init(parent: parent)
		treeSubrangeMutation.mutations.apply(toTreeSubrange: self)
	}
}

extension IndexedMutation where Element == TreeMutation<Metadata> {
	func apply<Leaf>(toTreeSubrange treeSubrangeState: TreeSubrangeState<Leaf>) where Subrange<Leaf> == Metadata {
		if !hasNoEffectOnValues {
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTreeSubrange: treeSubrangeState.state.values![rowIndex])
				}
			} else {
				mapValues { mutation in TreeSubrangeState<Leaf>.init(parent: treeSubrangeState, treeSubrangeMutation: mutation) }.apply(toSubrange: &treeSubrangeState.state)
			}
		}
		updateMetadata(&treeSubrangeState.state)
	}
}

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
struct Animatable<Value, AnimationType> {
	let value: Value
	let animation: AnimationType?
	
	static func set(_ value: Value) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: nil)
	}
	static func animate(_ value: Value, animation: AnimationType) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: animation)
	}
	
	var isAnimated: Bool {
		return animation != nil
	}
}

typealias SetOrAnimate<Value> = Animatable<Value, ()>

extension Animatable where AnimationType == () {
	static func animate(_ value: Value) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: ())
	}
}

extension BindingName {
	static func --<A, AnimationType>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Dynamic<Animatable<A, AnimationType>> == Value {
		return name.binding(with: Value.constant(.set(value)))
	}
	
}

enum AnimationChoice {
	case never
	case subsequent
	case always
}

extension SignalInterface {
	func animate(_ choice: AnimationChoice = .subsequent) -> Signal<Animatable<OutputValue, ()>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}

	func animate(_ choice: AnimationChoice = .subsequent) -> Signal<Animatable<OutputValue?, ()>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

import Foundation

#if os(iOS)

extension Adapter {
	func storeToArchive<Value>() -> (UIApplication, NSKeyedArchiver) -> Void where State == VarState<Value> {
		return { _, archiver in archiver.encodeLatest(from: self) }
	}
}

extension Adapter {
	func loadFromArchive<Value>() -> (UIApplication, NSKeyedUnarchiver) -> Void where State == VarState<Value> {
		return { _, unarchiver in unarchiver.decodeSend(to: self.set()) }
	}
}

#endif

extension NSKeyedArchiver {
	/// Gets the latest value from the signal and encodes the value as JSON data into self using the provided key
	///
	/// - Parameters:
	///   - interface: exposes the signal
	///   - forKey: key used for encoding (is `String.viewStateKey` by default)
	func encodeLatest<Interface>(from interface: Interface, forKey: String = .viewStateKey) where Interface: SignalInterface, Interface.OutputValue: Codable {
		if let data = try? JSONEncoder().encode(interface.peek()) {
			_ = self.encode(data, forKey: forKey)
		}
	}
}

extension NSKeyedUnarchiver {
	/// Decodes the JSON data in self, associated with the provided key, and sends into the signal input.
	///
	/// NOTE: this function does not send errors.
	///
	/// - Parameters:
	///   - inputInterface: exposes the signal input
	///   - forKey: key used for decoding (is `String.viewStateKey` by default)
	func decodeSend<InputInterface>(to inputInterface: InputInterface, forKey: String = .viewStateKey) where InputInterface: SignalInputInterface, InputInterface.InputValue: Codable {
		if let data = self.decodeObject(forKey: forKey) as? Data, let value = try? JSONDecoder().decode(InputInterface.InputValue.self, from: data) {
			inputInterface.input.send(value: value)
		}
	}
}

extension String {
	static let viewStateKey = "viewStateData"
}

import Foundation

#if os(macOS)
	extension NSImage {
		static func drawn(width: CGFloat, height: CGFloat, flipped: Bool = true, _ function: @escaping (CGContext, CGRect) -> Void) -> NSImage {
			let size = CGSize(width: width, height: height)
			return NSImage(size: size, flipped: flipped) { rect -> Bool in
				guard let context = NSGraphicsContext.current else { return false }
				function(context.cgContext, rect)
				return true
			}
		}
	}
#else
	extension UIImage {
		static func drawn(width: CGFloat, height: CGFloat, _ function: (CGContext, CGRect) -> Void) -> UIImage {
			let size = CGSize(width: width, height: height)
			UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
			if let graphicsContext = UIGraphicsGetCurrentContext() {
				function(graphicsContext, CGRect(origin: .zero, size: size))
			}
			let rectangleImage = UIGraphicsGetImageFromCurrentImageContext()
			UIGraphicsEndImageContext()
			return rectangleImage ?? UIImage()
		}
	}
#endif

import Foundation

extension NSKeyValueObservation: Lifetime {
	func cancel() {
		self.invalidate()
	}
}

#if os(macOS)
	import AppKit
	
	protocol ViewConvertible {
		func nsView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		func nsView() -> Layout.View {
			return self
		}
	}
#else
	import UIKit
	
	protocol ViewConvertible {
		func uiView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		func uiView() -> Layout.View {
			return self
		}
	}
#endif

#if os(iOS)
	// This type handles a combination of `layoutMargin` and `safeAreaMargin` inset edges. If a `safeArea` edge is specified, it will be used instead of `layout` edge.
	struct MarginEdges: OptionSet {
		static var none: MarginEdges { return MarginEdges(rawValue: 0) }
		static var topLayout: MarginEdges { return MarginEdges(rawValue: 1) }
		static var leadingLayout: MarginEdges { return MarginEdges(rawValue: 2) }
		static var bottomLayout: MarginEdges { return MarginEdges(rawValue: 4) }
		static var trailingLayout: MarginEdges { return MarginEdges(rawValue: 8) }
		static var topSafeArea: MarginEdges { return MarginEdges(rawValue: 16) }
		static var leadingSafeArea: MarginEdges { return MarginEdges(rawValue: 32) }
		static var bottomSafeArea: MarginEdges { return MarginEdges(rawValue: 64) }
		static var trailingSafeArea: MarginEdges { return MarginEdges(rawValue: 128) }
		static var allLayout: MarginEdges { return [.topLayout, .leadingLayout, .bottomLayout, .trailingLayout] }
		static var allSafeArea: MarginEdges { return [.topSafeArea, .leadingSafeArea, .bottomSafeArea, .trailingSafeArea] }
		let rawValue: UInt
		init(rawValue: UInt) {
			self.rawValue = rawValue
		}
	}
#endif

#if os(macOS)
	extension NSView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self)) })
		}
	}
#else
	extension UIView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self, marginEdges: $0.marginEdges)) })
		}
	}
	
	extension UIScrollView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyContentLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(scrollView: self)) })
		}
	}
#endif

/// A data structure for describing a layout as a series of nested columns and rows.
struct Layout {
	/// A rough equivalent to UIStackViewAlignment, minus baseline cases which aren't handled
	enum Alignment { case leading, trailing, center, fill }
	
	#if os(macOS)
		typealias Axis = NSUserInterfaceLayoutOrientation
		typealias View = NSView
		typealias Guide = NSLayoutGuide
		typealias EdgeInsets = NSEdgeInsets
	#else
		typealias Axis = NSLayoutConstraint.Axis
		typealias View = UIView
		typealias Guide = UILayoutGuide
		typealias EdgeInsets = UIEdgeInsets
	#endif

	/// When a layout is applied, it can animate one of three ways:
	///
	/// - none: Do not animate layout transitions
	/// - frames: Animate frame changes for views present both before and after but do not animate added or removed views
	/// - fade: Use a fade transition for all changes
	/// - all: Animate frame changes for views present both before and after and use fade transitions for other viewa
	struct Animation {
		enum Style {
			case frames
			case fade
			case both
		}
		let style: Style
		let duration: CFTimeInterval
		init(style: Style, duration: CFTimeInterval) {
			self.style = style
			self.duration = duration
		}
		
		static func frames(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .frames, duration: duration) }
		static func fade(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .fade, duration: duration) }
		static func both(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .both, duration: duration) }
	}
	
	
	/// Layout is either horizontal or vertical (although any element within the layout may be a layout in the perpendicular direction)
	let axis: Axis
	
	/// Within the horizontal row or vertical column, layout entities may fill, center or align-leading or align-trailing
	let align: Alignment
	
	#if os(iOS)
		/// The layout may extend to the view bounds or may be limited by the safeAreaMargins or layoutMargins. The safeArea insets supercede the layoutMargins (prior to iOS 11, safeArea is interpreted as UIViewController top/bottom layout guides when laying out within a UIViewController, otherwise it is treated as a synonym for the layoutMargins). This value has no effect on macOS.	
		let marginEdges: MarginEdges
	#endif
	
	/// When applied to the top level `Layout` passed to 'applyLayout`, then replacing an existing layout on a view, if this variable is true, after applying the new layout, `layoutIfNeeded` will be called inside a `UIView.beginAnimations`/`UIView.endAnimations` block. Has no effect when set on a child `Layout`.
	let animation: Layout.Animation?
	
	/// This is the list of views, spaces and sublayouts that will be layed out.
	var entities: [Entity]
	
	/// The default constructor assigns all values. In general, it's easier to use the `.horizontal` or `.vertical` constructor where possible.
	#if os(iOS)
		init(axis: Axis, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.marginEdges = marginEdges
			self.animation = animation
		}
	
		/// A convenience constructor for a horizontal layout
		static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .horizontal(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .horizontal, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .vertical(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .vertical, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Layout {
			return .center(axis: axis, alignment: alignment, marginEdges: marginEdges, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
	#else
		init(axis: Axis, align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.animation = animation
		}
		
		/// A convenience constructor for a horizontal layout
		static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .horizontal(align: align, animation: animation, entities: entities)
		}
		static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .horizontal, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .vertical(align: align, animation: animation, entities: entities)
		}
		static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .vertical, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Layout {
			return .center(axis: axis, alignment: alignment, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout 
		static func inset(margins: EdgeInsets, animation: Layout.Animation? = .frames(), _ entity: Entity) -> Layout {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	#endif
	
	// Used for removing all views from their superviews
	func forEachView(_ visit: (View) -> Void) {
		entities.forEach { $0.forEachView(visit) }
	}

	/// The `Layout` describes a series of these `Entity`s which may be a space, a view or a sublayout. There is also a special `matched` layout which allows a series of "same length" entities.
	///
	/// - interViewSpace: AppKit and UIKit use an 8 screen unit space as the "standard" space between adjacent views.
	/// - space: an arbitrary space between views
	/// - view: a view with optional width and height (if not specified, the view will use its "intrinsic" size or will fill the available layout space)
	/// - layout: a nested layout which may be parallel or perpedicular to its container and whose size may be specified (like view)
	/// - matched: a sequence of alternating "same size" and independent entities (you can use `.space(0)` if you don't want independent entities).
	struct Entity {
		enum Content {
			case space(Dimension)
			case sizedView(Layout.View, Size?)
			indirect case layout(Layout, size: Size?)
			indirect case matched(Matched)
		}
		let content: Content
		init(_ content: Content) {
			self.content = content
		}
		
		func forEachView(_ visit: (Layout.View) -> Void) {
			switch content {
			case .sizedView(let v, _):
				#if os(macOS)
					visit(v.nsView())
				#else
					visit(v.uiView())
				#endif
			case .layout(let l, _): l.forEachView(visit)
			case .matched(let matched):
				matched.first.forEachView(visit)
				matched.subsequent.forEach { element in
					switch element {
					case .free(let entity): entity.forEachView(visit)
					case .dependent(let dependent): dependent.entity.forEachView(visit)
					}
				}
			default: break
			}
		}
		
		static func space(_ dimension: Dimension = .standardSpace) -> Entity {
			return Entity(.space(dimension))
		}
		
		static func view(length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(macOS)
				return Entity(.sizedView(view.nsView(), size))
			#else
				return Entity(.sizedView(view.uiView(), size))
			#endif
		}

		static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}
		
		static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}

		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}

		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}
		
		static func pair(_ left: Entity, _ right: Entity, separator: Entity = .space(), priority: Dimension.Priority = .required) -> Entity {
			return Entity(.matched(Matched(
				first: left,
				subsequent: [
					.free(separator),
					.dependent(.init(dimension: .equalTo(ratio: 1.0, priority: priority), right))
				]
			)))
		}
		
		static func matched(_ first: Entity, _ subsequent: Matched.Element...) -> Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		static func matched(_ first: Entity, subsequent: [Matched.Element]) -> Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		static func same(priority: Dimension.Priority = .required, _ entities: Entity...) -> Entity {
			return same(entities: entities)
		}
		
		static func same(priority: Dimension.Priority = .required, entities: [Entity]) -> Entity {
			guard let first = entities.first else { return .space(0) }
			return Entity(.matched(.init(first: first, subsequent: entities.dropFirst().map { .same(priority: priority, $0) })))
		}
		
		static func inset(margins: EdgeInsets, _ entity: Entity) -> Entity {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	}
	
	/// A `Matched` element in a layout is a first element, followed by an array of free and dependent elements. The dependent elements all have a dimension  relationship to the first element (e.g. same size).
	struct Matched {
		struct Dependent {
			let dimension: Dimension
			let entity: Entity
			init(dimension: Dimension, _ entity: Entity) {
				self.entity = entity
				self.dimension = dimension
			}
		}
		enum Element {
			case dependent(Dependent)
			case free(Entity)

			static func same(priority: Dimension.Priority = .required, _ entity: Entity) -> Element {
				return .dependent(.init(dimension: Dimension.equalTo(ratio: 1, priority: priority), entity))
			}
		}
		let first: Entity
		let subsequent: [Element]
		init(first: Entity, subsequent: [Element]) {
			self.first = first
			self.subsequent = subsequent
		}
	}

	/// A `Size` is the combination of both length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction). If the length includes a ratio, it is relative to the parent container but the breadth can be relative to the length, allowing for specifying an aspect ratio.
	struct Size {
		enum Relativity {
			case independent
			case lengthRelativeToBreadth
			case breadthRelativeToLength
			
			var isLengthRelativeToBreadth: Bool {
				if case .lengthRelativeToBreadth = self { return true } else { return false }
			}
			var isBreadthRelativeToLength: Bool {
				if case .breadthRelativeToLength = self { return true } else { return false }
			}
		}
		let length: Dimension?
		let breadth: Dimension?
		let relativity: Relativity
		
		init(length: Dimension? = nil, breadth: Dimension?, relativity: Relativity = .independent) {
			self.length = length
			self.breadth = breadth
			self.relativity = relativity
		}
	}

	/// When length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction) is specified, it can be specified:
	///	* relative to the parent container (ratio)
	///	* in raw screen units (constant)
	/// The greater/less than and priority can also be specified.
	struct Dimension: ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral {
		typealias FloatLiteralType = Double
		typealias IntegerLiteralType = Int
		
		#if os(macOS)
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = NSLayoutConstraint.Priority
		#else
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = UILayoutPriority
		#endif
		
		let ratio: CGFloat
		let constant: CGFloat
		let relationship: Relation
		let priority: Dimension.Priority
		init(ratio: CGFloat = 0, constant: CGFloat = 0, relationship: Dimension.Relation = .equal, priority: Dimension.Priority = .required) {
			self.ratio = ratio
			self.constant = constant
			self.relationship = relationship
			self.priority = priority
		}
		
		init(floatLiteral value: Double) {
			self.init(constant: CGFloat(value))
		}
		
		init(integerLiteral value: Int) {
			self.init(constant: CGFloat(value))
		}
		
		static func constant(_ value: CGFloat) -> Dimension {
			return Dimension(constant: value)
		}
		
		static func ratio(_ value: CGFloat, constant: CGFloat = 0) -> Dimension {
			return Dimension(ratio: value, constant: constant)
		}
		
		static var standardSpace = Dimension(ratio: 0, constant: 8, relationship: .equal, priority: .layoutHigh) 
		
		static func lessThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .lessThanOrEqual, priority: priority)
		}
		
		static func greaterThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .greaterThanOrEqual, priority: priority)
		}
		
		static func equalTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .equal, priority: priority)
		}
		
		static var fillRemaining: Dimension {
			return equalTo(ratio: 1, priority: .layoutMid)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, priorityAdjustment: Int) -> NSLayoutConstraint {
			let constraint: NSLayoutConstraint
			switch relationship {
			case .equal: constraint = first.constraint(equalTo: second, multiplier: ratio, constant: constant)
			case .lessThanOrEqual: constraint = first.constraint(lessThanOrEqualTo: second, multiplier: ratio, constant: constant)
			case .greaterThanOrEqual: constraint = first.constraint(greaterThanOrEqualTo: second, multiplier: ratio, constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: priorityAdjustment)
			constraint.isActive = true
			return constraint
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension) -> NSLayoutConstraint {
			return scaledConstraintBetween(first: first, second: second, priorityAdjustment: 0)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, constraints: inout [NSLayoutConstraint]) {
			constraints.append(scaledConstraintBetween(first: first, second: second, priorityAdjustment: constraints.count))
		}
		
		func unscaledConstraintBetween<AnchorType>(first: NSLayoutAnchor<AnchorType>, second: NSLayoutAnchor<AnchorType>, constraints: inout [NSLayoutConstraint], reverse: Bool = false) {
			let constraint: NSLayoutConstraint
			switch (relationship, reverse) {
			case (.equal, _): constraint = first.constraint(equalTo: second, constant: reverse ? -constant: constant)
			case (.lessThanOrEqual, false), (.greaterThanOrEqual, true): constraint = first.constraint(lessThanOrEqualTo: second, constant: reverse ? -constant: constant)
			case (.greaterThanOrEqual, false), (.lessThanOrEqual, true): constraint = first.constraint(greaterThanOrEqualTo: second, constant: reverse ? -constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: constraints.count)
			constraint.isActive = true
			constraints.append(constraint)
		}
	}

	/// Bounds are used internally to capture a set of guides and anchors. On the Mac, these are merely copied from a single NSLayoutGuide or an NSView. On iOS, these may be copied from a blend of UIViewController top/bottomLayoutGuides, safeAreaLayoutGuides, layoutMarginsGuides or a UIView.
	fileprivate struct Bounds {
		var leading: NSLayoutXAxisAnchor
		var top: NSLayoutYAxisAnchor
		var trailing: NSLayoutXAxisAnchor
		var bottom: NSLayoutYAxisAnchor
		var width: NSLayoutDimension
		var height: NSLayoutDimension
		var centerX: NSLayoutXAxisAnchor
		var centerY: NSLayoutYAxisAnchor
		
		init(box: Layout.Box) {
			leading = box.leadingAnchor
			top = box.topAnchor
			trailing = box.trailingAnchor
			bottom = box.bottomAnchor
			width = box.widthAnchor
			height = box.heightAnchor
			centerX = box.centerXAnchor
			centerY = box.centerYAnchor
		}
		
		#if os(iOS)
			init(scrollView: UIScrollView) {
				leading = scrollView.contentLayoutGuide.leadingAnchor
				top = scrollView.contentLayoutGuide.topAnchor
				trailing = scrollView.contentLayoutGuide.trailingAnchor
				bottom = scrollView.contentLayoutGuide.bottomAnchor
				width = scrollView.contentLayoutGuide.widthAnchor
				height = scrollView.contentLayoutGuide.heightAnchor
				centerX = scrollView.contentLayoutGuide.centerXAnchor
				centerY = scrollView.contentLayoutGuide.centerYAnchor
			}
			
			init(view: Layout.View, marginEdges: MarginEdges) {
				leading = marginEdges.contains(.leadingSafeArea) ? view.safeAreaLayoutGuide.leadingAnchor : (marginEdges.contains(.leadingLayout) ? view.layoutMarginsGuide.leadingAnchor : view.leadingAnchor)
				top = marginEdges.contains(.topSafeArea) ? view.safeAreaLayoutGuide.topAnchor : (marginEdges.contains(.topLayout) ? view.layoutMarginsGuide.topAnchor : view.topAnchor)
				trailing = marginEdges.contains(.trailingSafeArea) ? view.safeAreaLayoutGuide.trailingAnchor : (marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.trailingAnchor : view.trailingAnchor)
				bottom = marginEdges.contains(.bottomSafeArea) ? view.safeAreaLayoutGuide.bottomAnchor : (marginEdges.contains(.bottomLayout) ? view.layoutMarginsGuide.bottomAnchor : view.bottomAnchor)
				width = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.widthAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.widthAnchor : view.widthAnchor)
				height = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.heightAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.heightAnchor : view.heightAnchor)
				centerX = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerXAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerXAnchor : view.centerXAnchor)
				centerY = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerYAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerYAnchor : view.centerYAnchor)
			}
		#else
			init(view: Layout.View) {
				leading = view.leadingAnchor
				top = view.topAnchor
				trailing = view.trailingAnchor
				bottom = view.bottomAnchor
				width = view.widthAnchor
				height = view.heightAnchor
				centerX = view.centerXAnchor
				centerY = view.centerYAnchor
			}
		#endif
	}

	private struct State {
		let view: View
		let storage: Storage
		
		var dimension: Dimension? = nil
		var previousEntityBounds: Bounds? = nil
		var containerBounds: Bounds
		
		init(containerBounds: Bounds, in view: View, storage: Storage) {
			self.containerBounds = containerBounds
			self.view = view
			self.storage = storage
		}
	}

	fileprivate class Storage: NSObject {
		let layout: Layout
		var constraints: [NSLayoutConstraint] = []
		var boxes: [Layout.Box] = []
		
		init(layout: Layout) {
			self.layout = layout
		}
	}

	private func twoPointConstraint<First, Second>(firstSource: NSLayoutAnchor<First>, firstTarget: NSLayoutAnchor<First>, secondSource: NSLayoutAnchor<Second>, secondTarget: NSLayoutAnchor<Second>, secondRelationLessThan: Bool? = nil, constraints: inout [NSLayoutConstraint]) {
		let first = firstSource.constraint(equalTo: firstTarget)
		first.priority = .required
		first.isActive = true
		constraints.append(first)
		
		let secondLow = secondSource.constraint(equalTo: secondTarget)
		
		var secondHigh: NSLayoutConstraint? = nil
		if secondRelationLessThan == true {
			secondHigh = secondSource.constraint(lessThanOrEqualTo: secondTarget)
		} else if secondRelationLessThan == false {
			secondHigh = secondSource.constraint(greaterThanOrEqualTo: secondTarget)
		}
		if let high = secondHigh {
			secondLow.priority = adjustedPriority(.layoutLow, count: constraints.count)
			high.priority = adjustedPriority(.layoutHigh, count: constraints.count + 1)
			high.isActive = true
			constraints.append(high)
		} else {
			secondLow.priority = adjustedPriority(.layoutHigh, count: constraints.count)
		}
		secondLow.isActive = true
		constraints.append(secondLow)
	}
	
	private func constrain(bounds: Bounds, leading: Dimension, length: Dimension?, breadth: Dimension?, relativity: Size.Relativity, state: inout State) {
		switch axis {
		case .horizontal:
			leading.unscaledConstraintBetween(first: bounds.leading, second: state.containerBounds.leading, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.width, second: relativity.isLengthRelativeToBreadth ? bounds.height : state.containerBounds.width, constraints: &state.storage.constraints)
			}
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.height, second: relativity.isBreadthRelativeToLength ? bounds.width : state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.bottom, firstTarget: state.containerBounds.bottom, secondSource: bounds.top, secondTarget: state.containerBounds.top, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerY, firstTarget: state.containerBounds.centerY, secondSource: bounds.height, secondTarget: state.containerBounds.height, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.leading = bounds.trailing
		case .vertical:
			leading.unscaledConstraintBetween(first: bounds.top, second: state.containerBounds.top, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.height, second: relativity.isLengthRelativeToBreadth ? bounds.width : state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.width, second: relativity.isBreadthRelativeToLength ? bounds.height : state.containerBounds.width, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.trailing, firstTarget: state.containerBounds.trailing, secondSource: bounds.leading, secondTarget: state.containerBounds.leading, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerX, firstTarget: state.containerBounds.centerX, secondSource: bounds.width, secondTarget: state.containerBounds.width, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.top = bounds.bottom
		@unknown default:	fatalError()
		}
	}
	
	@discardableResult
	private func layout(entity: Entity, state: inout State, needDimensionAnchor: Bool = false) -> NSLayoutDimension? {
		switch entity.content {
		case .space(let dimension):
			if let d = state.dimension, (d.ratio != 0 || d.constant != 0) {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: d, breadth: nil, relativity: .independent, state: &state)
				state.previousEntityBounds = nil
			}
			if dimension.ratio != 0 || needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: dimension, breadth: nil, relativity: .independent, state: &state)
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			}
			state.dimension = dimension
			return nil
		case .layout(let l, let size):
			let box = Layout.Box()
			state.view.addLayoutBox(box)
			state.storage.boxes.append(box)
			let bounds = Bounds(box: box)
			l.add(to: state.view, containerBounds: bounds, storage: state.storage)
			constrain(bounds: bounds, leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
			state.dimension = nil
			state.previousEntityBounds = bounds
			return needDimensionAnchor ? (axis == .horizontal ? box.widthAnchor : box.heightAnchor) : nil
		case .matched(let matched):
			if needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				var subState = State(containerBounds: state.containerBounds, in: state.view, storage: state.storage)
				layout(entity: entity, state: &subState)
				state.dimension = nil
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			} else {
				let first = layout(entity: matched.first, state: &state, needDimensionAnchor: true)!
				for element in matched.subsequent {
					switch element {
					case .free(let free):
						layout(entity: free, state: &state)
					case .dependent(let dependent):
						let match = layout(entity: dependent.entity, state: &state, needDimensionAnchor: true)!
						dependent.dimension.scaledConstraintBetween(first: match, second: first, constraints: &state.storage.constraints)
					}
				}
				return nil
			}
		case .sizedView(let v, let size):
			#if os(macOS)
				let view = v.nsView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view)
			#else
				let view = v.uiView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view, marginEdges: .none), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view, marginEdges: .none)
		#endif
			return needDimensionAnchor ? (axis == .horizontal ? view.widthAnchor : view.heightAnchor) : nil
		}
	}
	
	fileprivate func add(to view: Layout.View, containerBounds: Bounds, storage: Storage) {
		var state = State(containerBounds: containerBounds, in: view, storage: storage)
		for entity in entities {
			layout(entity: entity, state: &state)
		}
		if let previous = state.previousEntityBounds {
			switch axis {
			case .horizontal:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.trailing, second: state.containerBounds.trailing, constraints: &state.storage.constraints, reverse: true)
			case .vertical:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.bottom, second: state.containerBounds.bottom, constraints: &state.storage.constraints, reverse: true)
			@unknown default: fatalError()
			}
		}
	}
}

// DEBUGGING TIP:
// As of Xcode 8, the "Debug View Hierarchy" option does not show layout guides, making debugging of constraints involving layout guides tricky. To aid debugging in these cases, set the following condition to `true && DEBUG` and CwlLayout will create views instead of layout guides.
// Otherwise, you can set this to `false && DEBUG`.
#if true && DEBUG
	private extension Layout {
		typealias Box = Layout.View
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.translatesAutoresizingMaskIntoConstraints = false
			self.addSubview(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.removeFromSuperview()
		}
	}
#else
	private extension Layout {
		typealias Box = Layout.Guide
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			self.addLayoutGuide(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			self.removeLayoutGuide(layoutBox)
		}
	}
#endif

// NOTE:
//
// Views often have their own intrinsic size, and they maintain this size at
// either the `.defaultLow` or `.defaultHigh` priority. Unfortunately, layout
// doesn't work well if this intrinsic priority is perfectly balanced with the
// user-applied layout priority.
//
// For this reason, CwlLayout defaults to using the following layout priorities
// which are scaled to be slightly different to the default priorities. This
// allows you to easily set layout priorities above, between or below the
// intrinisic priorities without always resorting to `.required`.
//
extension Layout.Dimension.Priority {
	#if os(macOS)
		// .fittingSizeLevel = .fittingSizeCompression = 50
		static let fittingSizeLevel = NSLayoutConstraint.Priority.fittingSizeCompression
		// .layoutLow = 156.25
		static let layoutLow = NSLayoutConstraint.Priority(rawValue: (5 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = NSLayoutConstraint.Priority(rawValue: (14 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .dragThatCannotResizeWindow = 490
		// .windowSizeStayPut = 500
		// .dragThatCanResizeWindow = 510
		// .defaultHigh = 750
		// .layoutHigh = 843.75
		static let layoutHigh = NSLayoutConstraint.Priority(rawValue: (27 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .required = 1000
	#else
		// .fittingSizeLevel = 50
		// .layoutLow = 156.25
		static let layoutLow = UILayoutPriority(rawValue: (5 / 32) * UILayoutPriority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = UILayoutPriority(rawValue: (14 / 32) * UILayoutPriority.required.rawValue)
		// .layoutHigh = 843.75
		static let layoutHigh = UILayoutPriority(rawValue: (27 / 32) * UILayoutPriority.required.rawValue)
		// .required = 1000
	#endif
}

private var associatedLayoutKey = NSObject()
private extension Layout.View {
	var associatedLayoutStorage: Layout.Storage? {
		get { return objc_getAssociatedObject(self, &associatedLayoutKey) as? Layout.Storage }
		set { return objc_setAssociatedObject(self, &associatedLayoutKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) }
	}
}

private extension Layout.View {
	func remove(constraintsAndBoxes previousLayout: Layout.Storage?, subviews: Set<Layout.View>) {
		guard let previous = previousLayout else { return }
		for constraint in previous.constraints {
			constraint.isActive = false
		}
		for box in previous.boxes {
			self.removeLayoutBox(box)
		}
		subviews.forEach { $0.removeFromSuperview() }
	}
}

// Applying a rolloing set of priorities reduces the chance of ambiguity. Later constraints will always take precedence.
// NOTE: this does not eliminate ambiguity due to conflicting `.required` contraints or views with equal hugging or compression resistance.
private func adjustedPriority(_ priority: Layout.Dimension.Priority, count: Int) -> Layout.Dimension.Priority {
	if priority == .required {
		return priority
	}
	
	let fitting = Layout.Dimension.Priority.fittingSizeLevel.rawValue + (1 / 128)
	return Layout.Dimension.Priority(rawValue: max(fitting, priority.rawValue - Float(count) / 128))
}

private func applyLayoutToView(view: Layout.View, params: (layout: Layout, bounds: Layout.Bounds)?) {
	var removedViews = Set<Layout.View>()
	
	// Check for a previous layout and get the old views
	let previous = view.associatedLayoutStorage
	previous?.layout.forEachView { view in removedViews.insert(view) }
	
	guard let (layout, bounds) = params else {
		// If there's no new layout, remove the old layout and we're done
		view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		return
	}
	
	// Check if this will be animated
	let shouldAnimate = layout.animation?.style != .none && previous != nil
	
	// Exclude views in the new layout from the removed set. If we're animating, we'll need animated and added sets too.
	var animatedViews = Set<Layout.View>()
	var addedViews = Set<Layout.View>()
	layout.forEachView { v in
		if let animated = removedViews.remove(v), shouldAnimate {
			animatedViews.insert(animated)
		} else if shouldAnimate {
			addedViews.insert(v)
		}
	}

	// Now that we know the precise removed set, remove them.
	let removalChange = { view.remove(constraintsAndBoxes: previous, subviews: removedViews) }
	if shouldAnimate && layout.animation?.style != .frames && addedViews.count == 0 && removedViews.count > 0 {
		// If we're animating the removal of views but not the insertion of views, animate this removal
		fadeTransition(view: view, duration: layout.animation?.duration ?? 0, removalChange)
	} else {
		removalChange()
	}
	
	// Apply the new layout
	let storage = Layout.Storage(layout: layout)
	layout.add(to: view, containerBounds: bounds, storage: storage)
	
	// If we're not animating, store the layout and we're done.
	if !shouldAnimate {
		view.associatedLayoutStorage = storage
		return
	}

	// NOTE: the case where `removedViews.count > 0` but `addedViews.count == 0` is handled above
	if addedViews.count > 0 {
		// Apply the layout, so new views have a precise size
		view.relayout()
		
		// Remove the new views and revert to the old layout
		view.remove(constraintsAndBoxes: storage, subviews: addedViews)
		if let p = previous {
			let oldStorage = Layout.Storage(layout: layout)
			p.layout.add(to: view, containerBounds: bounds, storage: oldStorage)

			// Immediately remove the old constraints but keep the old views
			view.remove(constraintsAndBoxes: oldStorage, subviews: [])
		}
		
		removedViews.forEach { $0.removeFromSuperview() }
		addedViews.forEach { view.addSubview($0) }
		
		// Reapply the new layout. Since the new views are already in-place
		let reapplyStorage = Layout.Storage(layout: layout)
		layout.add(to: view, containerBounds: bounds, storage: reapplyStorage)
		view.associatedLayoutStorage = reapplyStorage
	} else {
		view.associatedLayoutStorage = storage
	}
	
	// Animate the frames of the new layout
	let shouldFade: Bool
	switch layout.animation?.style {
	case .both?, .fade?: shouldFade = true
	case .frames?, nil: shouldFade = false
	}
	let frameChanges = {
		if shouldFade {
			fadeTransition(view: view, duration: layout.animation?.duration ?? 0, { view.relayout() })
		} else {
			view.relayout()
		}
	}
	if layout.animation?.style == .fade {
		frameChanges()
	} else {
		frameAnimation(view: view, duration: layout.animation?.duration ?? 0, frameChanges)
	}
}

private extension Layout.View {
	func relayout() {
		#if os(macOS)
			layoutSubtreeIfNeeded()
		#else
			layoutIfNeeded()
		#endif
	}
}

private func fadeTransition(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -> ()) {
	#if os(macOS)
		let transition = CATransition()
		transition.duration = duration
		transition.type = .fade
		view.layer?.add(transition, forKey: nil)
		changes()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

private func frameAnimation(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -> ()) {
	#if os(macOS)
		NSAnimationContext.beginGrouping()
		NSAnimationContext.current.duration = duration
		NSAnimationContext.current.allowsImplicitAnimation = true
		changes()
		NSAnimationContext.endGrouping()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

#if os(iOS)
	import UIKit
	
	@available(iOSApplicationExtension 8.2, *)
	extension UIFont {
		static func preferredFont(forTextStyle style: UIFont.TextStyle, weight: UIFont.Weight = .regular, slant: Float = 0) -> UIFont {
			let base = UIFontDescriptor.preferredFontDescriptor(withTextStyle: style)
			let traits: [UIFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.addingAttributes([.traits: traits])
			return UIFont(descriptor: modified, size: 0)
		}
	}

	func preferredFontSize(forTextStyle style: UIFont.TextStyle) -> CGFloat {
		return UIFontDescriptor.preferredFontDescriptor(withTextStyle: style).pointSize
	}
#endif

#if os(macOS)
	import AppKit

	@available(OSXApplicationExtension 10.11, *)
	extension NSFont {
		enum TextStyle {
			case controlContent
			case label
			case menu
			case menuBar
			case message
			case monospacedDigit
			case palette
			case system
			case titleBar
			case toolTips
		}
		enum TextSize {
			case controlMini
			case controlRegular
			case controlSmall
			case label
			case points(CGFloat)
			case system
			case title1
			case title2
		}

		static func preferredFont(forTextStyle style: TextStyle, size: TextSize = .system, weight: NSFont.Weight = .regular, slant: CGFloat = 0) -> NSFont {
			let pointSize: CGFloat
			switch size {
			case .controlMini: pointSize = NSFont.systemFontSize(for: .mini)
			case .controlRegular: pointSize = NSFont.systemFontSize(for: .regular)
			case .controlSmall: pointSize = NSFont.systemFontSize(for: .small)
			case .label: pointSize = NSFont.labelFontSize
			case .points(let other): pointSize = other
			case .system: pointSize = NSFont.systemFontSize
			case .title1: pointSize = NSFont.systemFontSize + 5
			case .title2: pointSize = NSFont.systemFontSize + 2
			}
			
			let base: NSFont
			switch style {
			case .controlContent: base = NSFont.controlContentFont(ofSize: pointSize)
			case .label: base = NSFont.labelFont(ofSize: pointSize)
			case .menu: base = NSFont.menuFont(ofSize: pointSize)
			case .menuBar:  base = NSFont.menuBarFont(ofSize: pointSize)
			case .message:  base = NSFont.messageFont(ofSize: pointSize)
			case .monospacedDigit:  base = NSFont.monospacedDigitSystemFont(ofSize: pointSize, weight: weight)
			case .palette:  base = NSFont.paletteFont(ofSize: pointSize)
			case .system:  base = NSFont.systemFont(ofSize: pointSize)
			case .titleBar:  base = NSFont.titleBarFont(ofSize: pointSize)
			case .toolTips:  base = NSFont.toolTipsFont(ofSize: pointSize)
			}

			let traits: [NSFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.fontDescriptor.addingAttributes([.traits: traits])
			
			return NSFont(descriptor: modified, size: 0) ?? base
		}
	}
#endif
