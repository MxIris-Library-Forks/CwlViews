//
//  CwlTableView_iOS.swift
//  CwlViews
//
//  Created by Matt Gallagher on 2017/03/27.
//  Copyright Â© 2017 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or without
//  fee is hereby granted, provided that the above copyright notice and this permission notice
//  appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
//  SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
//  AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
//  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
//  OF THIS SOFTWARE.
//

#if os(iOS)

extension TableViewBinding {
	public static func tableStructure<S: Sequence>(in bindings: S) throws -> TableSectionState<RowDataType> where S.Element == TableView<RowDataType>.Binding {
		var found: TableSectionState<RowDataType>? = nil
		for b in bindings {
			if case .tableData(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.values
				var sections = TableSectionState<RowDataType>()
				for v in values {
					v.value.apply(to: &sections)
				}
				found = sections
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingParser<$2, TableView<Binding.RowDataType>.Binding> { return BindingParser<$2, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	public static var tableViewStyle: BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Constant<UITableView.Style>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Constant<UITableView.Style>> in if case .tableViewStyle(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	public static var allowsMultipleSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelection(let x) = binding { return x } else { return nil } }) }
	public static var allowsMultipleSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMultipleSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	public static var allowsSelection: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelection(let x) = binding { return x } else { return nil } }) }
	public static var allowsSelectionDuringEditing: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	public static var backgroundView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	public static var cellLayoutMarginsFollowReadableWidth: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .cellLayoutMarginsFollowReadableWidth(let x) = binding { return x } else { return nil } }) }
	public static var estimatedRowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedRowHeight(let x) = binding { return x } else { return nil } }) }
	public static var estimatedSectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	public static var estimatedSectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .estimatedSectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	public static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	public static var remembersLastFocusedIndexPath: BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .remembersLastFocusedIndexPath(let x) = binding { return x } else { return nil } }) }
	public static var rowHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .rowHeight(let x) = binding { return x } else { return nil } }) }
	public static var sectionFooterHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	public static var sectionHeaderHeight: BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .sectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	public static var sectionIndexBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexBackgroundColor(let x) = binding { return x } else { return nil } }) }
	public static var sectionIndexColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexColor(let x) = binding { return x } else { return nil } }) }
	public static var sectionIndexMinimumDisplayRowCount: BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<Int>> in if case .sectionIndexMinimumDisplayRowCount(let x) = binding { return x } else { return nil } }) }
	public static var sectionIndexTitles: BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<[String]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<[String]?>> in if case .sectionIndexTitles(let x) = binding { return x } else { return nil } }) }
	public static var sectionIndexTrackingBackgroundColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .sectionIndexTrackingBackgroundColor(let x) = binding { return x } else { return nil } }) }
	public static var separatorColor: BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIColor?>> in if case .separatorColor(let x) = binding { return x } else { return nil } }) }
	public static var separatorEffect: BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIVisualEffect?>> in if case .separatorEffect(let x) = binding { return x } else { return nil } }) }
	public static var separatorInset: BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	public static var separatorInsetReference: BindingParser<Dynamic<UITableView.SeparatorInsetReference>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UITableView.SeparatorInsetReference>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UITableView.SeparatorInsetReference>> in if case .separatorInsetReference(let x) = binding { return x } else { return nil } }) }
	public static var separatorStyle: BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<UITableViewCell.SeparatorStyle>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<UITableViewCell.SeparatorStyle>> in if case .separatorStyle(let x) = binding { return x } else { return nil } }) }
	public static var tableData: BindingParser<Dynamic<TableSectionAnimatable<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<TableSectionAnimatable<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<TableSectionAnimatable<Binding.RowDataType>>> in if case .tableData(let x) = binding { return x } else { return nil } }) }
	public static var tableFooterView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableFooterView(let x) = binding { return x } else { return nil } }) }
	public static var tableHeaderView: BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Dynamic<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible?>> in if case .tableHeaderView(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	public static var deselectRow: BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<IndexPath>>> in if case .deselectRow(let x) = binding { return x } else { return nil } }) }
	public static var scrollToNearestSelectedRow: BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<UITableView.ScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<UITableView.ScrollPosition>>> in if case .scrollToNearestSelectedRow(let x) = binding { return x } else { return nil } }) }
	public static var scrollToRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition>>> in if case .scrollToRow(let x) = binding { return x } else { return nil } }) }
	public static var selectRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition?>>> in if case .selectRow(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	public static var selectionDidChange: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]?>> in if case .selectionDidChange(let x) = binding { return x } else { return nil } }) }
	public static var userDidScrollToRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .userDidScrollToRow(let x) = binding { return x } else { return nil } }) }
	public static var visibleRowsChanged: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]>> in if case .visibleRowsChanged(let x) = binding { return x } else { return nil } }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	public static var accessoryButtonTapped: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .accessoryButtonTapped(let x) = binding { return x } else { return nil } }) }
	public static var canEditRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canEditRow(let x) = binding { return x } else { return nil } }) }
	public static var canFocusRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canFocusRow(let x) = binding { return x } else { return nil } }) }
	public static var canMoveRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canMoveRow(let x) = binding { return x } else { return nil } }) }
	public static var canPerformAction: BindingParser<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> in if case .canPerformAction(let x) = binding { return x } else { return nil } }) }
	public static var cellConstructor: BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> in if case .cellConstructor(let x) = binding { return x } else { return nil } }) }
	public static var cellIdentifier: BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(TableRow<Binding.RowDataType>) -> String?> in if case .cellIdentifier(let x) = binding { return x } else { return nil } }) }
	public static var commit: BindingParser<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void> in if case .commit(let x) = binding { return x } else { return nil } }) }
	public static var dataMissingCell: BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(IndexPath) -> TableViewCellConvertible> in if case .dataMissingCell(let x) = binding { return x } else { return nil } }) }
	public static var didDeselectRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didDeselectRow(let x) = binding { return x } else { return nil } }) }
	public static var didEndDisplayingCell: BindingParser<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void> in if case .didEndDisplayingCell(let x) = binding { return x } else { return nil } }) }
	public static var didEndDisplayingFooter: BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UIView, Int) -> Void> in if case .didEndDisplayingFooter(let x) = binding { return x } else { return nil } }) }
	public static var didEndDisplayingHeader: BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UIView, Int) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UIView, Int) -> Void> in if case .didEndDisplayingHeader(let x) = binding { return x } else { return nil } }) }
	public static var didEndEditingRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>?) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>?) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>?) -> Void> in if case .didEndEditingRow(let x) = binding { return x } else { return nil } }) }
	public static var didHightlightRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didHightlightRow(let x) = binding { return x } else { return nil } }) }
	public static var didSelectRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didSelectRow(let x) = binding { return x } else { return nil } }) }
	public static var didUnhighlightRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>) -> Void> in if case .didUnhighlightRow(let x) = binding { return x } else { return nil } }) }
	public static var didUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> in if case .didUpdateFocus(let x) = binding { return x } else { return nil } }) }
	public static var editActionsForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> in if case .editActionsForRow(let x) = binding { return x } else { return nil } }) }
	public static var editingStyleForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle> in if case .editingStyleForRow(let x) = binding { return x } else { return nil } }) }
	public static var estimatedHeightForFooter: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .estimatedHeightForFooter(let x) = binding { return x } else { return nil } }) }
	public static var estimatedHeightForHeader: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .estimatedHeightForHeader(let x) = binding { return x } else { return nil } }) }
	public static var estimatedHeightForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .estimatedHeightForRow(let x) = binding { return x } else { return nil } }) }
	public static var footerHeight: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .footerHeight(let x) = binding { return x } else { return nil } }) }
	public static var footerView: BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> in if case .footerView(let x) = binding { return x } else { return nil } }) }
	public static var headerHeight: BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int) -> CGFloat> in if case .headerHeight(let x) = binding { return x } else { return nil } }) }
	public static var headerView: BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> in if case .headerView(let x) = binding { return x } else { return nil } }) }
	public static var heightForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .heightForRow(let x) = binding { return x } else { return nil } }) }
	public static var indentationLevelForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int> in if case .indentationLevelForRow(let x) = binding { return x } else { return nil } }) }
	public static var indexPathForPreferredFocusedView: BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView) -> IndexPath> in if case .indexPathForPreferredFocusedView(let x) = binding { return x } else { return nil } }) }
	public static var moveRow: BindingParser<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void> in if case .moveRow(let x) = binding { return x } else { return nil } }) }
	public static var shouldHighlightRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldHighlightRow(let x) = binding { return x } else { return nil } }) }
	public static var shouldIndentWhileEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldIndentWhileEditingRow(let x) = binding { return x } else { return nil } }) }
	public static var shouldShowMenuForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldShowMenuForRow(let x) = binding { return x } else { return nil } }) }
	public static var shouldUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext) -> Bool> in if case .shouldUpdateFocus(let x) = binding { return x } else { return nil } }) }
	public static var targetIndexPathForMoveFromRow: BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> in if case .targetIndexPathForMoveFromRow(let x) = binding { return x } else { return nil } }) }
	public static var titleForDeleteConfirmationButtonForRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?> in if case .titleForDeleteConfirmationButtonForRow(let x) = binding { return x } else { return nil } }) }
	public static var willBeginEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> in if case .willBeginEditingRow(let x) = binding { return x } else { return nil } }) }
	public static var willDeselectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willDeselectRow(let x) = binding { return x } else { return nil } }) }
	public static var willDisplayFooter: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayFooter(let x) = binding { return x } else { return nil } }) }
	public static var willDisplayHeader: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayHeader(let x) = binding { return x } else { return nil } }) }
	public static var willDisplayRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> in if case .willDisplayRow(let x) = binding { return x } else { return nil } }) }
	public static var willSelectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willSelectRow(let x) = binding { return x } else { return nil } }) }
}

#endif
