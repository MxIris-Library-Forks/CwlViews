//
//  CwlWebView.swift
//  CwlViews
//
//  Created by Matt Gallagher on 2017/04/18.
//  Copyright Â© 2017 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or without
//  fee is hereby granted, provided that the above copyright notice and this permission notice
//  appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
//  SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
//  AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
//  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
//  OF THIS SOFTWARE.
//

import WebKit

extension BindingParser where Binding == CwlViews.WebView.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	public static var allowsAirPlayForMediaPlayback: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .allowsAirPlayForMediaPlayback(let x) = binding { return x } else { return nil } }) }
	public static var allowsInlineMediaPlayback: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .allowsInlineMediaPlayback(let x) = binding { return x } else { return nil } }) }
	public static var allowsPictureInPictureForMediaPlayback: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .allowsPictureInPictureForMediaPlayback(let x) = binding { return x } else { return nil } }) }
	public static var applicationNameForUserAgent: BindingParser<Constant<String?>, Binding> { return BindingParser<Constant<String?>, Binding>(parse: { binding -> Optional<Constant<String?>> in if case .applicationNameForUserAgent(let x) = binding { return x } else { return nil } }) }
	public static var ignoresViewportScaleLimits: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .ignoresViewportScaleLimits(let x) = binding { return x } else { return nil } }) }
	public static var javaScriptCanOpenWindowsAutomatically: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .javaScriptCanOpenWindowsAutomatically(let x) = binding { return x } else { return nil } }) }
	public static var javaScriptEnabled: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .javaScriptEnabled(let x) = binding { return x } else { return nil } }) }
	public static var mediaTypesRequiringUserActionForPlayback: BindingParser<Constant<WKAudiovisualMediaTypes>, Binding> { return BindingParser<Constant<WKAudiovisualMediaTypes>, Binding>(parse: { binding -> Optional<Constant<WKAudiovisualMediaTypes>> in if case .mediaTypesRequiringUserActionForPlayback(let x) = binding { return x } else { return nil } }) }
	public static var minimumFontSize: BindingParser<Constant<CGFloat>, Binding> { return BindingParser<Constant<CGFloat>, Binding>(parse: { binding -> Optional<Constant<CGFloat>> in if case .minimumFontSize(let x) = binding { return x } else { return nil } }) }
	public static var processPool: BindingParser<Constant<WKProcessPool>, Binding> { return BindingParser<Constant<WKProcessPool>, Binding>(parse: { binding -> Optional<Constant<WKProcessPool>> in if case .processPool(let x) = binding { return x } else { return nil } }) }
	public static var suppressesIncrementalRendering: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .suppressesIncrementalRendering(let x) = binding { return x } else { return nil } }) }
	public static var urlSchemeHandlers: BindingParser<Constant<[String: WKURLSchemeHandler]>, Binding> { return BindingParser<Constant<[String: WKURLSchemeHandler]>, Binding>(parse: { binding -> Optional<Constant<[String: WKURLSchemeHandler]>> in if case .urlSchemeHandlers(let x) = binding { return x } else { return nil } }) }
	public static var userContentController: BindingParser<Constant<WKUserContentController>, Binding> { return BindingParser<Constant<WKUserContentController>, Binding>(parse: { binding -> Optional<Constant<WKUserContentController>> in if case .userContentController(let x) = binding { return x } else { return nil } }) }

	@available(macOS 10.10, *) @available(iOS, unavailable) public static var javaEnabled: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .javaEnabled(let x) = binding { return x } else { return nil } }) }
	@available(macOS 10.10, *) @available(iOS, unavailable) public static var plugInsEnabled: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .plugInsEnabled(let x) = binding { return x } else { return nil } }) }
	@available(macOS 10.10, *) @available(iOS, unavailable) public static var tabFocusesLinks: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .tabFocusesLinks(let x) = binding { return x } else { return nil } }) }
	@available(macOS 10.12, *) @available(iOS, unavailable) public static var userInterfaceDirectionPolicy: BindingParser<Constant<CwlViews.WebView.WKUserInterfaceDirectionPolicy>, Binding> { return BindingParser<Constant<CwlViews.WebView.WKUserInterfaceDirectionPolicy>, Binding>(parse: { binding -> Optional<Constant<CwlViews.WebView.WKUserInterfaceDirectionPolicy>> in if case .userInterfaceDirectionPolicy(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 9, *) public static var allowsPictureInPictureMediaPlayback: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .allowsPictureInPictureMediaPlayback(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 11, *) public static var scrollView: BindingParser<Constant<ScrollView>, Binding> { return BindingParser<Constant<ScrollView>, Binding>(parse: { binding -> Optional<Constant<ScrollView>> in if case .scrollView(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 11, *) public static var dataDetectorTypes: BindingParser<Constant<CwlViews.WebView.WKDataDetectorTypes>, Binding> { return BindingParser<Constant<CwlViews.WebView.WKDataDetectorTypes>, Binding>(parse: { binding -> Optional<Constant<CwlViews.WebView.WKDataDetectorTypes>> in if case .dataDetectorTypes(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 11, *) public static var selectionGranularity: BindingParser<Constant<CwlViews.WebView.WKSelectionGranularity>, Binding> { return BindingParser<Constant<CwlViews.WebView.WKSelectionGranularity>, Binding>(parse: { binding -> Optional<Constant<CwlViews.WebView.WKSelectionGranularity>> in if case .selectionGranularity(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	public static var allowsBackForwardNavigationGestures: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsBackForwardNavigationGestures(let x) = binding { return x } else { return nil } }) }
	public static var allowsLinkPreview: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsLinkPreview(let x) = binding { return x } else { return nil } }) }
	public static var customUserAgent: BindingParser<Dynamic<String?>, Binding> { return BindingParser<Dynamic<String?>, Binding>(parse: { binding -> Optional<Dynamic<String?>> in if case .customUserAgent(let x) = binding { return x } else { return nil } }) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) public static var allowsMagnification: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsMagnification(let x) = binding { return x } else { return nil } }) }
	@available(macOS 10.13, *) @available(iOS, unavailable) public static var magnification: BindingParser<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding> { return BindingParser<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding>(parse: { binding -> Optional<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>> in if case .magnification(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	public static var evaluateJavaScript: BindingParser<Signal<Callback<String, (Any?, Error?)>>, Binding> { return BindingParser<Signal<Callback<String, (Any?, Error?)>>, Binding>(parse: { binding -> Optional<Signal<Callback<String, (Any?, Error?)>>> in if case .evaluateJavaScript(let x) = binding { return x } else { return nil } }) }
	public static var goBack: BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<Void, WKNavigation?>>> in if case .goBack(let x) = binding { return x } else { return nil } }) }
	public static var goForward: BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<Void, WKNavigation?>>> in if case .goForward(let x) = binding { return x } else { return nil } }) }
	public static var goTo: BindingParser<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<WKBackForwardListItem, WKNavigation?>>> in if case .goTo(let x) = binding { return x } else { return nil } }) }
	public static var load: BindingParser<Signal<Callback<URLRequest, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<URLRequest, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<URLRequest, WKNavigation?>>> in if case .load(let x) = binding { return x } else { return nil } }) }
	public static var loadData: BindingParser<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>> in if case .loadData(let x) = binding { return x } else { return nil } }) }
	public static var loadFile: BindingParser<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>> in if case .loadFile(let x) = binding { return x } else { return nil } }) }
	public static var loadHTMLString: BindingParser<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>> in if case .loadHTMLString(let x) = binding { return x } else { return nil } }) }
	public static var reload: BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<Void, WKNavigation?>>> in if case .reload(let x) = binding { return x } else { return nil } }) }
	public static var reloadFromOrigin: BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingParser<Signal<Callback<Void, WKNavigation?>>, Binding>(parse: { binding -> Optional<Signal<Callback<Void, WKNavigation?>>> in if case .reloadFromOrigin(let x) = binding { return x } else { return nil } }) }
	public static var stopLoading: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .stopLoading(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	public static var createWebView: BindingParser<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding> { return BindingParser<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding>(parse: { binding -> Optional<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?> in if case .createWebView(let x) = binding { return x } else { return nil } }) }
	public static var didClose: BindingParser<(WKWebView) -> Void, Binding> { return BindingParser<(WKWebView) -> Void, Binding>(parse: { binding -> Optional<(WKWebView) -> Void> in if case .didClose(let x) = binding { return x } else { return nil } }) }
	public static var didCommit: BindingParser<(WKWebView, WKNavigation) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation) -> Void> in if case .didCommit(let x) = binding { return x } else { return nil } }) }
	public static var didStartProvisionalNavigation: BindingParser<(WKWebView, WKNavigation) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation) -> Void> in if case .didStartProvisionalNavigation(let x) = binding { return x } else { return nil } }) }
	public static var didReceiveServerRedirectForProvisionalNavigation: BindingParser<(WKWebView, WKNavigation) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation) -> Void> in if case .didReceiveServerRedirectForProvisionalNavigation(let x) = binding { return x } else { return nil } }) }
	public static var didFail: BindingParser<(WKWebView, WKNavigation, Error) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation, Error) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation, Error) -> Void> in if case .didFail(let x) = binding { return x } else { return nil } }) }
	public static var didFailProvisionalNavigation: BindingParser<(WKWebView, WKNavigation, Error) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation, Error) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation, Error) -> Void> in if case .didFailProvisionalNavigation(let x) = binding { return x } else { return nil } }) }
	public static var didFinish: BindingParser<(WKWebView, WKNavigation) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigation) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigation) -> Void> in if case .didFinish(let x) = binding { return x } else { return nil } }) }
	public static var contentProcessDidTerminate: BindingParser<(WKWebView) -> Void, Binding> { return BindingParser<(WKWebView) -> Void, Binding>(parse: { binding -> Optional<(WKWebView) -> Void> in if case .contentProcessDidTerminate(let x) = binding { return x } else { return nil } }) }
	public static var decideActionPolicy: BindingParser<(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void> in if case .decideActionPolicy(let x) = binding { return x } else { return nil } }) }
	public static var decideResponsePolicy: BindingParser<(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void> in if case .decideResponsePolicy(let x) = binding { return x } else { return nil } }) }
	public static var didReceiveAuthenticationChallenge: BindingParser<(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void> in if case .didReceiveAuthenticationChallenge(let x) = binding { return x } else { return nil } }) }
	public static var runJavaScriptAlertPanel: BindingParser<(WKWebView, String, WKFrameInfo, () -> Void) -> Void, Binding> { return BindingParser<(WKWebView, String, WKFrameInfo, () -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, String, WKFrameInfo, () -> Void) -> Void> in if case .runJavaScriptAlertPanel(let x) = binding { return x } else { return nil } }) }
	public static var runJavaScriptConfirmPanel: BindingParser<(WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void> in if case .runJavaScriptConfirmPanel(let x) = binding { return x } else { return nil } }) }
	public static var runJavaScriptTextInputPanel: BindingParser<(WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void> in if case .runJavaScriptTextInputPanel(let x) = binding { return x } else { return nil } }) }
	
	@available(macOS, unavailable) @available(iOS 10.0, *) public static var commitPreviewingViewController: BindingParser<(_ webView: WKWebView, _ previewingViewController: CwlViews.WebView.UIViewController) -> Void, Binding> { return BindingParser<(_ webView: WKWebView, _ previewingViewController: CwlViews.WebView.UIViewController) -> Void, Binding>(parse: { binding -> Optional<(_ webView: WKWebView, _ previewingViewController: CwlViews.WebView.UIViewController) -> Void> in if case .commitPreviewingViewController(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 10.0, *) public static var previewingViewController: BindingParser<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo, _ previewActions: [CwlViews.WebView.WKPreviewActionItem]) -> CwlViews.WebView.UIViewController?, Binding> { return BindingParser<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo, _ previewActions: [CwlViews.WebView.WKPreviewActionItem]) -> CwlViews.WebView.UIViewController?, Binding>(parse: { binding -> Optional<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo, _ previewActions: [CwlViews.WebView.WKPreviewActionItem]) -> CwlViews.WebView.UIViewController?> in if case .previewingViewController(let x) = binding { return x } else { return nil } }) }
	@available(macOS 10.12, *) @available(iOS, unavailable) public static var runOpenPanel: BindingParser<(WKWebView, CwlViews.WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void, Binding> { return BindingParser<(WKWebView, CwlViews.WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void, Binding>(parse: { binding -> Optional<(WKWebView, CwlViews.WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void> in if case .runOpenPanel(let x) = binding { return x } else { return nil } }) }
	@available(macOS, unavailable) @available(iOS 10.0, *) public static var shouldPreviewElement: BindingParser<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo) -> Bool, Binding> { return BindingParser<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo) -> Bool, Binding>(parse: { binding -> Optional<(_ webView: WKWebView, _ elementInfo: CwlViews.WebView.WKPreviewElementInfo) -> Bool> in if case .shouldPreviewElement(let x) = binding { return x } else { return nil } }) }
}
