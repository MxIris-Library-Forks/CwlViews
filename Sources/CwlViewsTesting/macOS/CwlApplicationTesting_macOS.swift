//
//  CwlApplication_macOS.swift
//  CwlViews
//
//  Created by Matt Gallagher on 5/08/2015.
//  Copyright Â© 2015 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or without
//  fee is hereby granted, provided that the above copyright notice and this permission notice
//  appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
//  SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
//  AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
//  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
//  OF THIS SOFTWARE.
//

#if os(macOS)

import CloudKit

extension BindingParser where Binding == Application.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	public static var activationPolicy: BindingParser<Dynamic<NSApplication.ActivationPolicy>, Binding> { return BindingParser<Dynamic<NSApplication.ActivationPolicy>, Binding>(parse: { binding -> Optional<Dynamic<NSApplication.ActivationPolicy>> in if case .activationPolicy(let x) = binding { return x } else { return nil } }) }
	public static var applicationIconImage: BindingParser<Dynamic<NSImage?>, Binding> { return BindingParser<Dynamic<NSImage?>, Binding>(parse: { binding -> Optional<Dynamic<NSImage?>> in if case .applicationIconImage(let x) = binding { return x } else { return nil } }) }
	public static var dockMenu: BindingParser<Dynamic<MenuConvertible?>, Binding> { return BindingParser<Dynamic<MenuConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<MenuConvertible?>> in if case .dockMenu(let x) = binding { return x } else { return nil } }) }
	public static var mainMenu: BindingParser<Dynamic<MenuConvertible?>, Binding> { return BindingParser<Dynamic<MenuConvertible?>, Binding>(parse: { binding -> Optional<Dynamic<MenuConvertible?>> in if case .mainMenu(let x) = binding { return x } else { return nil } }) }
	public static var menuBarVisible: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .menuBarVisible(let x) = binding { return x } else { return nil } }) }
	public static var presentationOptions: BindingParser<Dynamic<NSApplication.PresentationOptions>, Binding> { return BindingParser<Dynamic<NSApplication.PresentationOptions>, Binding>(parse: { binding -> Optional<Dynamic<NSApplication.PresentationOptions>> in if case .presentationOptions(let x) = binding { return x } else { return nil } }) }
	public static var relauchOnLogin: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .relauchOnLogin(let x) = binding { return x } else { return nil } }) }
	public static var remoteNotifications: BindingParser<Dynamic<NSApplication.RemoteNotificationType>, Binding> { return BindingParser<Dynamic<NSApplication.RemoteNotificationType>, Binding>(parse: { binding -> Optional<Dynamic<NSApplication.RemoteNotificationType>> in if case .remoteNotifications(let x) = binding { return x } else { return nil } }) }
	
	@available(macOS 10.14, *) public static var appearance: BindingParser<Dynamic<NSAppearance?>, Binding> { return BindingParser<Dynamic<NSAppearance?>, Binding>(parse: { binding -> Optional<Dynamic<NSAppearance?>> in if case .appearance(let x) = binding { return x } else { return nil } }) }
	
	// 2. Signal bindings are performed on the object after construction.
	public static var activate: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .activate(let x) = binding { return x } else { return nil } }) }
	public static var arrangeInFront: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .arrangeInFront(let x) = binding { return x } else { return nil } }) }
	public static var deactivate: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .deactivate(let x) = binding { return x } else { return nil } }) }
	public static var hide: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .hide(let x) = binding { return x } else { return nil } }) }
	public static var hideOtherApplications: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .hideOtherApplications(let x) = binding { return x } else { return nil } }) }
	public static var miniaturizeAll: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .miniaturizeAll(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontCharacterPalette: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontCharacterPalette(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontColorPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontColorPanel(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontStandardAboutPanel: BindingParser<Signal<Dictionary<NSApplication.AboutPanelOptionKey, Any>>, Binding> { return BindingParser<Signal<Dictionary<NSApplication.AboutPanelOptionKey, Any>>, Binding>(parse: { binding -> Optional<Signal<Dictionary<NSApplication.AboutPanelOptionKey, Any>>> in if case .orderFrontStandardAboutPanel(let x) = binding { return x } else { return nil } }) }
	public static var presentError: BindingParser<Signal<Callback<Error, Bool>>, Binding> { return BindingParser<Signal<Callback<Error, Bool>>, Binding>(parse: { binding -> Optional<Signal<Callback<Error, Bool>>> in if case .presentError(let x) = binding { return x } else { return nil } }) }
	public static var requestUserAttention: BindingParser<Signal<(NSApplication.RequestUserAttentionType, Signal<Void>)>, Binding> { return BindingParser<Signal<(NSApplication.RequestUserAttentionType, Signal<Void>)>, Binding>(parse: { binding -> Optional<Signal<(NSApplication.RequestUserAttentionType, Signal<Void>)>> in if case .requestUserAttention(let x) = binding { return x } else { return nil } }) }
	public static var terminate: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .terminate(let x) = binding { return x } else { return nil } }) }
	public static var unhide: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .unhide(let x) = binding { return x } else { return nil } }) }
	public static var unhideAllApplications: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .unhideAllApplications(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	public static var didBecomeActive: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeActive(let x) = binding { return x } else { return nil } }) }
	public static var didChangeOcclusionState: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didChangeOcclusionState(let x) = binding { return x } else { return nil } }) }
	public static var didChangeScreenParameters: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didChangeScreenParameters(let x) = binding { return x } else { return nil } }) }
	public static var didFinishLaunching: BindingParser<SignalInput<[AnyHashable: Any]>, Binding> { return BindingParser<SignalInput<[AnyHashable: Any]>, Binding>(parse: { binding -> Optional<SignalInput<[AnyHashable: Any]>> in if case .didFinishLaunching(let x) = binding { return x } else { return nil } }) }
	public static var didFinishRestoringWindows: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didFinishRestoringWindows(let x) = binding { return x } else { return nil } }) }
	public static var didHide: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didHide(let x) = binding { return x } else { return nil } }) }
	public static var didResignActive: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didResignActive(let x) = binding { return x } else { return nil } }) }
	public static var didUnhide: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didUnhide(let x) = binding { return x } else { return nil } }) }
	public static var didUpdate: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didUpdate(let x) = binding { return x } else { return nil } }) }
	public static var willBecomeActive: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willBecomeActive(let x) = binding { return x } else { return nil } }) }
	public static var willFinishLaunching: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willFinishLaunching(let x) = binding { return x } else { return nil } }) }
	public static var willHide: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willHide(let x) = binding { return x } else { return nil } }) }
	public static var willResignActive: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willResignActive(let x) = binding { return x } else { return nil } }) }
	public static var willUnhide: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willUnhide(let x) = binding { return x } else { return nil } }) }
	public static var willUpdate: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willUpdate(let x) = binding { return x } else { return nil } }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	public static var continueUserActivity: BindingParser<(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool> in if case .continueUserActivity(let x) = binding { return x } else { return nil } }) }
	public static var didDecodeRestorableState: BindingParser<(_ application: NSApplication, NSKeyedUnarchiver) -> Void, Binding> { return BindingParser<(_ application: NSApplication, NSKeyedUnarchiver) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, NSKeyedUnarchiver) -> Void> in if case .didDecodeRestorableState(let x) = binding { return x } else { return nil } }) }
	public static var didFailToContinueUserActivity: BindingParser<(_ application: NSApplication, _ userActivityType: String, _ error: Error) -> Void, Binding> { return BindingParser<(_ application: NSApplication, _ userActivityType: String, _ error: Error) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ userActivityType: String, _ error: Error) -> Void> in if case .didFailToContinueUserActivity(let x) = binding { return x } else { return nil } }) }
	public static var didFailToRegisterForRemoteNotifications: BindingParser<(_ application: NSApplication, _ error: Error) -> Void, Binding> { return BindingParser<(_ application: NSApplication, _ error: Error) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ error: Error) -> Void> in if case .didFailToRegisterForRemoteNotifications(let x) = binding { return x } else { return nil } }) }
	public static var didReceiveRemoteNotification: BindingParser<(_ application: NSApplication, _ notification: [String: Any]) -> Void, Binding> { return BindingParser<(_ application: NSApplication, _ notification: [String: Any]) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ notification: [String: Any]) -> Void> in if case .didReceiveRemoteNotification(let x) = binding { return x } else { return nil } }) }
	public static var didRegisterForRemoteNotifications: BindingParser<(_ application: NSApplication, _ token: Data) -> Void, Binding> { return BindingParser<(_ application: NSApplication, _ token: Data) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ token: Data) -> Void> in if case .didRegisterForRemoteNotifications(let x) = binding { return x } else { return nil } }) }
	public static var didUpdateUserActivity: BindingParser<(_ application: NSApplication, NSUserActivity) -> Void, Binding> { return BindingParser<(_ application: NSApplication, NSUserActivity) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, NSUserActivity) -> Void> in if case .didUpdateUserActivity(let x) = binding { return x } else { return nil } }) }
	public static var openFile: BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ filename: String) -> Bool> in if case .openFile(let x) = binding { return x } else { return nil } }) }
	public static var openFiles: BindingParser<(_ application: NSApplication, _ filenames: [String]) -> Void, Binding> { return BindingParser<(_ application: NSApplication, _ filenames: [String]) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ filenames: [String]) -> Void> in if case .openFiles(let x) = binding { return x } else { return nil } }) }
	public static var openFileWithoutUI: BindingParser<(_ application: Any, _ filename: String) -> Bool, Binding> { return BindingParser<(_ application: Any, _ filename: String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: Any, _ filename: String) -> Bool> in if case .openFileWithoutUI(let x) = binding { return x } else { return nil } }) }
	public static var openTempFile: BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ filename: String) -> Bool> in if case .openTempFile(let x) = binding { return x } else { return nil } }) }
	public static var openUntitledFile: BindingParser<(_ application: NSApplication) -> Bool, Binding> { return BindingParser<(_ application: NSApplication) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication) -> Bool> in if case .openUntitledFile(let x) = binding { return x } else { return nil } }) }
	public static var printFile: BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ filename: String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ filename: String) -> Bool> in if case .printFile(let x) = binding { return x } else { return nil } }) }
	public static var printFiles: BindingParser<(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -> NSApplication.PrintReply, Binding> { return BindingParser<(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -> NSApplication.PrintReply, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -> NSApplication.PrintReply> in if case .printFiles(let x) = binding { return x } else { return nil } }) }
	public static var shouldHandleReopen: BindingParser<(_ application: NSApplication, _ hasVisibleWindows: Bool) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ hasVisibleWindows: Bool) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ hasVisibleWindows: Bool) -> Bool> in if case .shouldHandleReopen(let x) = binding { return x } else { return nil } }) }
	public static var shouldOpenUntitledFile: BindingParser<(_ application: NSApplication) -> Bool, Binding> { return BindingParser<(_ application: NSApplication) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication) -> Bool> in if case .shouldOpenUntitledFile(let x) = binding { return x } else { return nil } }) }
	public static var shouldTerminate: BindingParser<(_ application: NSApplication) -> NSApplication.TerminateReply, Binding> { return BindingParser<(_ application: NSApplication) -> NSApplication.TerminateReply, Binding>(parse: { binding -> Optional<(_ application: NSApplication) -> NSApplication.TerminateReply> in if case .shouldTerminate(let x) = binding { return x } else { return nil } }) }
	public static var shouldTerminateAfterLastWindowClosed: BindingParser<(_ application: NSApplication) -> Bool, Binding> { return BindingParser<(_ application: NSApplication) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication) -> Bool> in if case .shouldTerminateAfterLastWindowClosed(let x) = binding { return x } else { return nil } }) }
	public static var userDidAcceptCloudKitShare: BindingParser<(_ application: NSApplication, CKShare.Metadata) -> Void, Binding> { return BindingParser<(_ application: NSApplication, CKShare.Metadata) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, CKShare.Metadata) -> Void> in if case .userDidAcceptCloudKitShare(let x) = binding { return x } else { return nil } }) }
	public static var willContinueUserActivity: BindingParser<(_ application: NSApplication, _ type: String) -> Bool, Binding> { return BindingParser<(_ application: NSApplication, _ type: String) -> Bool, Binding>(parse: { binding -> Optional<(_ application: NSApplication, _ type: String) -> Bool> in if case .willContinueUserActivity(let x) = binding { return x } else { return nil } }) }
	public static var willEncodeRestorableState: BindingParser<(_ application: NSApplication, NSKeyedArchiver) -> Void, Binding> { return BindingParser<(_ application: NSApplication, NSKeyedArchiver) -> Void, Binding>(parse: { binding -> Optional<(_ application: NSApplication, NSKeyedArchiver) -> Void> in if case .willEncodeRestorableState(let x) = binding { return x } else { return nil } }) }
	public static var willPresentError: BindingParser<(_ application: NSApplication, Error) -> Error, Binding> { return BindingParser<(_ application: NSApplication, Error) -> Error, Binding>(parse: { binding -> Optional<(_ application: NSApplication, Error) -> Error> in if case .willPresentError(let x) = binding { return x } else { return nil } }) }
	public static var willTerminate: BindingParser<(_ notification: Notification) -> Void, Binding> { return BindingParser<(_ notification: Notification) -> Void, Binding>(parse: { binding -> Optional<(_ notification: Notification) -> Void> in if case .willTerminate(let x) = binding { return x } else { return nil } }) }
}

#endif
