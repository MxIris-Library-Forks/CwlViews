//
//  CwlTextView_macOS.swift
//  CwlViews
//
//  Created by Matt Gallagher on 2/4/19.
//  Copyright Â© 2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//

#if os(macOS)

extension BindingParser where Binding == TextView.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	public static var string: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .string(let x) = binding { return x } else { return nil } }) }
	public static var backgroundColor: BindingParser<Dynamic<NSColor>, Binding> { return BindingParser<Dynamic<NSColor>, Binding>(parse: { binding -> Optional<Dynamic<NSColor>> in if case .backgroundColor(let x) = binding { return x } else { return nil } }) }
	public static var drawsBackground: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .drawsBackground(let x) = binding { return x } else { return nil } }) }
	public static var isEditable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isEditable(let x) = binding { return x } else { return nil } }) }
	public static var isSelectable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isSelectable(let x) = binding { return x } else { return nil } }) }
	public static var isFieldEditor: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isFieldEditor(let x) = binding { return x } else { return nil } }) }
	public static var isRichText: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isRichText(let x) = binding { return x } else { return nil } }) }
	public static var importsGraphics: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .importsGraphics(let x) = binding { return x } else { return nil } }) }
	public static var usesFontPanel: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesFontPanel(let x) = binding { return x } else { return nil } }) }
	public static var font: BindingParser<Dynamic<NSFont>, Binding> { return BindingParser<Dynamic<NSFont>, Binding>(parse: { binding -> Optional<Dynamic<NSFont>> in if case .font(let x) = binding { return x } else { return nil } }) }
	public static var alignment: BindingParser<Dynamic<NSTextAlignment>, Binding> { return BindingParser<Dynamic<NSTextAlignment>, Binding>(parse: { binding -> Optional<Dynamic<NSTextAlignment>> in if case .alignment(let x) = binding { return x } else { return nil } }) }
	public static var textColor: BindingParser<Dynamic<NSColor>, Binding> { return BindingParser<Dynamic<NSColor>, Binding>(parse: { binding -> Optional<Dynamic<NSColor>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	public static var baseWritingDirection: BindingParser<Dynamic<NSWritingDirection>, Binding> { return BindingParser<Dynamic<NSWritingDirection>, Binding>(parse: { binding -> Optional<Dynamic<NSWritingDirection>> in if case .baseWritingDirection(let x) = binding { return x } else { return nil } }) }
	public static var maxSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .maxSize(let x) = binding { return x } else { return nil } }) }
	public static var minSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .minSize(let x) = binding { return x } else { return nil } }) }
	public static var isVerticallyResizable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isVerticallyResizable(let x) = binding { return x } else { return nil } }) }
	public static var isHorizontallyResizable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isHorizontallyResizable(let x) = binding { return x } else { return nil } }) }
	
	public static var textContainerInset: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .textContainerInset(let x) = binding { return x } else { return nil } }) }
	public static var allowsDocumentBackgroundColorChange: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsDocumentBackgroundColorChange(let x) = binding { return x } else { return nil } }) }
	public static var allowsUndo: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsUndo(let x) = binding { return x } else { return nil } }) }
	public static var defaultParagraphStyle: BindingParser<Dynamic<NSParagraphStyle>, Binding> { return BindingParser<Dynamic<NSParagraphStyle>, Binding>(parse: { binding -> Optional<Dynamic<NSParagraphStyle>> in if case .defaultParagraphStyle(let x) = binding { return x } else { return nil } }) }
	public static var allowsImageEditing: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsImageEditing(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticQuoteSubstitutionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticQuoteSubstitutionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticLinkDetectionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticLinkDetectionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var displaysLinkToolTips: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .displaysLinkToolTips(let x) = binding { return x } else { return nil } }) }
	public static var usesRuler: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesRuler(let x) = binding { return x } else { return nil } }) }
	public static var usesInspectorBar: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesInspectorBar(let x) = binding { return x } else { return nil } }) }
	public static var selectionGranularity: BindingParser<Dynamic<NSSelectionGranularity>, Binding> { return BindingParser<Dynamic<NSSelectionGranularity>, Binding>(parse: { binding -> Optional<Dynamic<NSSelectionGranularity>> in if case .selectionGranularity(let x) = binding { return x } else { return nil } }) }
	public static var insertionPointColor: BindingParser<Dynamic<NSColor>, Binding> { return BindingParser<Dynamic<NSColor>, Binding>(parse: { binding -> Optional<Dynamic<NSColor>> in if case .insertionPointColor(let x) = binding { return x } else { return nil } }) }
	public static var selectedTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key : Any]>> in if case .selectedTextAttributes(let x) = binding { return x } else { return nil } }) }
	public static var markedTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key : Any]>> in if case .markedTextAttributes(let x) = binding { return x } else { return nil } }) }
	public static var linkTextAttributes: BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key : Any]>> in if case .linkTextAttributes(let x) = binding { return x } else { return nil } }) }
	public static var typingAttributes: BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding> { return BindingParser<Dynamic<[NSAttributedString.Key : Any]>, Binding>(parse: { binding -> Optional<Dynamic<[NSAttributedString.Key : Any]>> in if case .typingAttributes(let x) = binding { return x } else { return nil } }) }
	public static var isContinuousSpellCheckingEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isContinuousSpellCheckingEnabled(let x) = binding { return x } else { return nil } }) }
	public static var isGrammarCheckingEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isGrammarCheckingEnabled(let x) = binding { return x } else { return nil } }) }
	public static var usesFindPanel: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesFindPanel(let x) = binding { return x } else { return nil } }) }
	public static var enabledTextCheckingTypes: BindingParser<Dynamic<NSTextCheckingTypes>, Binding> { return BindingParser<Dynamic<NSTextCheckingTypes>, Binding>(parse: { binding -> Optional<Dynamic<NSTextCheckingTypes>> in if case .enabledTextCheckingTypes(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticDashSubstitutionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticDashSubstitutionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticDataDetectionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticDataDetectionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticSpellingCorrectionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticSpellingCorrectionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticTextReplacementEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticTextReplacementEnabled(let x) = binding { return x } else { return nil } }) }
	public static var layoutOrientation: BindingParser<Dynamic<NSLayoutManager.TextLayoutOrientation>, Binding> { return BindingParser<Dynamic<NSLayoutManager.TextLayoutOrientation>, Binding>(parse: { binding -> Optional<Dynamic<NSLayoutManager.TextLayoutOrientation>> in if case .layoutOrientation(let x) = binding { return x } else { return nil } }) }
	public static var usesFindBar: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesFindBar(let x) = binding { return x } else { return nil } }) }
	public static var isIncrementalSearchingEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isIncrementalSearchingEnabled(let x) = binding { return x } else { return nil } }) }
	public static var allowsCharacterPickerTouchBarItem: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsCharacterPickerTouchBarItem(let x) = binding { return x } else { return nil } }) }
	public static var isAutomaticTextCompletionEnabled: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutomaticTextCompletionEnabled(let x) = binding { return x } else { return nil } }) }
	public static var usesRolloverButtonForSelection: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .usesRolloverButtonForSelection(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	public static var selectRange: BindingParser<Signal<NSRange>, Binding> { return BindingParser<Signal<NSRange>, Binding>(parse: { binding -> Optional<Signal<NSRange>> in if case .selectRange(let x) = binding { return x } else { return nil } }) }
	public static var selectAll: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .selectAll(let x) = binding { return x } else { return nil } }) }
	public static var copy: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .copy(let x) = binding { return x } else { return nil } }) }
	public static var cut: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .cut(let x) = binding { return x } else { return nil } }) }
	public static var paste: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .paste(let x) = binding { return x } else { return nil } }) }
	public static var copyFont: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .copyFont(let x) = binding { return x } else { return nil } }) }
	public static var pasteFont: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .pasteFont(let x) = binding { return x } else { return nil } }) }
	public static var copyRuler: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .copyRuler(let x) = binding { return x } else { return nil } }) }
	public static var pasteRuler: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .pasteRuler(let x) = binding { return x } else { return nil } }) }
	public static var delete: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .delete(let x) = binding { return x } else { return nil } }) }
	public static var changeFont: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .changeFont(let x) = binding { return x } else { return nil } }) }
	public static var alignCenter: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .alignCenter(let x) = binding { return x } else { return nil } }) }
	public static var alignLeft: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .alignLeft(let x) = binding { return x } else { return nil } }) }
	public static var alignRight: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .alignRight(let x) = binding { return x } else { return nil } }) }
	public static var superscript: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .superscript(let x) = binding { return x } else { return nil } }) }
	public static var `subscript`: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .`subscript`(let x) = binding { return x } else { return nil } }) }
	public static var unscript: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .unscript(let x) = binding { return x } else { return nil } }) }
	public static var underline: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .underline(let x) = binding { return x } else { return nil } }) }
	public static var checkSpelling: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .checkSpelling(let x) = binding { return x } else { return nil } }) }
	public static var showGuessPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .showGuessPanel(let x) = binding { return x } else { return nil } }) }
	public static var sizeToFit: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .sizeToFit(let x) = binding { return x } else { return nil } }) }
	public static var scrollRangeToVisible: BindingParser<Signal<NSRange>, Binding> { return BindingParser<Signal<NSRange>, Binding>(parse: { binding -> Optional<Signal<NSRange>> in if case .scrollRangeToVisible(let x) = binding { return x } else { return nil } }) }

	public static var showFindIndicator: BindingParser<Signal<NSRange>, Binding> { return BindingParser<Signal<NSRange>, Binding>(parse: { binding -> Optional<Signal<NSRange>> in if case .showFindIndicator(let x) = binding { return x } else { return nil } }) }
	public static var changeDocumentBackgroundColor: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .changeDocumentBackgroundColor(let x) = binding { return x } else { return nil } }) }
	public static var outline: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .outline(let x) = binding { return x } else { return nil } }) }
	public static var alignJustified: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .alignJustified(let x) = binding { return x } else { return nil } }) }
	public static var changeAttributes: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .changeAttributes(let x) = binding { return x } else { return nil } }) }
	public static var useStandardKerning: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .useStandardKerning(let x) = binding { return x } else { return nil } }) }
	public static var lowerBaseline: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .lowerBaseline(let x) = binding { return x } else { return nil } }) }
	public static var raiseBaseline: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .raiseBaseline(let x) = binding { return x } else { return nil } }) }
	public static var turnOffKerning: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .turnOffKerning(let x) = binding { return x } else { return nil } }) }
	public static var loosenKerning: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .loosenKerning(let x) = binding { return x } else { return nil } }) }
	public static var tightenKerning: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .tightenKerning(let x) = binding { return x } else { return nil } }) }
	public static var useStandardLigatures: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .useStandardLigatures(let x) = binding { return x } else { return nil } }) }
	public static var turnOffLigatures: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .turnOffLigatures(let x) = binding { return x } else { return nil } }) }
	public static var useAllLigatures: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .useAllLigatures(let x) = binding { return x } else { return nil } }) }
	public static var clicked: BindingParser<Signal<(Any, Int)>, Binding> { return BindingParser<Signal<(Any, Int)>, Binding>(parse: { binding -> Optional<Signal<(Any, Int)>> in if case .clicked(let x) = binding { return x } else { return nil } }) }
	public static var pasteAsPlainText: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .pasteAsPlainText(let x) = binding { return x } else { return nil } }) }
	public static var pasteAsRichText: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .pasteAsRichText(let x) = binding { return x } else { return nil } }) }
	public static var breakUndoCoalescing: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .breakUndoCoalescing(let x) = binding { return x } else { return nil } }) }
	public static var setSpellingState: BindingParser<Signal<(NSAttributedString.SpellingState, NSRange)>, Binding> { return BindingParser<Signal<(NSAttributedString.SpellingState, NSRange)>, Binding>(parse: { binding -> Optional<Signal<(NSAttributedString.SpellingState, NSRange)>> in if case .setSpellingState(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontSharingServicePicker: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontSharingServicePicker(let x) = binding { return x } else { return nil } }) }
	public static var startSpeaking: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .startSpeaking(let x) = binding { return x } else { return nil } }) }
	public static var stopSpeaking: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .stopSpeaking(let x) = binding { return x } else { return nil } }) }
	public static var performFindPanelAction: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .performFindPanelAction(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontLinkPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontLinkPanel(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontListPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontListPanel(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontSpacingPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontSpacingPanel(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontTablePanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontTablePanel(let x) = binding { return x } else { return nil } }) }
	public static var orderFrontSubstitutionsPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .orderFrontSubstitutionsPanel(let x) = binding { return x } else { return nil } }) }
	public static var complete: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .complete(let x) = binding { return x } else { return nil } }) }
	public static var checkTextInDocument: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .checkTextInDocument(let x) = binding { return x } else { return nil } }) }
	public static var checkTextInSelection: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .checkTextInSelection(let x) = binding { return x } else { return nil } }) }
	public static var checkText: BindingParser<Signal<(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])>, Binding> { return BindingParser<Signal<(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])>, Binding>(parse: { binding -> Optional<Signal<(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])>> in if case .checkText(let x) = binding { return x } else { return nil } }) }
	public static var updateQuickLookPreviewPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .updateQuickLookPreviewPanel(let x) = binding { return x } else { return nil } }) }
	public static var toggleQuickLookPreviewPanel: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .toggleQuickLookPreviewPanel(let x) = binding { return x } else { return nil } }) }
	public static var updateCandidates: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .updateCandidates(let x) = binding { return x } else { return nil } }) }
	public static var updateTextTouchBarItems: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .updateTextTouchBarItems(let x) = binding { return x } else { return nil } }) }
	public static var updateTouchBarItemIdentifiers: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .updateTouchBarItemIdentifiers(let x) = binding { return x } else { return nil } }) }

	// 3. Action bindings are triggered by the object after construction.
	public static var didBeginEditing: BindingParser<SignalInput<NSTextView>, Binding> { return BindingParser<SignalInput<NSTextView>, Binding>(parse: { binding -> Optional<SignalInput<NSTextView>> in if case .didBeginEditing(let x) = binding { return x } else { return nil } }) }
	public static var didChange: BindingParser<SignalInput<NSTextView>, Binding> { return BindingParser<SignalInput<NSTextView>, Binding>(parse: { binding -> Optional<SignalInput<NSTextView>> in if case .didChange(let x) = binding { return x } else { return nil } }) }
	public static var didEndEditing: BindingParser<SignalInput<(NSTextView, NSTextMovement?)>, Binding> { return BindingParser<SignalInput<(NSTextView, NSTextMovement?)>, Binding>(parse: { binding -> Optional<SignalInput<(NSTextView, NSTextMovement?)>> in if case .didEndEditing(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	public static var shouldBeginEditing: BindingParser<(NSTextView) -> Bool, Binding> { return BindingParser<(NSTextView) -> Bool, Binding>(parse: { binding -> Optional<(NSTextView) -> Bool> in if case .shouldBeginEditing(let x) = binding { return x } else { return nil } }) }
	public static var shouldEndEditing: BindingParser<(NSTextView) -> Bool, Binding> { return BindingParser<(NSTextView) -> Bool, Binding>(parse: { binding -> Optional<(NSTextView) -> Bool> in if case .shouldEndEditing(let x) = binding { return x } else { return nil } }) }
}

#endif
