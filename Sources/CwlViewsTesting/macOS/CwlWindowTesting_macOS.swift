//
//  CwlWindow_macOS.swift
//  CwlViews
//
//  Created by Matt Gallagher on 10/30/16.
//  Copyright Â© 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any purpose with or without
//  fee is hereby granted, provided that the above copyright notice and this permission notice
//  appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
//  SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
//  AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
//  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
//  OF THIS SOFTWARE.
//

#if os(macOS)

extension BindingParser where Binding == Window.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	public static var deferCreation: BindingParser<Constant<Bool>, Binding> { return BindingParser<Constant<Bool>, Binding>(parse: { binding -> Optional<Constant<Bool>> in if case .deferCreation(let x) = binding { return x } else { return nil } }) }
	public static var initialFirstResponderTag: BindingParser<Constant<Int>, Binding> { return BindingParser<Constant<Int>, Binding>(parse: { binding -> Optional<Constant<Int>> in if case .initialFirstResponderTag(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	public static var acceptsMouseMovedEvents: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .acceptsMouseMovedEvents(let x) = binding { return x } else { return nil } }) }
	public static var allowsConcurrentViewDrawing: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsConcurrentViewDrawing(let x) = binding { return x } else { return nil } }) }
	public static var allowsToolTipsWhenApplicationIsInactive: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .allowsToolTipsWhenApplicationIsInactive(let x) = binding { return x } else { return nil } }) }
	public static var alphaValue: BindingParser<Dynamic<CGFloat>, Binding> { return BindingParser<Dynamic<CGFloat>, Binding>(parse: { binding -> Optional<Dynamic<CGFloat>> in if case .alphaValue(let x) = binding { return x } else { return nil } }) }
	public static var animationBehavior: BindingParser<Dynamic<NSWindow.AnimationBehavior>, Binding> { return BindingParser<Dynamic<NSWindow.AnimationBehavior>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.AnimationBehavior>> in if case .animationBehavior(let x) = binding { return x } else { return nil } }) }
	public static var appearance: BindingParser<Dynamic<NSAppearance?>, Binding> { return BindingParser<Dynamic<NSAppearance?>, Binding>(parse: { binding -> Optional<Dynamic<NSAppearance?>> in if case .appearance(let x) = binding { return x } else { return nil } }) }
	public static var autorecalculatesKeyViewLoop: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .autorecalculatesKeyViewLoop(let x) = binding { return x } else { return nil } }) }
	public static var backingType: BindingParser<Dynamic<NSWindow.BackingStoreType>, Binding> { return BindingParser<Dynamic<NSWindow.BackingStoreType>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.BackingStoreType>> in if case .backingType(let x) = binding { return x } else { return nil } }) }
	public static var canBecomeVisibleWithoutLogin: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .canBecomeVisibleWithoutLogin(let x) = binding { return x } else { return nil } }) }
	public static var canHide: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .canHide(let x) = binding { return x } else { return nil } }) }
	public static var collectionBehavior: BindingParser<Dynamic<NSWindow.CollectionBehavior>, Binding> { return BindingParser<Dynamic<NSWindow.CollectionBehavior>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.CollectionBehavior>> in if case .collectionBehavior(let x) = binding { return x } else { return nil } }) }
	public static var colorSpace: BindingParser<Dynamic<NSColorSpace>, Binding> { return BindingParser<Dynamic<NSColorSpace>, Binding>(parse: { binding -> Optional<Dynamic<NSColorSpace>> in if case .colorSpace(let x) = binding { return x } else { return nil } }) }
	public static var contentAspectRatio: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .contentAspectRatio(let x) = binding { return x } else { return nil } }) }
	public static var contentHeight: BindingParser<Dynamic<WindowDimension>, Binding> { return BindingParser<Dynamic<WindowDimension>, Binding>(parse: { binding -> Optional<Dynamic<WindowDimension>> in if case .contentHeight(let x) = binding { return x } else { return nil } }) }
	public static var contentMaxSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .contentMaxSize(let x) = binding { return x } else { return nil } }) }
	public static var contentMinSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .contentMinSize(let x) = binding { return x } else { return nil } }) }
	public static var contentResizeIncrements: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .contentResizeIncrements(let x) = binding { return x } else { return nil } }) }
	public static var contentRelativity: BindingParser<Dynamic<WindowDimension.Relativity>, Binding> { return BindingParser<Dynamic<WindowDimension.Relativity>, Binding>(parse: { binding -> Optional<Dynamic<WindowDimension.Relativity>> in if case .contentRelativity(let x) = binding { return x } else { return nil } }) }
	public static var contentView: BindingParser<Dynamic<ViewConvertible>, Binding> { return BindingParser<Dynamic<ViewConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ViewConvertible>> in if case .contentView(let x) = binding { return x } else { return nil } }) }
	public static var contentWidth: BindingParser<Dynamic<WindowDimension>, Binding> { return BindingParser<Dynamic<WindowDimension>, Binding>(parse: { binding -> Optional<Dynamic<WindowDimension>> in if case .contentWidth(let x) = binding { return x } else { return nil } }) }
	public static var depthLimit: BindingParser<Dynamic<NSWindow.Depth?>, Binding> { return BindingParser<Dynamic<NSWindow.Depth?>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.Depth?>> in if case .depthLimit(let x) = binding { return x } else { return nil } }) }
	public static var displaysWhenScreenProfileChanges: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .displaysWhenScreenProfileChanges(let x) = binding { return x } else { return nil } }) }
	public static var frameAutosaveName: BindingParser<Dynamic<NSWindow.FrameAutosaveName>, Binding> { return BindingParser<Dynamic<NSWindow.FrameAutosaveName>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.FrameAutosaveName>> in if case .frameAutosaveName(let x) = binding { return x } else { return nil } }) }
	public static var frameHorizontal: BindingParser<Dynamic<WindowDimension>, Binding> { return BindingParser<Dynamic<WindowDimension>, Binding>(parse: { binding -> Optional<Dynamic<WindowDimension>> in if case .frameHorizontal(let x) = binding { return x } else { return nil } }) }
	public static var frameVertical: BindingParser<Dynamic<WindowDimension>, Binding> { return BindingParser<Dynamic<WindowDimension>, Binding>(parse: { binding -> Optional<Dynamic<WindowDimension>> in if case .frameVertical(let x) = binding { return x } else { return nil } }) }
	public static var hasShadow: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hasShadow(let x) = binding { return x } else { return nil } }) }
	public static var hidesOnDeactivate: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .hidesOnDeactivate(let x) = binding { return x } else { return nil } }) }
	public static var ignoresMouseEvents: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .ignoresMouseEvents(let x) = binding { return x } else { return nil } }) }
	public static var isAutodisplay: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isAutodisplay(let x) = binding { return x } else { return nil } }) }
	public static var isDocumentEdited: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isDocumentEdited(let x) = binding { return x } else { return nil } }) }
	public static var isExcludedFromWindowsMenu: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isExcludedFromWindowsMenu(let x) = binding { return x } else { return nil } }) }
	public static var isMovable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isMovable(let x) = binding { return x } else { return nil } }) }
	public static var isMovableByWindowBackground: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isMovableByWindowBackground(let x) = binding { return x } else { return nil } }) }
	public static var isOneShot: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isOneShot(let x) = binding { return x } else { return nil } }) }
	public static var isOpaque: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isOpaque(let x) = binding { return x } else { return nil } }) }
	public static var isRestorable: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .isRestorable(let x) = binding { return x } else { return nil } }) }
	public static var key: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .key(let x) = binding { return x } else { return nil } }) }
	public static var level: BindingParser<Dynamic<NSWindow.Level>, Binding> { return BindingParser<Dynamic<NSWindow.Level>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.Level>> in if case .level(let x) = binding { return x } else { return nil } }) }
	public static var main: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .main(let x) = binding { return x } else { return nil } }) }
	public static var maxFullScreenContentSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .maxFullScreenContentSize(let x) = binding { return x } else { return nil } }) }
	public static var minFullScreenContentSize: BindingParser<Dynamic<NSSize>, Binding> { return BindingParser<Dynamic<NSSize>, Binding>(parse: { binding -> Optional<Dynamic<NSSize>> in if case .minFullScreenContentSize(let x) = binding { return x } else { return nil } }) }
	public static var miniwindowImage: BindingParser<Dynamic<NSImage?>, Binding> { return BindingParser<Dynamic<NSImage?>, Binding>(parse: { binding -> Optional<Dynamic<NSImage?>> in if case .miniwindowImage(let x) = binding { return x } else { return nil } }) }
	public static var miniwindowTitle: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .miniwindowTitle(let x) = binding { return x } else { return nil } }) }
	public static var order: BindingParser<Dynamic<WindowOrder>, Binding> { return BindingParser<Dynamic<WindowOrder>, Binding>(parse: { binding -> Optional<Dynamic<WindowOrder>> in if case .order(let x) = binding { return x } else { return nil } }) }
	public static var preferredBackingLocation: BindingParser<Dynamic<NSWindow.BackingLocation>, Binding> { return BindingParser<Dynamic<NSWindow.BackingLocation>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.BackingLocation>> in if case .preferredBackingLocation(let x) = binding { return x } else { return nil } }) }
	public static var preservesContentDuringLiveResize: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .preservesContentDuringLiveResize(let x) = binding { return x } else { return nil } }) }
	public static var preventsApplicationTerminationWhenModal: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .preventsApplicationTerminationWhenModal(let x) = binding { return x } else { return nil } }) }
	public static var representedURL: BindingParser<Dynamic<URL?>, Binding> { return BindingParser<Dynamic<URL?>, Binding>(parse: { binding -> Optional<Dynamic<URL?>> in if case .representedURL(let x) = binding { return x } else { return nil } }) }
	public static var resizeStyle: BindingParser<Dynamic<WindowResizeStyle>, Binding> { return BindingParser<Dynamic<WindowResizeStyle>, Binding>(parse: { binding -> Optional<Dynamic<WindowResizeStyle>> in if case .resizeStyle(let x) = binding { return x } else { return nil } }) }
	public static var restorationClass: BindingParser<Dynamic<NSWindowRestoration.Type>, Binding> { return BindingParser<Dynamic<NSWindowRestoration.Type>, Binding>(parse: { binding -> Optional<Dynamic<NSWindowRestoration.Type>> in if case .restorationClass(let x) = binding { return x } else { return nil } }) }
	public static var screen: BindingParser<Dynamic<NSScreen?>, Binding> { return BindingParser<Dynamic<NSScreen?>, Binding>(parse: { binding -> Optional<Dynamic<NSScreen?>> in if case .screen(let x) = binding { return x } else { return nil } }) }
	public static var sharingType: BindingParser<Dynamic<NSWindow.SharingType>, Binding> { return BindingParser<Dynamic<NSWindow.SharingType>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.SharingType>> in if case .sharingType(let x) = binding { return x } else { return nil } }) }
	public static var styleMask: BindingParser<Dynamic<NSWindow.StyleMask>, Binding> { return BindingParser<Dynamic<NSWindow.StyleMask>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.StyleMask>> in if case .styleMask(let x) = binding { return x } else { return nil } }) }
	public static var title: BindingParser<Dynamic<String>, Binding> { return BindingParser<Dynamic<String>, Binding>(parse: { binding -> Optional<Dynamic<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	public static var titlebarAppearsTransparent: BindingParser<Dynamic<Bool>, Binding> { return BindingParser<Dynamic<Bool>, Binding>(parse: { binding -> Optional<Dynamic<Bool>> in if case .titlebarAppearsTransparent(let x) = binding { return x } else { return nil } }) }
	public static var titleVisibility: BindingParser<Dynamic<NSWindow.TitleVisibility>, Binding> { return BindingParser<Dynamic<NSWindow.TitleVisibility>, Binding>(parse: { binding -> Optional<Dynamic<NSWindow.TitleVisibility>> in if case .titleVisibility(let x) = binding { return x } else { return nil } }) }
	public static var toolbar: BindingParser<Dynamic<ToolbarConvertible>, Binding> { return BindingParser<Dynamic<ToolbarConvertible>, Binding>(parse: { binding -> Optional<Dynamic<ToolbarConvertible>> in if case .toolbar(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	public static var close: BindingParser<Signal<WindowCloseBehavior>, Binding> { return BindingParser<Signal<WindowCloseBehavior>, Binding>(parse: { binding -> Optional<Signal<WindowCloseBehavior>> in if case .close(let x) = binding { return x } else { return nil } }) }
	public static var criticalSheet: BindingParser<Signal<Callback<NSWindow, NSApplication.ModalResponse>>, Binding> { return BindingParser<Signal<Callback<NSWindow, NSApplication.ModalResponse>>, Binding>(parse: { binding -> Optional<Signal<Callback<NSWindow, NSApplication.ModalResponse>>> in if case .criticalSheet(let x) = binding { return x } else { return nil } }) }
	public static var deminiaturize: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .deminiaturize(let x) = binding { return x } else { return nil } }) }
	public static var display: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .display(let x) = binding { return x } else { return nil } }) }
	public static var invalidateShadow: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .invalidateShadow(let x) = binding { return x } else { return nil } }) }
	public static var miniaturize: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .miniaturize(let x) = binding { return x } else { return nil } }) }
	public static var presentError: BindingParser<Signal<Callback<Error, Bool>>, Binding> { return BindingParser<Signal<Callback<Error, Bool>>, Binding>(parse: { binding -> Optional<Signal<Callback<Error, Bool>>> in if case .presentError(let x) = binding { return x } else { return nil } }) }
	public static var printWindow: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .printWindow(let x) = binding { return x } else { return nil } }) }
	public static var recalculateKeyViewLoop: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .recalculateKeyViewLoop(let x) = binding { return x } else { return nil } }) }
	public static var runToolbarCustomizationPalette: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .runToolbarCustomizationPalette(let x) = binding { return x } else { return nil } }) }
	public static var selectNextKeyView: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .selectNextKeyView(let x) = binding { return x } else { return nil } }) }
	public static var selectPreviousKeyView: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .selectPreviousKeyView(let x) = binding { return x } else { return nil } }) }
	public static var sheet: BindingParser<Signal<Callback<NSWindow, NSApplication.ModalResponse>>, Binding> { return BindingParser<Signal<Callback<NSWindow, NSApplication.ModalResponse>>, Binding>(parse: { binding -> Optional<Signal<Callback<NSWindow, NSApplication.ModalResponse>>> in if case .sheet(let x) = binding { return x } else { return nil } }) }
	public static var toggleFullScreen: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .toggleFullScreen(let x) = binding { return x } else { return nil } }) }
	public static var toggleToolbarShown: BindingParser<Signal<Void>, Binding> { return BindingParser<Signal<Void>, Binding>(parse: { binding -> Optional<Signal<Void>> in if case .toggleToolbarShown(let x) = binding { return x } else { return nil } }) }
	public static var zoom: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .zoom(let x) = binding { return x } else { return nil } }) }
	
	// 3. Action bindings are triggered by the object after construction.
	public static var effectiveAppearanceName: BindingParser<SignalInput<NSAppearance.Name>, Binding> { return BindingParser<SignalInput<NSAppearance.Name>, Binding>(parse: { binding -> Optional<SignalInput<NSAppearance.Name>> in if case .effectiveAppearanceName(let x) = binding { return x } else { return nil } }) }
	public static var didBecomeKey: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeKey(let x) = binding { return x } else { return nil } }) }
	public static var didBecomeMain: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didBecomeMain(let x) = binding { return x } else { return nil } }) }
	public static var didChangeBackingProperties: BindingParser<SignalInput<(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)>, Binding> { return BindingParser<SignalInput<(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)>, Binding>(parse: { binding -> Optional<SignalInput<(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)>> in if case .didChangeBackingProperties(let x) = binding { return x } else { return nil } }) }
	public static var didChangeOcclusionState: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didChangeOcclusionState(let x) = binding { return x } else { return nil } }) }
	public static var didChangeScreen: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didChangeScreen(let x) = binding { return x } else { return nil } }) }
	public static var didChangeScreenProfile: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didChangeScreenProfile(let x) = binding { return x } else { return nil } }) }
	public static var didDeminiaturize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didDeminiaturize(let x) = binding { return x } else { return nil } }) }
	public static var didEndLiveResize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didEndLiveResize(let x) = binding { return x } else { return nil } }) }
	public static var didEndSheet: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didEndSheet(let x) = binding { return x } else { return nil } }) }
	public static var didEnterFullScreen: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didEnterFullScreen(let x) = binding { return x } else { return nil } }) }
	public static var didEnterVersionBrowser: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didEnterVersionBrowser(let x) = binding { return x } else { return nil } }) }
	public static var didExitFullScreen: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didExitFullScreen(let x) = binding { return x } else { return nil } }) }
	public static var didExitVersionBrowser: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didExitVersionBrowser(let x) = binding { return x } else { return nil } }) }
	public static var didExpose: BindingParser<SignalInput<NSRect>, Binding> { return BindingParser<SignalInput<NSRect>, Binding>(parse: { binding -> Optional<SignalInput<NSRect>> in if case .didExpose(let x) = binding { return x } else { return nil } }) }
	public static var didMiniaturize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didMiniaturize(let x) = binding { return x } else { return nil } }) }
	public static var didMove: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didMove(let x) = binding { return x } else { return nil } }) }
	public static var didResignKey: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didResignKey(let x) = binding { return x } else { return nil } }) }
	public static var didResignMain: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didResignMain(let x) = binding { return x } else { return nil } }) }
	public static var didResize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didResize(let x) = binding { return x } else { return nil } }) }
	public static var didUpdate: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .didUpdate(let x) = binding { return x } else { return nil } }) }
	public static var willBeginSheet: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willBeginSheet(let x) = binding { return x } else { return nil } }) }
	public static var willClose: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willClose(let x) = binding { return x } else { return nil } }) }
	public static var willEnterFullScreen: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willEnterFullScreen(let x) = binding { return x } else { return nil } }) }
	public static var willEnterVersionBrowser: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willEnterVersionBrowser(let x) = binding { return x } else { return nil } }) }
	public static var willExitFullScreen: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willExitFullScreen(let x) = binding { return x } else { return nil } }) }
	public static var willExitVersionBrowser: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willExitVersionBrowser(let x) = binding { return x } else { return nil } }) }
	public static var willMiniaturize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willMiniaturize(let x) = binding { return x } else { return nil } }) }
	public static var willMove: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willMove(let x) = binding { return x } else { return nil } }) }
	public static var willStartLiveResize: BindingParser<SignalInput<Void>, Binding> { return BindingParser<SignalInput<Void>, Binding>(parse: { binding -> Optional<SignalInput<Void>> in if case .willStartLiveResize(let x) = binding { return x } else { return nil } }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	public static var shouldClose: BindingParser<(NSWindow) -> Bool, Binding> { return BindingParser<(NSWindow) -> Bool, Binding>(parse: { binding -> Optional<(NSWindow) -> Bool> in if case .shouldClose(let x) = binding { return x } else { return nil } }) }
	public static var shouldPopUpDocumentPathMenu: BindingParser<(NSWindow, NSMenu) -> Bool, Binding> { return BindingParser<(NSWindow, NSMenu) -> Bool, Binding>(parse: { binding -> Optional<(NSWindow, NSMenu) -> Bool> in if case .shouldPopUpDocumentPathMenu(let x) = binding { return x } else { return nil } }) }
	public static var shouldZoom: BindingParser<(NSWindow, NSRect) -> Bool, Binding> { return BindingParser<(NSWindow, NSRect) -> Bool, Binding>(parse: { binding -> Optional<(NSWindow, NSRect) -> Bool> in if case .shouldZoom(let x) = binding { return x } else { return nil } }) }
	public static var willResize: BindingParser<(NSWindow, NSSize) -> NSSize, Binding> { return BindingParser<(NSWindow, NSSize) -> NSSize, Binding>(parse: { binding -> Optional<(NSWindow, NSSize) -> NSSize> in if case .willResize(let x) = binding { return x } else { return nil } }) }
	public static var willResizeForVersionBrowser: BindingParser<(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -> NSSize, Binding> { return BindingParser<(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -> NSSize, Binding>(parse: { binding -> Optional<(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -> NSSize> in if case .willResizeForVersionBrowser(let x) = binding { return x } else { return nil } }) }
	public static var willUseFullScreenContentSize: BindingParser<(NSWindow, NSSize) -> NSSize, Binding> { return BindingParser<(NSWindow, NSSize) -> NSSize, Binding>(parse: { binding -> Optional<(NSWindow, NSSize) -> NSSize> in if case .willUseFullScreenContentSize(let x) = binding { return x } else { return nil } }) }
	public static var willUseFullScreenPresentationOptions: BindingParser<(NSWindow, NSApplication.PresentationOptions) -> NSApplication.PresentationOptions, Binding> { return BindingParser<(NSWindow, NSApplication.PresentationOptions) -> NSApplication.PresentationOptions, Binding>(parse: { binding -> Optional<(NSWindow, NSApplication.PresentationOptions) -> NSApplication.PresentationOptions> in if case .willUseFullScreenPresentationOptions(let x) = binding { return x } else { return nil } }) }
	public static var willUseStandardFrame: BindingParser<(NSWindow, NSRect) -> NSRect, Binding> { return BindingParser<(NSWindow, NSRect) -> NSRect, Binding>(parse: { binding -> Optional<(NSWindow, NSRect) -> NSRect> in if case .willUseStandardFrame(let x) = binding { return x } else { return nil } }) }
}

#endif
